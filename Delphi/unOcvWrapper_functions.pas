Function   pCvdetail_AffineBasedEstimatorCreate(): PCvdetail_AffineBasedEstimator_t; cdecl;
Procedure  pCvdetail_AffineBasedEstimatorDelete(const wrapper: PCvdetail_AffineBasedEstimator_t); cdecl;
Function   pCvdetail_AffineBestOf2NearestMatcherCreate(full_affine: Boolean { default: false } = false; 
                 try_use_gpu: Boolean { default: false } = false; match_conf: Single { default: 0.3f } = 0.3; 
                 num_matches_thresh1: Integer { default: 6 } = 6): PCvdetail_AffineBestOf2NearestMatcher_t; cdecl;
Procedure  pCvdetail_AffineBestOf2NearestMatcherDelete(const wrapper: PCvdetail_AffineBestOf2NearestMatcher_t); cdecl;
Function   pCvAsyncArrayCreate(): PCvAsyncArray_t; cdecl;
Procedure  pCvAsyncArrayDelete(const wrapper: PCvAsyncArray_t); cdecl;
Function   pCvBFMatcherCreate(normType: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 crossCheck: Boolean { default: false } = false): PCvBFMatcher_t; cdecl;
Procedure  pCvBFMatcherDelete(const wrapper: PCvBFMatcher_t); cdecl;
Function   pCvBOWImgDescriptorExtractorCreate(dextractor: PCvPtr_DescriptorExtractor; 
                 dmatcher: PCvPtr_DescriptorMatcher): PCvBOWImgDescriptorExtractor_t; cdecl;
Procedure  pCvBOWImgDescriptorExtractorDelete(const wrapper: PCvBOWImgDescriptorExtractor_t); cdecl;
Function   pCvBOWKMeansTrainerCreate(clusterCount: Integer; 
                 termcrit: PCvTermCriteria_t { default: TermCriteria() } = nil; attempts: Integer { default: 3 } = 3; 
                 flags: Integer { default: KMEANS_PP_CENTERS } = ord(KMEANS_PP_CENTERS)): PCvBOWKMeansTrainer_t; cdecl;
Procedure  pCvBOWKMeansTrainerDelete(const wrapper: PCvBOWKMeansTrainer_t); cdecl;
Function   pCvdetail_BestOf2NearestMatcherCreate(try_use_gpu: Boolean { default: false } = false; 
                 match_conf: Single { default: 0.3f } = 0.3; num_matches_thresh1: Integer { default: 6 } = 6; 
                 num_matches_thresh2: Integer { default: 6 } = 6): PCvdetail_BestOf2NearestMatcher_t; cdecl;
Procedure  pCvdetail_BestOf2NearestMatcherDelete(const wrapper: PCvdetail_BestOf2NearestMatcher_t); cdecl;
Function   pCvdetail_BestOf2NearestRangeMatcherCreate(range_width: Integer { default: 5 } = 5; 
                 try_use_gpu: Boolean { default: false } = false; match_conf: Single { default: 0.3f } = 0.3; 
                 num_matches_thresh1: Integer { default: 6 } = 6; num_matches_thresh2: Integer { default: 6 } = 6): PCvdetail_BestOf2NearestRangeMatcher_t; cdecl;
Procedure  pCvdetail_BestOf2NearestRangeMatcherDelete(const wrapper: PCvdetail_BestOf2NearestRangeMatcher_t); cdecl;
Function   pCvdetail_BlocksChannelsCompensatorCreate(bl_width: Integer { default: 32 } = 32; 
                 bl_height: Integer { default: 32 } = 32; nr_feeds: Integer { default: 1 } = 1): PCvdetail_BlocksChannelsCompensator_t; cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorDelete(const wrapper: PCvdetail_BlocksChannelsCompensator_t); cdecl;
Function   pCvdetail_BlocksGainCompensatorCreate(bl_width: Integer { default: 32 } = 32; 
                 bl_height: Integer { default: 32 } = 32): PCvdetail_BlocksGainCompensator_t; cdecl;
Function   pCvdetail_BlocksGainCompensatorCreateV2(bl_width: Integer; bl_height: Integer; 
                 nr_feeds: Integer): PCvdetail_BlocksGainCompensator_t; cdecl;
Procedure  pCvdetail_BlocksGainCompensatorDelete(const wrapper: PCvdetail_BlocksGainCompensator_t); cdecl;
Function   pCvdetail_BundleAdjusterAffineCreate(): PCvdetail_BundleAdjusterAffine_t; cdecl;
Procedure  pCvdetail_BundleAdjusterAffineDelete(const wrapper: PCvdetail_BundleAdjusterAffine_t); cdecl;
Function   pCvdetail_BundleAdjusterAffinePartialCreate(): PCvdetail_BundleAdjusterAffinePartial_t; cdecl;
Procedure  pCvdetail_BundleAdjusterAffinePartialDelete(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t); cdecl;
Function   pCvdetail_BundleAdjusterRayCreate(): PCvdetail_BundleAdjusterRay_t; cdecl;
Procedure  pCvdetail_BundleAdjusterRayDelete(const wrapper: PCvdetail_BundleAdjusterRay_t); cdecl;
Function   pCvdetail_BundleAdjusterReprojCreate(): PCvdetail_BundleAdjusterReproj_t; cdecl;
Procedure  pCvdetail_BundleAdjusterReprojDelete(const wrapper: PCvdetail_BundleAdjusterReproj_t); cdecl;
Function   pCvCascadeClassifierCreate(): PCvCascadeClassifier_t; cdecl;
Function   pCvCascadeClassifierCreateV2(filename: PCvString_t): PCvCascadeClassifier_t; cdecl;
Procedure  pCvCascadeClassifierDelete(const wrapper: PCvCascadeClassifier_t); cdecl;
Function   pCvdetail_ChannelsCompensatorCreate(nr_feeds: Integer { default: 1 } = 1): PCvdetail_ChannelsCompensator_t; cdecl;
Procedure  pCvdetail_ChannelsCompensatorDelete(const wrapper: PCvdetail_ChannelsCompensator_t); cdecl;
Function   pCvCirclesGridFinderParametersCreate(): PCvCirclesGridFinderParameters_t; cdecl;
Procedure  pCvCirclesGridFinderParametersDelete(const wrapper: PCvCirclesGridFinderParameters_t); cdecl;
Function   pCvdnn_ClassificationModelCreate(model: PCvString_t; 
                 config: PCvString_t { default: "" } = nil): PCvdnn_ClassificationModel_t; cdecl;
Function   pCvdnn_ClassificationModelCreateV2(network: PCvdnn_Net_t): PCvdnn_ClassificationModel_t; cdecl;
Procedure  pCvdnn_ClassificationModelDelete(const wrapper: PCvdnn_ClassificationModel_t); cdecl;
Function   pCvDMatchCreate(): PCvDMatch_t; cdecl;
Function   pCvDMatchCreateV2(_queryIdx: Integer; _trainIdx: Integer; _distance: Single): PCvDMatch_t; cdecl;
Function   pCvDMatchCreateV3(_queryIdx: Integer; _trainIdx: Integer; _imgIdx: Integer; _distance: Single): PCvDMatch_t; cdecl;
Procedure  pCvDMatchDelete(const wrapper: PCvDMatch_t); cdecl;
Function   pCvdnn_DetectionModelCreate(model: PCvString_t; config: PCvString_t { default: "" } = nil): PCvdnn_DetectionModel_t; cdecl;
Function   pCvdnn_DetectionModelCreateV2(network: PCvdnn_Net_t): PCvdnn_DetectionModel_t; cdecl;
Procedure  pCvdnn_DetectionModelDelete(const wrapper: PCvdnn_DetectionModel_t); cdecl;
Function   pCvocl_DeviceCreate(): PCvocl_Device_t; cdecl;
Procedure  pCvocl_DeviceDelete(const wrapper: PCvocl_Device_t); cdecl;
Function   pCvdnn_DictValueCreate(i: Integer): PCvdnn_DictValue_t; cdecl;
Function   pCvdnn_DictValueCreateV2(p: Double): PCvdnn_DictValue_t; cdecl;
Function   pCvdnn_DictValueCreateV3(s: PCvString_t): PCvdnn_DictValue_t; cdecl;
Procedure  pCvdnn_DictValueDelete(const wrapper: PCvdnn_DictValue_t); cdecl;
Function   pCvdetail_DpSeamFinderCreate(costFunc: PCvString_t): PCvdetail_DpSeamFinder_t; cdecl;
Procedure  pCvdetail_DpSeamFinderDelete(const wrapper: PCvdetail_DpSeamFinder_t); cdecl;
Function   pCvdetail_FeatherBlenderCreate(sharpness: Single { default: 0.02f } = 0.02): PCvdetail_FeatherBlender_t; cdecl;
Procedure  pCvdetail_FeatherBlenderDelete(const wrapper: PCvdetail_FeatherBlender_t); cdecl;
Function   pCvFileNodeCreate(): PCvFileNode_t; cdecl;
Procedure  pCvFileNodeDelete(const wrapper: PCvFileNode_t); cdecl;
Function   pCvFileStorageCreate(): PCvFileStorage_t; cdecl;
Function   pCvFileStorageCreateV2(filename: PCvString_t; flags: Integer; 
                 encoding: PCvString_t { default: String() } = nil): PCvFileStorage_t; cdecl;
Procedure  pCvFileStorageDelete(const wrapper: PCvFileStorage_t); cdecl;
Function   pCvFlannBasedMatcherCreate(
                 indexParams: PCvPtr_flann_IndexParams { default: makePtr<flann::KDTreeIndexParams>() } = nil; 
                 searchParams: PCvPtr_flann_SearchParams { default: makePtr<flann::SearchParams>() } = nil): PCvFlannBasedMatcher_t; cdecl;
Procedure  pCvFlannBasedMatcherDelete(const wrapper: PCvFlannBasedMatcher_t); cdecl;
Function   pCvdetail_GainCompensatorCreate(): PCvdetail_GainCompensator_t; cdecl;
Function   pCvdetail_GainCompensatorCreateV2(nr_feeds: Integer): PCvdetail_GainCompensator_t; cdecl;
Procedure  pCvdetail_GainCompensatorDelete(const wrapper: PCvdetail_GainCompensator_t); cdecl;
Function   pCvdetail_GraphCutSeamFinderCreate(cost_type: PCvString_t; 
                 terminal_cost: Single { default: 10000.f } = 10000.0; bad_region_penalty: Single { default: 1000.f } = 1000.0): PCvdetail_GraphCutSeamFinder_t; cdecl;
Procedure  pCvdetail_GraphCutSeamFinderDelete(const wrapper: PCvdetail_GraphCutSeamFinder_t); cdecl;
Function   pCvHOGDescriptorCreate(): PCvHOGDescriptor_t; cdecl;
Function   pCvHOGDescriptorCreateV2(_winSize: PCvSize_t; _blockSize: PCvSize_t; _blockStride: PCvSize_t; 
                 _cellSize: PCvSize_t; _nbins: Integer; _derivAperture: Integer { default: 1 } = 1; 
                 _winSigma: Double { default: -1 } = ord(-1); 
                 _histogramNormType: TCvHOGDescriptor_HistogramNormType { default: HOGDescriptor::L2Hys } = TCvHOGDescriptor_HistogramNormType.L2Hys; _L2HysThreshold: Double { default: 0.2 } = 0.2; 
                 _gammaCorrection: Boolean { default: false } = false; 
                 _nlevels: Integer { default: HOGDescriptor::DEFAULT_NLEVELS } = ord(HOGDescriptor_DEFAULT_NLEVELS); _signedGradient: Boolean { default: false } = false): PCvHOGDescriptor_t; cdecl;
Function   pCvHOGDescriptorCreateV3(filename: PCvString_t): PCvHOGDescriptor_t; cdecl;
Procedure  pCvHOGDescriptorDelete(const wrapper: PCvHOGDescriptor_t); cdecl;
Function   pCvdetail_HomographyBasedEstimatorCreate(
                 is_focals_estimated: Boolean { default: false } = false): PCvdetail_HomographyBasedEstimator_t; cdecl;
Procedure  pCvdetail_HomographyBasedEstimatorDelete(const wrapper: PCvdetail_HomographyBasedEstimator_t); cdecl;
Function   pCvflann_IndexCreate(): PCvflann_Index_t; cdecl;
Function   pCvflann_IndexCreateV2(features: PCvMat_t; params: PCvIndexParams_t; 
                 distType: TCvcvflann_flann_distance_t { default: cvflann::FLANN_DIST_L2 } = TCvcvflann_flann_distance_t.FLANN_DIST_L2): PCvflann_Index_t; cdecl;
Function   pCvflann_IndexCreateV3(features: PCvUMat_t; params: PCvIndexParams_t; 
                 distType: TCvcvflann_flann_distance_t { default: cvflann::FLANN_DIST_L2 } = TCvcvflann_flann_distance_t.FLANN_DIST_L2): PCvflann_Index_t; cdecl;
Procedure  pCvflann_IndexDelete(const wrapper: PCvflann_Index_t); cdecl;
Function   pCvsegmentation_IntelligentScissorsMBCreate(): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Procedure  pCvsegmentation_IntelligentScissorsMBDelete(const wrapper: PCvsegmentation_IntelligentScissorsMB_t); cdecl;
Function   pCvml_KDTreeCreate(): PCvml_KDTree_t; cdecl;
Function   pCvml_KDTreeCreateV2(points: PCvMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false): PCvml_KDTree_t; cdecl;
Function   pCvml_KDTreeCreateV3(points: PCvUMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false): PCvml_KDTree_t; cdecl;
Function   pCvml_KDTreeCreateV4(points: PCvMat_t; _labels: PCvMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false): PCvml_KDTree_t; cdecl;
Function   pCvml_KDTreeCreateV5(points: PCvUMat_t; _labels: PCvUMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false): PCvml_KDTree_t; cdecl;
Procedure  pCvml_KDTreeDelete(const wrapper: PCvml_KDTree_t); cdecl;
Function   pCvKalmanFilterCreate(): PCvKalmanFilter_t; cdecl;
Function   pCvKalmanFilterCreateV2(dynamParams: Integer; measureParams: Integer; 
                 controlParams: Integer { default: 0 } = 0; _type: Integer { default: CV_32F } = ord(CV_32F)): PCvKalmanFilter_t; cdecl;
Procedure  pCvKalmanFilterDelete(const wrapper: PCvKalmanFilter_t); cdecl;
Function   pCvKeyPointCreate(): PCvKeyPoint_t; cdecl;
Function   pCvKeyPointCreateV2(x: Single; y: Single; size: Single; 
                 angle: Single { default: -1 } = ord(-1); response: Single { default: 0 } = 0; octave: Integer { default: 0 } = 0; 
                 class_id: Integer { default: -1 } = ord(-1)): PCvKeyPoint_t; cdecl;
Procedure  pCvKeyPointDelete(const wrapper: PCvKeyPoint_t); cdecl;
Function   pCvdnn_KeypointsModelCreate(model: PCvString_t; config: PCvString_t { default: "" } = nil): PCvdnn_KeypointsModel_t; cdecl;
Function   pCvdnn_KeypointsModelCreateV2(network: PCvdnn_Net_t): PCvdnn_KeypointsModel_t; cdecl;
Procedure  pCvdnn_KeypointsModelDelete(const wrapper: PCvdnn_KeypointsModel_t); cdecl;
Function   pCvdnn_ModelCreate(model: PCvString_t; config: PCvString_t { default: "" } = nil): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelCreateV2(network: PCvdnn_Net_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_ModelDelete(const wrapper: PCvdnn_Model_t); cdecl;
Function   pCvdetail_MultiBandBlenderCreate(try_gpu: Integer { default: false } = 0; 
                 num_bands: Integer { default: 5 } = 5; weight_type: Integer { default: CV_32F } = ord(CV_32F)): PCvdetail_MultiBandBlender_t; cdecl;
Procedure  pCvdetail_MultiBandBlenderDelete(const wrapper: PCvdetail_MultiBandBlender_t); cdecl;
Function   pCvdnn_NetCreate(): PCvdnn_Net_t; cdecl;
Procedure  pCvdnn_NetDelete(const wrapper: PCvdnn_Net_t); cdecl;
Function   pCvdetail_NoBundleAdjusterCreate(): PCvdetail_NoBundleAdjuster_t; cdecl;
Procedure  pCvdetail_NoBundleAdjusterDelete(const wrapper: PCvdetail_NoBundleAdjuster_t); cdecl;
Function   pCvutils_nested_OriginalClassName_ParamsCreate(int_param: Integer { default: 123 } = 123; 
                 float_param: Single { default: 3.5f } = 3.5): PCvutils_nested_OriginalClassName_Params_t; cdecl;
Procedure  pCvutils_nested_OriginalClassName_ParamsDelete(const wrapper: PCvutils_nested_OriginalClassName_Params_t); cdecl;
Function   pCvPyRotationWarperCreate(_type: PCvString_t; scale: Single): PCvPyRotationWarper_t; cdecl;
Function   pCvPyRotationWarperCreateV2(): PCvPyRotationWarper_t; cdecl;
Procedure  pCvPyRotationWarperDelete(const wrapper: PCvPyRotationWarper_t); cdecl;
Function   pCvQRCodeDetectorCreate(): PCvQRCodeDetector_t; cdecl;
Procedure  pCvQRCodeDetectorDelete(const wrapper: PCvQRCodeDetector_t); cdecl;
Function   pCvQRCodeEncoder_ParamsCreate(): PCvQRCodeEncoder_Params_t; cdecl;
Procedure  pCvQRCodeEncoder_ParamsDelete(const wrapper: PCvQRCodeEncoder_Params_t); cdecl;
Function   pCvdnn_SegmentationModelCreate(model: PCvString_t; config: PCvString_t { default: "" } = nil): PCvdnn_SegmentationModel_t; cdecl;
Function   pCvdnn_SegmentationModelCreateV2(network: PCvdnn_Net_t): PCvdnn_SegmentationModel_t; cdecl;
Procedure  pCvdnn_SegmentationModelDelete(const wrapper: PCvdnn_SegmentationModel_t); cdecl;
Function   pCvSimpleBlobDetector_ParamsCreate(): PCvSimpleBlobDetector_Params_t; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsDelete(const wrapper: PCvSimpleBlobDetector_Params_t); cdecl;
Function   pCvSubdiv2DCreate(): PCvSubdiv2D_t; cdecl;
Function   pCvSubdiv2DCreateV2(rect: PCvRect_t): PCvSubdiv2D_t; cdecl;
Procedure  pCvSubdiv2DDelete(const wrapper: PCvSubdiv2D_t); cdecl;
Function   pCvdnn_TextDetectionModel_DBCreate(network: PCvdnn_Net_t): PCvdnn_TextDetectionModel_DB_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBCreateV2(model: PCvString_t; 
                 config: PCvString_t { default: "" } = nil): PCvdnn_TextDetectionModel_DB_t; cdecl;
Procedure  pCvdnn_TextDetectionModel_DBDelete(const wrapper: PCvdnn_TextDetectionModel_DB_t); cdecl;
Function   pCvdnn_TextDetectionModel_EASTCreate(network: PCvdnn_Net_t): PCvdnn_TextDetectionModel_EAST_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTCreateV2(model: PCvString_t; 
                 config: PCvString_t { default: "" } = nil): PCvdnn_TextDetectionModel_EAST_t; cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTDelete(const wrapper: PCvdnn_TextDetectionModel_EAST_t); cdecl;
Function   pCvdnn_TextRecognitionModelCreate(network: PCvdnn_Net_t): PCvdnn_TextRecognitionModel_t; cdecl;
Function   pCvdnn_TextRecognitionModelCreateV2(model: PCvString_t; 
                 config: PCvString_t { default: "" } = nil): PCvdnn_TextRecognitionModel_t; cdecl;
Procedure  pCvdnn_TextRecognitionModelDelete(const wrapper: PCvdnn_TextRecognitionModel_t); cdecl;
Function   pCvTickMeterCreate(): PCvTickMeter_t; cdecl;
Procedure  pCvTickMeterDelete(const wrapper: PCvTickMeter_t); cdecl;
Function   pCvTrackerDaSiamRPN_ParamsCreate(): PCvTrackerDaSiamRPN_Params_t; cdecl;
Procedure  pCvTrackerDaSiamRPN_ParamsDelete(const wrapper: PCvTrackerDaSiamRPN_Params_t); cdecl;
Function   pCvTrackerGOTURN_ParamsCreate(): PCvTrackerGOTURN_Params_t; cdecl;
Procedure  pCvTrackerGOTURN_ParamsDelete(const wrapper: PCvTrackerGOTURN_Params_t); cdecl;
Function   pCvTrackerMIL_ParamsCreate(): PCvTrackerMIL_Params_t; cdecl;
Procedure  pCvTrackerMIL_ParamsDelete(const wrapper: PCvTrackerMIL_Params_t); cdecl;
Function   pCvUMatCreate(
                 usageFlags: TCvUMatUsageFlags { default: USAGE_DEFAULT } = TCvUMatUsageFlags.USAGE_DEFAULT): PCvUMat_t; cdecl;
Function   pCvUMatCreateV2(rows: Integer; cols: Integer; _type: Integer; 
                 usageFlags: TCvUMatUsageFlags { default: USAGE_DEFAULT } = TCvUMatUsageFlags.USAGE_DEFAULT): PCvUMat_t; cdecl;
Function   pCvUMatCreateV3(size: PCvSize_t; _type: Integer; 
                 usageFlags: TCvUMatUsageFlags { default: USAGE_DEFAULT } = TCvUMatUsageFlags.USAGE_DEFAULT): PCvUMat_t; cdecl;
Function   pCvUMatCreateV4(rows: Integer; cols: Integer; _type: Integer; s: PCvScalar_t; 
                 usageFlags: TCvUMatUsageFlags { default: USAGE_DEFAULT } = TCvUMatUsageFlags.USAGE_DEFAULT): PCvUMat_t; cdecl;
Function   pCvUMatCreateV5(size: PCvSize_t; _type: Integer; s: PCvScalar_t; 
                 usageFlags: TCvUMatUsageFlags { default: USAGE_DEFAULT } = TCvUMatUsageFlags.USAGE_DEFAULT): PCvUMat_t; cdecl;
Function   pCvUMatCreateV6(m: PCvUMat_t): PCvUMat_t; cdecl;
Function   pCvUMatCreateV7(m: PCvUMat_t; rowRange: PCvRange_t; 
                 colRange: PCvRange_t { default: Range::all() } = nil): PCvUMat_t; cdecl;
Function   pCvUMatCreateV8(m: PCvUMat_t; roi: PCvRect_t): PCvUMat_t; cdecl;
Function   pCvUMatCreateV9(m: PCvUMat_t; ranges: PCvvector_Range): PCvUMat_t; cdecl;
Procedure  pCvUMatDelete(const wrapper: PCvUMat_t); cdecl;
Function   pCvUsacParamsCreate(): PCvUsacParams_t; cdecl;
Procedure  pCvUsacParamsDelete(const wrapper: PCvUsacParams_t); cdecl;
Function   pCvVideoCaptureCreate(): PCvVideoCapture_t; cdecl;
Function   pCvVideoCaptureCreateV2(filename: PCvString_t; 
                 apiPreference: Integer { default: CAP_ANY } = ord(CAP_ANY)): PCvVideoCapture_t; cdecl;
Function   pCvVideoCaptureCreateV3(filename: PCvString_t; apiPreference: Integer; params: PCvvector_int): PCvVideoCapture_t; cdecl;
Function   pCvVideoCaptureCreateV4(index: Integer; 
                 apiPreference: Integer { default: CAP_ANY } = ord(CAP_ANY)): PCvVideoCapture_t; cdecl;
Function   pCvVideoCaptureCreateV5(index: Integer; apiPreference: Integer; params: PCvvector_int): PCvVideoCapture_t; cdecl;
Procedure  pCvVideoCaptureDelete(const wrapper: PCvVideoCapture_t); cdecl;
Function   pCvVideoWriterCreate(): PCvVideoWriter_t; cdecl;
Function   pCvVideoWriterCreateV2(filename: PCvString_t; fourcc: Integer; fps: Double; 
                 frameSize: PCvSize_t; isColor: Boolean { default: true } = true): PCvVideoWriter_t; cdecl;
Function   pCvVideoWriterCreateV3(filename: PCvString_t; apiPreference: Integer; fourcc: Integer; 
                 fps: Double; frameSize: PCvSize_t; isColor: Boolean { default: true } = true): PCvVideoWriter_t; cdecl;
Function   pCvVideoWriterCreateV4(filename: PCvString_t; fourcc: Integer; fps: Double; 
                 frameSize: PCvSize_t; params: PCvvector_int): PCvVideoWriter_t; cdecl;
Function   pCvVideoWriterCreateV5(filename: PCvString_t; apiPreference: Integer; fourcc: Integer; 
                 fps: Double; frameSize: PCvSize_t; params: PCvvector_int): PCvVideoWriter_t; cdecl;
Procedure  pCvVideoWriterDelete(const wrapper: PCvVideoWriter_t); cdecl;
Procedure  pCvAKAZEclear(const wrapper: PCvAKAZE_t); cdecl;
Procedure  pCvAKAZEcompute(const wrapper: PCvAKAZE_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t); cdecl;
Procedure  pCvAKAZEcomputeV2(const wrapper: PCvAKAZE_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t); cdecl;
Procedure  pCvAKAZEcomputeV3(const wrapper: PCvAKAZE_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvAKAZEcomputeV4(const wrapper: PCvAKAZE_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvAKAZE_create(
                 descriptor_type: TCvAKAZE_DescriptorType { default: AKAZE::DESCRIPTOR_MLDB } = TCvAKAZE_DescriptorType.DESCRIPTOR_MLDB; descriptor_size: Integer { default: 0 } = 0; 
                 descriptor_channels: Integer { default: 3 } = 3; threshold: Single { default: 0.001f } = 0.001; 
                 nOctaves: Integer { default: 4 } = 4; nOctaveLayers: Integer { default: 4 } = 4; 
                 diffusivity: TCvKAZE_DiffusivityType { default: KAZE::DIFF_PM_G2 } = TCvKAZE_DiffusivityType.DIFF_PM_G2): PCvPtr_AKAZE; cdecl;
Function   pCvAKAZEdefaultNorm(const wrapper: PCvAKAZE_t): Integer; cdecl;
Function   pCvAKAZEdescriptorSize(const wrapper: PCvAKAZE_t): Integer; cdecl;
Function   pCvAKAZEdescriptorType(const wrapper: PCvAKAZE_t): Integer; cdecl;
Procedure  pCvAKAZEdetect(const wrapper: PCvAKAZE_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvAKAZEdetectV2(const wrapper: PCvAKAZE_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvAKAZEdetectV3(const wrapper: PCvAKAZE_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvAKAZEdetectV4(const wrapper: PCvAKAZE_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvAKAZEdetectAndCompute(const wrapper: PCvAKAZE_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvAKAZEdetectAndComputeV2(const wrapper: PCvAKAZE_t; image: PCvUMat_t; mask: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvAKAZEempty(const wrapper: PCvAKAZE_t): Boolean; cdecl;
Function   pCvAKAZEgetDefaultName(const wrapper: PCvAKAZE_t): PCvString_t; cdecl;
Function   pCvAKAZEgetDescriptorChannels(const wrapper: PCvAKAZE_t): Integer; cdecl;
Function   pCvAKAZEgetDescriptorSize(const wrapper: PCvAKAZE_t): Integer; cdecl;
Function   pCvAKAZEgetDescriptorType(const wrapper: PCvAKAZE_t): TCvAKAZE_DescriptorType; cdecl;
Function   pCvAKAZEgetDiffusivity(const wrapper: PCvAKAZE_t): TCvKAZE_DiffusivityType; cdecl;
Function   pCvAKAZEgetNOctaveLayers(const wrapper: PCvAKAZE_t): Integer; cdecl;
Function   pCvAKAZEgetNOctaves(const wrapper: PCvAKAZE_t): Integer; cdecl;
Function   pCvAKAZEgetThreshold(const wrapper: PCvAKAZE_t): Double; cdecl;
Procedure  pCvAKAZEread(const wrapper: PCvAKAZE_t; fileName: PCvString_t); cdecl;
Procedure  pCvAKAZEreadV2(const wrapper: PCvAKAZE_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvAKAZEsave(const wrapper: PCvAKAZE_t; filename: PCvString_t); cdecl;
Procedure  pCvAKAZEsetDescriptorChannels(const wrapper: PCvAKAZE_t; dch: Integer); cdecl;
Procedure  pCvAKAZEsetDescriptorSize(const wrapper: PCvAKAZE_t; dsize: Integer); cdecl;
Procedure  pCvAKAZEsetDescriptorType(const wrapper: PCvAKAZE_t; dtype: TCvAKAZE_DescriptorType); cdecl;
Procedure  pCvAKAZEsetDiffusivity(const wrapper: PCvAKAZE_t; diff: TCvKAZE_DiffusivityType); cdecl;
Procedure  pCvAKAZEsetNOctaveLayers(const wrapper: PCvAKAZE_t; octaveLayers: Integer); cdecl;
Procedure  pCvAKAZEsetNOctaves(const wrapper: PCvAKAZE_t; octaves: Integer); cdecl;
Procedure  pCvAKAZEsetThreshold(const wrapper: PCvAKAZE_t; threshold: Double); cdecl;
Procedure  pCvAKAZEwrite(const wrapper: PCvAKAZE_t; fileName: PCvString_t); cdecl;
Procedure  pCvAKAZEwriteV2(const wrapper: PCvAKAZE_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvAffineFeatureclear(const wrapper: PCvAffineFeature_t); cdecl;
Procedure  pCvAffineFeaturecompute(const wrapper: PCvAffineFeature_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvAffineFeaturecomputeV2(const wrapper: PCvAffineFeature_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t); cdecl;
Procedure  pCvAffineFeaturecomputeV3(const wrapper: PCvAffineFeature_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvAffineFeaturecomputeV4(const wrapper: PCvAffineFeature_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvAffineFeature_create(backend: PCvPtr_Feature2D; maxTilt: Integer { default: 5 } = 5; 
                 minTilt: Integer { default: 0 } = 0; 
                 tiltStep: Single { default: 1.4142135623730951f } = 1.4142135623730951; rotateStepBase: Single { default: 72 } = 72): PCvPtr_AffineFeature; cdecl;
Function   pCvAffineFeaturedefaultNorm(const wrapper: PCvAffineFeature_t): Integer; cdecl;
Function   pCvAffineFeaturedescriptorSize(const wrapper: PCvAffineFeature_t): Integer; cdecl;
Function   pCvAffineFeaturedescriptorType(const wrapper: PCvAffineFeature_t): Integer; cdecl;
Procedure  pCvAffineFeaturedetect(const wrapper: PCvAffineFeature_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvAffineFeaturedetectV2(const wrapper: PCvAffineFeature_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvAffineFeaturedetectV3(const wrapper: PCvAffineFeature_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvAffineFeaturedetectV4(const wrapper: PCvAffineFeature_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvAffineFeaturedetectAndCompute(const wrapper: PCvAffineFeature_t; image: PCvMat_t; 
                 mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvAffineFeaturedetectAndComputeV2(const wrapper: PCvAffineFeature_t; image: PCvUMat_t; 
                 mask: PCvUMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvAffineFeatureempty(const wrapper: PCvAffineFeature_t): Boolean; cdecl;
Function   pCvAffineFeaturegetDefaultName(const wrapper: PCvAffineFeature_t): PCvString_t; cdecl;
Procedure  pCvAffineFeaturegetViewParams(const wrapper: PCvAffineFeature_t; tilts: PCvvector_float; 
                 rolls: PCvvector_float); cdecl;
Procedure  pCvAffineFeatureread(const wrapper: PCvAffineFeature_t; fileName: PCvString_t); cdecl;
Procedure  pCvAffineFeaturereadV2(const wrapper: PCvAffineFeature_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvAffineFeaturesave(const wrapper: PCvAffineFeature_t; filename: PCvString_t); cdecl;
Procedure  pCvAffineFeaturesetViewParams(const wrapper: PCvAffineFeature_t; tilts: PCvvector_float; 
                 rolls: PCvvector_float); cdecl;
Procedure  pCvAffineFeaturewrite(const wrapper: PCvAffineFeature_t; fileName: PCvString_t); cdecl;
Procedure  pCvAffineFeaturewriteV2(const wrapper: PCvAffineFeature_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvAgastFeatureDetectorclear(const wrapper: PCvAgastFeatureDetector_t); cdecl;
Procedure  pCvAgastFeatureDetectorcompute(const wrapper: PCvAgastFeatureDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvAgastFeatureDetectorcomputeV2(const wrapper: PCvAgastFeatureDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t); cdecl;
Procedure  pCvAgastFeatureDetectorcomputeV3(const wrapper: PCvAgastFeatureDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvAgastFeatureDetectorcomputeV4(const wrapper: PCvAgastFeatureDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvAgastFeatureDetector_create(threshold: Integer { default: 10 } = 10; 
                 nonmaxSuppression: Boolean { default: true } = true; 
                 _type: TCvAgastFeatureDetector_DetectorType { default: AgastFeatureDetector::OAST_9_16 } = TCvAgastFeatureDetector_DetectorType.OAST_9_16): PCvPtr_AgastFeatureDetector; cdecl;
Function   pCvAgastFeatureDetectordefaultNorm(const wrapper: PCvAgastFeatureDetector_t): Integer; cdecl;
Function   pCvAgastFeatureDetectordescriptorSize(const wrapper: PCvAgastFeatureDetector_t): Integer; cdecl;
Function   pCvAgastFeatureDetectordescriptorType(const wrapper: PCvAgastFeatureDetector_t): Integer; cdecl;
Procedure  pCvAgastFeatureDetectordetect(const wrapper: PCvAgastFeatureDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvAgastFeatureDetectordetectV2(const wrapper: PCvAgastFeatureDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvAgastFeatureDetectordetectV3(const wrapper: PCvAgastFeatureDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvAgastFeatureDetectordetectV4(const wrapper: PCvAgastFeatureDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvAgastFeatureDetectordetectAndCompute(const wrapper: PCvAgastFeatureDetector_t; image: PCvMat_t; 
                 mask: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvAgastFeatureDetectordetectAndComputeV2(const wrapper: PCvAgastFeatureDetector_t; image: PCvUMat_t; 
                 mask: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvAgastFeatureDetectorempty(const wrapper: PCvAgastFeatureDetector_t): Boolean; cdecl;
Function   pCvAgastFeatureDetectorgetDefaultName(const wrapper: PCvAgastFeatureDetector_t): PCvString_t; cdecl;
Function   pCvAgastFeatureDetectorgetNonmaxSuppression(const wrapper: PCvAgastFeatureDetector_t): Boolean; cdecl;
Function   pCvAgastFeatureDetectorgetThreshold(const wrapper: PCvAgastFeatureDetector_t): Integer; cdecl;
Function   pCvAgastFeatureDetectorgetType(const wrapper: PCvAgastFeatureDetector_t): TCvAgastFeatureDetector_DetectorType; cdecl;
Procedure  pCvAgastFeatureDetectorread(const wrapper: PCvAgastFeatureDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvAgastFeatureDetectorreadV2(const wrapper: PCvAgastFeatureDetector_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvAgastFeatureDetectorsave(const wrapper: PCvAgastFeatureDetector_t; filename: PCvString_t); cdecl;
Procedure  pCvAgastFeatureDetectorsetNonmaxSuppression(const wrapper: PCvAgastFeatureDetector_t; f: Boolean); cdecl;
Procedure  pCvAgastFeatureDetectorsetThreshold(const wrapper: PCvAgastFeatureDetector_t; threshold: Integer); cdecl;
Procedure  pCvAgastFeatureDetectorsetType(const wrapper: PCvAgastFeatureDetector_t; _type: TCvAgastFeatureDetector_DetectorType); cdecl;
Procedure  pCvAgastFeatureDetectorwrite(const wrapper: PCvAgastFeatureDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvAgastFeatureDetectorwriteV2(const wrapper: PCvAgastFeatureDetector_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvAlgorithmclear(const wrapper: PCvAlgorithm_t); cdecl;
Function   pCvAlgorithmempty(const wrapper: PCvAlgorithm_t): Boolean; cdecl;
Function   pCvAlgorithmgetDefaultName(const wrapper: PCvAlgorithm_t): PCvString_t; cdecl;
Procedure  pCvAlgorithmread(const wrapper: PCvAlgorithm_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvAlgorithmsave(const wrapper: PCvAlgorithm_t; filename: PCvString_t); cdecl;
Procedure  pCvAlgorithmwrite(const wrapper: PCvAlgorithm_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvAlignExposuresclear(const wrapper: PCvAlignExposures_t); cdecl;
Function   pCvAlignExposuresempty(const wrapper: PCvAlignExposures_t): Boolean; cdecl;
Function   pCvAlignExposuresgetDefaultName(const wrapper: PCvAlignExposures_t): PCvString_t; cdecl;
Procedure  pCvAlignExposuresprocess(const wrapper: PCvAlignExposures_t; src: PCvvector_Mat; 
                 dst: PCvvector_Mat; times: PCvMat_t; response: PCvMat_t); cdecl;
Procedure  pCvAlignExposuresprocessV2(const wrapper: PCvAlignExposures_t; src: PCvvector_UMat; 
                 dst: PCvvector_Mat; times: PCvUMat_t; response: PCvUMat_t); cdecl;
Procedure  pCvAlignExposuresread(const wrapper: PCvAlignExposures_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvAlignExposuressave(const wrapper: PCvAlignExposures_t; filename: PCvString_t); cdecl;
Procedure  pCvAlignExposureswrite(const wrapper: PCvAlignExposures_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvAlignMTBcalculateShift(const wrapper: PCvAlignMTB_t; img0: PCvMat_t; img1: PCvMat_t): PCvPoint_t; cdecl;
Function   pCvAlignMTBcalculateShiftV2(const wrapper: PCvAlignMTB_t; img0: PCvUMat_t; img1: PCvUMat_t): PCvPoint_t; cdecl;
Procedure  pCvAlignMTBclear(const wrapper: PCvAlignMTB_t); cdecl;
Procedure  pCvAlignMTBcomputeBitmaps(const wrapper: PCvAlignMTB_t; img: PCvMat_t; tb: PCvMat_t; 
                 eb: PCvMat_t); cdecl;
Procedure  pCvAlignMTBcomputeBitmapsV2(const wrapper: PCvAlignMTB_t; img: PCvUMat_t; tb: PCvUMat_t; 
                 eb: PCvUMat_t); cdecl;
Function   pCvAlignMTBempty(const wrapper: PCvAlignMTB_t): Boolean; cdecl;
Function   pCvAlignMTBgetCut(const wrapper: PCvAlignMTB_t): Boolean; cdecl;
Function   pCvAlignMTBgetDefaultName(const wrapper: PCvAlignMTB_t): PCvString_t; cdecl;
Function   pCvAlignMTBgetExcludeRange(const wrapper: PCvAlignMTB_t): Integer; cdecl;
Function   pCvAlignMTBgetMaxBits(const wrapper: PCvAlignMTB_t): Integer; cdecl;
Procedure  pCvAlignMTBprocess(const wrapper: PCvAlignMTB_t; src: PCvvector_Mat; dst: PCvvector_Mat; 
                 times: PCvMat_t; response: PCvMat_t); cdecl;
Procedure  pCvAlignMTBprocessV2(const wrapper: PCvAlignMTB_t; src: PCvvector_UMat; dst: PCvvector_Mat; 
                 times: PCvUMat_t; response: PCvUMat_t); cdecl;
Procedure  pCvAlignMTBprocessV3(const wrapper: PCvAlignMTB_t; src: PCvvector_Mat; dst: PCvvector_Mat); cdecl;
Procedure  pCvAlignMTBprocessV4(const wrapper: PCvAlignMTB_t; src: PCvvector_UMat; dst: PCvvector_Mat); cdecl;
Procedure  pCvAlignMTBread(const wrapper: PCvAlignMTB_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvAlignMTBsave(const wrapper: PCvAlignMTB_t; filename: PCvString_t); cdecl;
Procedure  pCvAlignMTBsetCut(const wrapper: PCvAlignMTB_t; value: Boolean); cdecl;
Procedure  pCvAlignMTBsetExcludeRange(const wrapper: PCvAlignMTB_t; exclude_range: Integer); cdecl;
Procedure  pCvAlignMTBsetMaxBits(const wrapper: PCvAlignMTB_t; max_bits: Integer); cdecl;
Procedure  pCvAlignMTBshiftMat(const wrapper: PCvAlignMTB_t; src: PCvMat_t; dst: PCvMat_t; 
                 shift: PCvPoint_t); cdecl;
Procedure  pCvAlignMTBshiftMatV2(const wrapper: PCvAlignMTB_t; src: PCvUMat_t; dst: PCvUMat_t; 
                 shift: PCvPoint_t); cdecl;
Procedure  pCvAlignMTBwrite(const wrapper: PCvAlignMTB_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvAsyncArrayget(const wrapper: PCvAsyncArray_t; dst: PCvMat_t); cdecl;
Procedure  pCvAsyncArraygetV2(const wrapper: PCvAsyncArray_t; dst: PCvUMat_t); cdecl;
Function   pCvAsyncArraygetV3(const wrapper: PCvAsyncArray_t; dst: PCvMat_t; timeoutNs: Double): Boolean; cdecl;
Function   pCvAsyncArraygetV4(const wrapper: PCvAsyncArray_t; dst: PCvUMat_t; timeoutNs: Double): Boolean; cdecl;
Procedure  pCvAsyncArrayrelease(const wrapper: PCvAsyncArray_t); cdecl;
Function   pCvAsyncArrayvalid(const wrapper: PCvAsyncArray_t): Boolean; cdecl;
Function   pCvAsyncArraywait_for(const wrapper: PCvAsyncArray_t; timeoutNs: Double): Boolean; cdecl;
Procedure  pCvBFMatcheradd(const wrapper: PCvBFMatcher_t; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvBFMatcheraddV2(const wrapper: PCvBFMatcher_t; descriptors: PCvvector_UMat); cdecl;
Procedure  pCvBFMatcherclear(const wrapper: PCvBFMatcher_t); cdecl;
Function   pCvBFMatcherclone(const wrapper: PCvBFMatcher_t; emptyTrainData: Boolean { default: false } = false): PCvPtr_DescriptorMatcher; cdecl;
Function   pCvBFMatcher_create(normType: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 crossCheck: Boolean { default: false } = false): PCvPtr_BFMatcher; cdecl;
Function   pCvBFMatcherempty(const wrapper: PCvBFMatcher_t): Boolean; cdecl;
Function   pCvBFMatchergetDefaultName(const wrapper: PCvBFMatcher_t): PCvString_t; cdecl;
Function   pCvBFMatchergetTrainDescriptors(const wrapper: PCvBFMatcher_t): PCvvector_Mat; cdecl;
Function   pCvBFMatcherisMaskSupported(const wrapper: PCvBFMatcher_t): Boolean; cdecl;
Procedure  pCvBFMatcherknnMatch(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; 
                 mask: PCvMat_t { default: Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherknnMatchV2(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_vector_DMatch; k: Integer; 
                 mask: PCvUMat_t { default: UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherknnMatchV3(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_vector_DMatch; k: Integer; masks: PCvvector_Mat { default: vector_Mat() } = nil; 
                 compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherknnMatchV4(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_vector_DMatch; k: Integer; masks: PCvvector_UMat { default: vector_UMat() } = nil; 
                 compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatchermatch(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_DMatch; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvBFMatchermatchV2(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_DMatch; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvBFMatchermatchV3(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_DMatch; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvBFMatchermatchV4(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_DMatch; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvBFMatcherradiusMatch(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 mask: PCvMat_t { default: Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherradiusMatchV2(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 mask: PCvUMat_t { default: UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherradiusMatchV3(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 masks: PCvvector_Mat { default: vector_Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherradiusMatchV4(const wrapper: PCvBFMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 masks: PCvvector_UMat { default: vector_UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvBFMatcherread(const wrapper: PCvBFMatcher_t; fileName: PCvString_t); cdecl;
Procedure  pCvBFMatcherreadV2(const wrapper: PCvBFMatcher_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvBFMatchersave(const wrapper: PCvBFMatcher_t; filename: PCvString_t); cdecl;
Procedure  pCvBFMatchertrain(const wrapper: PCvBFMatcher_t); cdecl;
Procedure  pCvBFMatcherwrite(const wrapper: PCvBFMatcher_t; fileName: PCvString_t); cdecl;
Procedure  pCvBFMatcherwriteV2(const wrapper: PCvBFMatcher_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvBOWImgDescriptorExtractorcompute(const wrapper: PCvBOWImgDescriptorExtractor_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; imgDescriptor: PCvMat_t); cdecl;
Function   pCvBOWImgDescriptorExtractordescriptorSize(const wrapper: PCvBOWImgDescriptorExtractor_t): Integer; cdecl;
Function   pCvBOWImgDescriptorExtractordescriptorType(const wrapper: PCvBOWImgDescriptorExtractor_t): Integer; cdecl;
Function   pCvBOWImgDescriptorExtractorgetVocabulary(const wrapper: PCvBOWImgDescriptorExtractor_t): PCvMat_t; cdecl;
Procedure  pCvBOWImgDescriptorExtractorsetVocabulary(const wrapper: PCvBOWImgDescriptorExtractor_t; vocabulary: PCvMat_t); cdecl;
Procedure  pCvBOWKMeansTraineradd(const wrapper: PCvBOWKMeansTrainer_t; descriptors: PCvMat_t); cdecl;
Procedure  pCvBOWKMeansTrainerclear(const wrapper: PCvBOWKMeansTrainer_t); cdecl;
Function   pCvBOWKMeansTrainercluster(const wrapper: PCvBOWKMeansTrainer_t): PCvMat_t; cdecl;
Function   pCvBOWKMeansTrainerclusterV2(const wrapper: PCvBOWKMeansTrainer_t; descriptors: PCvMat_t): PCvMat_t; cdecl;
Function   pCvBOWKMeansTrainerdescriptorsCount(const wrapper: PCvBOWKMeansTrainer_t): Integer; cdecl;
Function   pCvBOWKMeansTrainergetDescriptors(const wrapper: PCvBOWKMeansTrainer_t): PCvvector_Mat; cdecl;
Procedure  pCvBOWTraineradd(const wrapper: PCvBOWTrainer_t; descriptors: PCvMat_t); cdecl;
Procedure  pCvBOWTrainerclear(const wrapper: PCvBOWTrainer_t); cdecl;
Function   pCvBOWTrainercluster(const wrapper: PCvBOWTrainer_t): PCvMat_t; cdecl;
Function   pCvBOWTrainerclusterV2(const wrapper: PCvBOWTrainer_t; descriptors: PCvMat_t): PCvMat_t; cdecl;
Function   pCvBOWTrainerdescriptorsCount(const wrapper: PCvBOWTrainer_t): Integer; cdecl;
Function   pCvBOWTrainergetDescriptors(const wrapper: PCvBOWTrainer_t): PCvvector_Mat; cdecl;
Procedure  pCvBRISKclear(const wrapper: PCvBRISK_t); cdecl;
Procedure  pCvBRISKcompute(const wrapper: PCvBRISK_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t); cdecl;
Procedure  pCvBRISKcomputeV2(const wrapper: PCvBRISK_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t); cdecl;
Procedure  pCvBRISKcomputeV3(const wrapper: PCvBRISK_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvBRISKcomputeV4(const wrapper: PCvBRISK_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvBRISK_create(thresh: Integer { default: 30 } = 30; octaves: Integer { default: 3 } = 3; 
                 patternScale: Single { default: 1.0f } = 1.0): PCvPtr_BRISK; cdecl;
Function   pCvBRISK_createV2(radiusList: PCvvector_float; numberList: PCvvector_int; 
                 dMax: Single { default: 5.85f } = 5.85; dMin: Single { default: 8.2f } = 8.2; 
                 indexChange: PCvvector_int { default: std::vector<int>() } = nil): PCvPtr_BRISK; cdecl;
Function   pCvBRISK_createV3(thresh: Integer; octaves: Integer; radiusList: PCvvector_float; 
                 numberList: PCvvector_int; dMax: Single { default: 5.85f } = 5.85; 
                 dMin: Single { default: 8.2f } = 8.2; indexChange: PCvvector_int { default: std::vector<int>() } = nil): PCvPtr_BRISK; cdecl;
Function   pCvBRISKdefaultNorm(const wrapper: PCvBRISK_t): Integer; cdecl;
Function   pCvBRISKdescriptorSize(const wrapper: PCvBRISK_t): Integer; cdecl;
Function   pCvBRISKdescriptorType(const wrapper: PCvBRISK_t): Integer; cdecl;
Procedure  pCvBRISKdetect(const wrapper: PCvBRISK_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvBRISKdetectV2(const wrapper: PCvBRISK_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvBRISKdetectV3(const wrapper: PCvBRISK_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvBRISKdetectV4(const wrapper: PCvBRISK_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvBRISKdetectAndCompute(const wrapper: PCvBRISK_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvBRISKdetectAndComputeV2(const wrapper: PCvBRISK_t; image: PCvUMat_t; mask: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvBRISKempty(const wrapper: PCvBRISK_t): Boolean; cdecl;
Function   pCvBRISKgetDefaultName(const wrapper: PCvBRISK_t): PCvString_t; cdecl;
Function   pCvBRISKgetOctaves(const wrapper: PCvBRISK_t): Integer; cdecl;
Function   pCvBRISKgetThreshold(const wrapper: PCvBRISK_t): Integer; cdecl;
Procedure  pCvBRISKread(const wrapper: PCvBRISK_t; fileName: PCvString_t); cdecl;
Procedure  pCvBRISKreadV2(const wrapper: PCvBRISK_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvBRISKsave(const wrapper: PCvBRISK_t; filename: PCvString_t); cdecl;
Procedure  pCvBRISKsetOctaves(const wrapper: PCvBRISK_t; octaves: Integer); cdecl;
Procedure  pCvBRISKsetThreshold(const wrapper: PCvBRISK_t; threshold: Integer); cdecl;
Procedure  pCvBRISKwrite(const wrapper: PCvBRISK_t; fileName: PCvString_t); cdecl;
Procedure  pCvBRISKwriteV2(const wrapper: PCvBRISK_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvBackgroundSubtractorapply(const wrapper: PCvBackgroundSubtractor_t; image: PCvMat_t; 
                 fgmask: PCvMat_t; learningRate: Double { default: -1 } = ord(-1)); cdecl;
Procedure  pCvBackgroundSubtractorapplyV2(const wrapper: PCvBackgroundSubtractor_t; image: PCvUMat_t; 
                 fgmask: PCvUMat_t; learningRate: Double { default: -1 } = ord(-1)); cdecl;
Procedure  pCvBackgroundSubtractorclear(const wrapper: PCvBackgroundSubtractor_t); cdecl;
Function   pCvBackgroundSubtractorempty(const wrapper: PCvBackgroundSubtractor_t): Boolean; cdecl;
Procedure  pCvBackgroundSubtractorgetBackgroundImage(const wrapper: PCvBackgroundSubtractor_t; backgroundImage: PCvMat_t); cdecl;
Procedure  pCvBackgroundSubtractorgetBackgroundImageV2(const wrapper: PCvBackgroundSubtractor_t; backgroundImage: PCvUMat_t); cdecl;
Function   pCvBackgroundSubtractorgetDefaultName(const wrapper: PCvBackgroundSubtractor_t): PCvString_t; cdecl;
Procedure  pCvBackgroundSubtractorread(const wrapper: PCvBackgroundSubtractor_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvBackgroundSubtractorsave(const wrapper: PCvBackgroundSubtractor_t; filename: PCvString_t); cdecl;
Procedure  pCvBackgroundSubtractorwrite(const wrapper: PCvBackgroundSubtractor_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvBackgroundSubtractorKNNapply(const wrapper: PCvBackgroundSubtractorKNN_t; image: PCvMat_t; 
                 fgmask: PCvMat_t; learningRate: Double { default: -1 } = ord(-1)); cdecl;
Procedure  pCvBackgroundSubtractorKNNapplyV2(const wrapper: PCvBackgroundSubtractorKNN_t; image: PCvUMat_t; 
                 fgmask: PCvUMat_t; learningRate: Double { default: -1 } = ord(-1)); cdecl;
Procedure  pCvBackgroundSubtractorKNNclear(const wrapper: PCvBackgroundSubtractorKNN_t); cdecl;
Function   pCvBackgroundSubtractorKNNempty(const wrapper: PCvBackgroundSubtractorKNN_t): Boolean; cdecl;
Procedure  pCvBackgroundSubtractorKNNgetBackgroundImage(const wrapper: PCvBackgroundSubtractorKNN_t; backgroundImage: PCvMat_t); cdecl;
Procedure  pCvBackgroundSubtractorKNNgetBackgroundImageV2(const wrapper: PCvBackgroundSubtractorKNN_t; backgroundImage: PCvUMat_t); cdecl;
Function   pCvBackgroundSubtractorKNNgetDefaultName(const wrapper: PCvBackgroundSubtractorKNN_t): PCvString_t; cdecl;
Function   pCvBackgroundSubtractorKNNgetDetectShadows(const wrapper: PCvBackgroundSubtractorKNN_t): Boolean; cdecl;
Function   pCvBackgroundSubtractorKNNgetDist2Threshold(const wrapper: PCvBackgroundSubtractorKNN_t): Double; cdecl;
Function   pCvBackgroundSubtractorKNNgetHistory(const wrapper: PCvBackgroundSubtractorKNN_t): Integer; cdecl;
Function   pCvBackgroundSubtractorKNNgetNSamples(const wrapper: PCvBackgroundSubtractorKNN_t): Integer; cdecl;
Function   pCvBackgroundSubtractorKNNgetShadowThreshold(const wrapper: PCvBackgroundSubtractorKNN_t): Double; cdecl;
Function   pCvBackgroundSubtractorKNNgetShadowValue(const wrapper: PCvBackgroundSubtractorKNN_t): Integer; cdecl;
Function   pCvBackgroundSubtractorKNNgetkNNSamples(const wrapper: PCvBackgroundSubtractorKNN_t): Integer; cdecl;
Procedure  pCvBackgroundSubtractorKNNread(const wrapper: PCvBackgroundSubtractorKNN_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvBackgroundSubtractorKNNsave(const wrapper: PCvBackgroundSubtractorKNN_t; filename: PCvString_t); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetDetectShadows(const wrapper: PCvBackgroundSubtractorKNN_t; detectShadows: Boolean); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetDist2Threshold(const wrapper: PCvBackgroundSubtractorKNN_t; _dist2Threshold: Double); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetHistory(const wrapper: PCvBackgroundSubtractorKNN_t; history: Integer); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetNSamples(const wrapper: PCvBackgroundSubtractorKNN_t; _nN: Integer); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetShadowThreshold(const wrapper: PCvBackgroundSubtractorKNN_t; threshold: Double); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetShadowValue(const wrapper: PCvBackgroundSubtractorKNN_t; value: Integer); cdecl;
Procedure  pCvBackgroundSubtractorKNNsetkNNSamples(const wrapper: PCvBackgroundSubtractorKNN_t; _nkNN: Integer); cdecl;
Procedure  pCvBackgroundSubtractorKNNwrite(const wrapper: PCvBackgroundSubtractorKNN_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvBackgroundSubtractorMOG2apply(const wrapper: PCvBackgroundSubtractorMOG2_t; image: PCvMat_t; 
                 fgmask: PCvMat_t; learningRate: Double { default: -1 } = ord(-1)); cdecl;
Procedure  pCvBackgroundSubtractorMOG2applyV2(const wrapper: PCvBackgroundSubtractorMOG2_t; image: PCvUMat_t; 
                 fgmask: PCvUMat_t; learningRate: Double { default: -1 } = ord(-1)); cdecl;
Procedure  pCvBackgroundSubtractorMOG2clear(const wrapper: PCvBackgroundSubtractorMOG2_t); cdecl;
Function   pCvBackgroundSubtractorMOG2empty(const wrapper: PCvBackgroundSubtractorMOG2_t): Boolean; cdecl;
Procedure  pCvBackgroundSubtractorMOG2getBackgroundImage(const wrapper: PCvBackgroundSubtractorMOG2_t; backgroundImage: PCvMat_t); cdecl;
Procedure  pCvBackgroundSubtractorMOG2getBackgroundImageV2(const wrapper: PCvBackgroundSubtractorMOG2_t; backgroundImage: PCvUMat_t); cdecl;
Function   pCvBackgroundSubtractorMOG2getBackgroundRatio(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getComplexityReductionThreshold(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getDefaultName(const wrapper: PCvBackgroundSubtractorMOG2_t): PCvString_t; cdecl;
Function   pCvBackgroundSubtractorMOG2getDetectShadows(const wrapper: PCvBackgroundSubtractorMOG2_t): Boolean; cdecl;
Function   pCvBackgroundSubtractorMOG2getHistory(const wrapper: PCvBackgroundSubtractorMOG2_t): Integer; cdecl;
Function   pCvBackgroundSubtractorMOG2getNMixtures(const wrapper: PCvBackgroundSubtractorMOG2_t): Integer; cdecl;
Function   pCvBackgroundSubtractorMOG2getShadowThreshold(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getShadowValue(const wrapper: PCvBackgroundSubtractorMOG2_t): Integer; cdecl;
Function   pCvBackgroundSubtractorMOG2getVarInit(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getVarMax(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getVarMin(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getVarThreshold(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Function   pCvBackgroundSubtractorMOG2getVarThresholdGen(const wrapper: PCvBackgroundSubtractorMOG2_t): Double; cdecl;
Procedure  pCvBackgroundSubtractorMOG2read(const wrapper: PCvBackgroundSubtractorMOG2_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvBackgroundSubtractorMOG2save(const wrapper: PCvBackgroundSubtractorMOG2_t; filename: PCvString_t); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setBackgroundRatio(const wrapper: PCvBackgroundSubtractorMOG2_t; ratio: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setComplexityReductionThreshold(const wrapper: PCvBackgroundSubtractorMOG2_t; ct: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setDetectShadows(const wrapper: PCvBackgroundSubtractorMOG2_t; detectShadows: Boolean); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setHistory(const wrapper: PCvBackgroundSubtractorMOG2_t; history: Integer); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setNMixtures(const wrapper: PCvBackgroundSubtractorMOG2_t; nmixtures: Integer); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setShadowThreshold(const wrapper: PCvBackgroundSubtractorMOG2_t; threshold: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setShadowValue(const wrapper: PCvBackgroundSubtractorMOG2_t; value: Integer); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setVarInit(const wrapper: PCvBackgroundSubtractorMOG2_t; varInit: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setVarMax(const wrapper: PCvBackgroundSubtractorMOG2_t; varMax: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setVarMin(const wrapper: PCvBackgroundSubtractorMOG2_t; varMin: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setVarThreshold(const wrapper: PCvBackgroundSubtractorMOG2_t; varThreshold: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2setVarThresholdGen(const wrapper: PCvBackgroundSubtractorMOG2_t; varThresholdGen: Double); cdecl;
Procedure  pCvBackgroundSubtractorMOG2write(const wrapper: PCvBackgroundSubtractorMOG2_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvBaseCascadeClassifierclear(const wrapper: PCvBaseCascadeClassifier_t); cdecl;
Function   pCvBaseCascadeClassifierempty(const wrapper: PCvBaseCascadeClassifier_t): Boolean; cdecl;
Function   pCvBaseCascadeClassifiergetDefaultName(const wrapper: PCvBaseCascadeClassifier_t): PCvString_t; cdecl;
Procedure  pCvBaseCascadeClassifierread(const wrapper: PCvBaseCascadeClassifier_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvBaseCascadeClassifiersave(const wrapper: PCvBaseCascadeClassifier_t; filename: PCvString_t); cdecl;
Procedure  pCvBaseCascadeClassifierwrite(const wrapper: PCvBaseCascadeClassifier_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvCLAHEapply(const wrapper: PCvCLAHE_t; src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvCLAHEapplyV2(const wrapper: PCvCLAHE_t; src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvCLAHEclear(const wrapper: PCvCLAHE_t); cdecl;
Procedure  pCvCLAHEcollectGarbage(const wrapper: PCvCLAHE_t); cdecl;
Function   pCvCLAHEempty(const wrapper: PCvCLAHE_t): Boolean; cdecl;
Function   pCvCLAHEgetClipLimit(const wrapper: PCvCLAHE_t): Double; cdecl;
Function   pCvCLAHEgetDefaultName(const wrapper: PCvCLAHE_t): PCvString_t; cdecl;
Function   pCvCLAHEgetTilesGridSize(const wrapper: PCvCLAHE_t): PCvSize_t; cdecl;
Procedure  pCvCLAHEread(const wrapper: PCvCLAHE_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvCLAHEsave(const wrapper: PCvCLAHE_t; filename: PCvString_t); cdecl;
Procedure  pCvCLAHEsetClipLimit(const wrapper: PCvCLAHE_t; clipLimit: Double); cdecl;
Procedure  pCvCLAHEsetTilesGridSize(const wrapper: PCvCLAHE_t; tileGridSize: PCvSize_t); cdecl;
Procedure  pCvCLAHEwrite(const wrapper: PCvCLAHE_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvCalibrateCRFclear(const wrapper: PCvCalibrateCRF_t); cdecl;
Function   pCvCalibrateCRFempty(const wrapper: PCvCalibrateCRF_t): Boolean; cdecl;
Function   pCvCalibrateCRFgetDefaultName(const wrapper: PCvCalibrateCRF_t): PCvString_t; cdecl;
Procedure  pCvCalibrateCRFprocess(const wrapper: PCvCalibrateCRF_t; src: PCvvector_Mat; dst: PCvMat_t; 
                 times: PCvMat_t); cdecl;
Procedure  pCvCalibrateCRFprocessV2(const wrapper: PCvCalibrateCRF_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t); cdecl;
Procedure  pCvCalibrateCRFread(const wrapper: PCvCalibrateCRF_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvCalibrateCRFsave(const wrapper: PCvCalibrateCRF_t; filename: PCvString_t); cdecl;
Procedure  pCvCalibrateCRFwrite(const wrapper: PCvCalibrateCRF_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvCalibrateDebevecclear(const wrapper: PCvCalibrateDebevec_t); cdecl;
Function   pCvCalibrateDebevecempty(const wrapper: PCvCalibrateDebevec_t): Boolean; cdecl;
Function   pCvCalibrateDebevecgetDefaultName(const wrapper: PCvCalibrateDebevec_t): PCvString_t; cdecl;
Function   pCvCalibrateDebevecgetLambda(const wrapper: PCvCalibrateDebevec_t): Single; cdecl;
Function   pCvCalibrateDebevecgetRandom(const wrapper: PCvCalibrateDebevec_t): Boolean; cdecl;
Function   pCvCalibrateDebevecgetSamples(const wrapper: PCvCalibrateDebevec_t): Integer; cdecl;
Procedure  pCvCalibrateDebevecprocess(const wrapper: PCvCalibrateDebevec_t; src: PCvvector_Mat; 
                 dst: PCvMat_t; times: PCvMat_t); cdecl;
Procedure  pCvCalibrateDebevecprocessV2(const wrapper: PCvCalibrateDebevec_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t); cdecl;
Procedure  pCvCalibrateDebevecread(const wrapper: PCvCalibrateDebevec_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvCalibrateDebevecsave(const wrapper: PCvCalibrateDebevec_t; filename: PCvString_t); cdecl;
Procedure  pCvCalibrateDebevecsetLambda(const wrapper: PCvCalibrateDebevec_t; lambda: Single); cdecl;
Procedure  pCvCalibrateDebevecsetRandom(const wrapper: PCvCalibrateDebevec_t; _random: Boolean); cdecl;
Procedure  pCvCalibrateDebevecsetSamples(const wrapper: PCvCalibrateDebevec_t; samples: Integer); cdecl;
Procedure  pCvCalibrateDebevecwrite(const wrapper: PCvCalibrateDebevec_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvCalibrateRobertsonclear(const wrapper: PCvCalibrateRobertson_t); cdecl;
Function   pCvCalibrateRobertsonempty(const wrapper: PCvCalibrateRobertson_t): Boolean; cdecl;
Function   pCvCalibrateRobertsongetDefaultName(const wrapper: PCvCalibrateRobertson_t): PCvString_t; cdecl;
Function   pCvCalibrateRobertsongetMaxIter(const wrapper: PCvCalibrateRobertson_t): Integer; cdecl;
Function   pCvCalibrateRobertsongetRadiance(const wrapper: PCvCalibrateRobertson_t): PCvMat_t; cdecl;
Function   pCvCalibrateRobertsongetThreshold(const wrapper: PCvCalibrateRobertson_t): Single; cdecl;
Procedure  pCvCalibrateRobertsonprocess(const wrapper: PCvCalibrateRobertson_t; src: PCvvector_Mat; 
                 dst: PCvMat_t; times: PCvMat_t); cdecl;
Procedure  pCvCalibrateRobertsonprocessV2(const wrapper: PCvCalibrateRobertson_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t); cdecl;
Procedure  pCvCalibrateRobertsonread(const wrapper: PCvCalibrateRobertson_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvCalibrateRobertsonsave(const wrapper: PCvCalibrateRobertson_t; filename: PCvString_t); cdecl;
Procedure  pCvCalibrateRobertsonsetMaxIter(const wrapper: PCvCalibrateRobertson_t; max_iter: Integer); cdecl;
Procedure  pCvCalibrateRobertsonsetThreshold(const wrapper: PCvCalibrateRobertson_t; threshold: Single); cdecl;
Procedure  pCvCalibrateRobertsonwrite(const wrapper: PCvCalibrateRobertson_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvCascadeClassifierconvert(oldcascade: PCvString_t; newcascade: PCvString_t): Boolean; cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale(const wrapper: PCvCascadeClassifier_t; image: PCvMat_t; 
                 objects: PCvvector_Rect; scaleFactor: Double { default: 1.1 } = 1.1; 
                 minNeighbors: Integer { default: 3 } = 3; flags: Integer { default: 0 } = 0; 
                 minSize: PCvSize_t { default: Size() } = nil; maxSize: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScaleV2(const wrapper: PCvCascadeClassifier_t; image: PCvUMat_t; 
                 objects: PCvvector_Rect; scaleFactor: Double { default: 1.1 } = 1.1; 
                 minNeighbors: Integer { default: 3 } = 3; flags: Integer { default: 0 } = 0; 
                 minSize: PCvSize_t { default: Size() } = nil; maxSize: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale2(const wrapper: PCvCascadeClassifier_t; image: PCvMat_t; 
                 objects: PCvvector_Rect; numDetections: PCvvector_int; 
                 scaleFactor: Double { default: 1.1 } = 1.1; minNeighbors: Integer { default: 3 } = 3; 
                 flags: Integer { default: 0 } = 0; minSize: PCvSize_t { default: Size() } = nil; 
                 maxSize: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale2V2(const wrapper: PCvCascadeClassifier_t; image: PCvUMat_t; 
                 objects: PCvvector_Rect; numDetections: PCvvector_int; 
                 scaleFactor: Double { default: 1.1 } = 1.1; minNeighbors: Integer { default: 3 } = 3; 
                 flags: Integer { default: 0 } = 0; minSize: PCvSize_t { default: Size() } = nil; 
                 maxSize: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale3(const wrapper: PCvCascadeClassifier_t; image: PCvMat_t; 
                 objects: PCvvector_Rect; rejectLevels: PCvvector_int; 
                 levelWeights: PCvvector_double; scaleFactor: Double { default: 1.1 } = 1.1; 
                 minNeighbors: Integer { default: 3 } = 3; flags: Integer { default: 0 } = 0; 
                 minSize: PCvSize_t { default: Size() } = nil; maxSize: PCvSize_t { default: Size() } = nil; 
                 outputRejectLevels: Boolean { default: false } = false); cdecl;
Procedure  pCvCascadeClassifierdetectMultiScale3V2(const wrapper: PCvCascadeClassifier_t; image: PCvUMat_t; 
                 objects: PCvvector_Rect; rejectLevels: PCvvector_int; 
                 levelWeights: PCvvector_double; scaleFactor: Double { default: 1.1 } = 1.1; 
                 minNeighbors: Integer { default: 3 } = 3; flags: Integer { default: 0 } = 0; 
                 minSize: PCvSize_t { default: Size() } = nil; maxSize: PCvSize_t { default: Size() } = nil; 
                 outputRejectLevels: Boolean { default: false } = false); cdecl;
Function   pCvCascadeClassifierempty(const wrapper: PCvCascadeClassifier_t): Boolean; cdecl;
Function   pCvCascadeClassifiergetFeatureType(const wrapper: PCvCascadeClassifier_t): Integer; cdecl;
Function   pCvCascadeClassifiergetOriginalWindowSize(const wrapper: PCvCascadeClassifier_t): PCvSize_t; cdecl;
Function   pCvCascadeClassifierisOldFormatCascade(const wrapper: PCvCascadeClassifier_t): Boolean; cdecl;
Function   pCvCascadeClassifierload(const wrapper: PCvCascadeClassifier_t; filename: PCvString_t): Boolean; cdecl;
Function   pCvCascadeClassifierread(const wrapper: PCvCascadeClassifier_t; node: PCvFileNode_t): Boolean; cdecl;
Function   pCvCirclesGridFinderParametersGet_convexHullFactor(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_convexHullFactor(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_densityNeighborhoodSize(const wrapper: PCvCirclesGridFinderParameters_t): PCvSize2f_t; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_densityNeighborhoodSize(const wrapper: PCvCirclesGridFinderParameters_t; propval: PCvSize2f_t); cdecl;
Function   pCvCirclesGridFinderParametersGet_edgeGain(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_edgeGain(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_edgePenalty(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_edgePenalty(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_existingVertexGain(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_existingVertexGain(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_keypointScale(const wrapper: PCvCirclesGridFinderParameters_t): Integer; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_keypointScale(const wrapper: PCvCirclesGridFinderParameters_t; propval: Integer); cdecl;
Function   pCvCirclesGridFinderParametersGet_kmeansAttempts(const wrapper: PCvCirclesGridFinderParameters_t): Integer; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_kmeansAttempts(const wrapper: PCvCirclesGridFinderParameters_t; propval: Integer); cdecl;
Function   pCvCirclesGridFinderParametersGet_maxRectifiedDistance(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_maxRectifiedDistance(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_minDensity(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_minDensity(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_minDistanceToAddKeypoint(const wrapper: PCvCirclesGridFinderParameters_t): Integer; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_minDistanceToAddKeypoint(const wrapper: PCvCirclesGridFinderParameters_t; propval: Integer); cdecl;
Function   pCvCirclesGridFinderParametersGet_minGraphConfidence(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_minGraphConfidence(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_minRNGEdgeSwitchDist(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_minRNGEdgeSwitchDist(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_squareSize(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_squareSize(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_vertexGain(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_vertexGain(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Function   pCvCirclesGridFinderParametersGet_vertexPenalty(const wrapper: PCvCirclesGridFinderParameters_t): Single; cdecl;
Procedure  pCvCirclesGridFinderParametersSet_vertexPenalty(const wrapper: PCvCirclesGridFinderParameters_t; propval: Single); cdecl;
Procedure  pCvDISOpticalFlowcalc(const wrapper: PCvDISOpticalFlow_t; I0: PCvMat_t; I1: PCvMat_t; 
                 flow: PCvMat_t); cdecl;
Procedure  pCvDISOpticalFlowcalcV2(const wrapper: PCvDISOpticalFlow_t; I0: PCvUMat_t; I1: PCvUMat_t; 
                 flow: PCvUMat_t); cdecl;
Procedure  pCvDISOpticalFlowclear(const wrapper: PCvDISOpticalFlow_t); cdecl;
Procedure  pCvDISOpticalFlowcollectGarbage(const wrapper: PCvDISOpticalFlow_t); cdecl;
Function   pCvDISOpticalFlow_create(
                 preset: Integer { default: DISOpticalFlow::PRESET_FAST } = ord(DISOpticalFlow_PRESET_FAST)): PCvPtr_DISOpticalFlow; cdecl;
Function   pCvDISOpticalFlowempty(const wrapper: PCvDISOpticalFlow_t): Boolean; cdecl;
Function   pCvDISOpticalFlowgetDefaultName(const wrapper: PCvDISOpticalFlow_t): PCvString_t; cdecl;
Function   pCvDISOpticalFlowgetFinestScale(const wrapper: PCvDISOpticalFlow_t): Integer; cdecl;
Function   pCvDISOpticalFlowgetGradientDescentIterations(const wrapper: PCvDISOpticalFlow_t): Integer; cdecl;
Function   pCvDISOpticalFlowgetPatchSize(const wrapper: PCvDISOpticalFlow_t): Integer; cdecl;
Function   pCvDISOpticalFlowgetPatchStride(const wrapper: PCvDISOpticalFlow_t): Integer; cdecl;
Function   pCvDISOpticalFlowgetUseMeanNormalization(const wrapper: PCvDISOpticalFlow_t): Boolean; cdecl;
Function   pCvDISOpticalFlowgetUseSpatialPropagation(const wrapper: PCvDISOpticalFlow_t): Boolean; cdecl;
Function   pCvDISOpticalFlowgetVariationalRefinementAlpha(const wrapper: PCvDISOpticalFlow_t): Single; cdecl;
Function   pCvDISOpticalFlowgetVariationalRefinementDelta(const wrapper: PCvDISOpticalFlow_t): Single; cdecl;
Function   pCvDISOpticalFlowgetVariationalRefinementGamma(const wrapper: PCvDISOpticalFlow_t): Single; cdecl;
Function   pCvDISOpticalFlowgetVariationalRefinementIterations(const wrapper: PCvDISOpticalFlow_t): Integer; cdecl;
Procedure  pCvDISOpticalFlowread(const wrapper: PCvDISOpticalFlow_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvDISOpticalFlowsave(const wrapper: PCvDISOpticalFlow_t; filename: PCvString_t); cdecl;
Procedure  pCvDISOpticalFlowsetFinestScale(const wrapper: PCvDISOpticalFlow_t; _val: Integer); cdecl;
Procedure  pCvDISOpticalFlowsetGradientDescentIterations(const wrapper: PCvDISOpticalFlow_t; _val: Integer); cdecl;
Procedure  pCvDISOpticalFlowsetPatchSize(const wrapper: PCvDISOpticalFlow_t; _val: Integer); cdecl;
Procedure  pCvDISOpticalFlowsetPatchStride(const wrapper: PCvDISOpticalFlow_t; _val: Integer); cdecl;
Procedure  pCvDISOpticalFlowsetUseMeanNormalization(const wrapper: PCvDISOpticalFlow_t; _val: Boolean); cdecl;
Procedure  pCvDISOpticalFlowsetUseSpatialPropagation(const wrapper: PCvDISOpticalFlow_t; _val: Boolean); cdecl;
Procedure  pCvDISOpticalFlowsetVariationalRefinementAlpha(const wrapper: PCvDISOpticalFlow_t; _val: Single); cdecl;
Procedure  pCvDISOpticalFlowsetVariationalRefinementDelta(const wrapper: PCvDISOpticalFlow_t; _val: Single); cdecl;
Procedure  pCvDISOpticalFlowsetVariationalRefinementGamma(const wrapper: PCvDISOpticalFlow_t; _val: Single); cdecl;
Procedure  pCvDISOpticalFlowsetVariationalRefinementIterations(const wrapper: PCvDISOpticalFlow_t; _val: Integer); cdecl;
Procedure  pCvDISOpticalFlowwrite(const wrapper: PCvDISOpticalFlow_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvDMatchGet_distance(const wrapper: PCvDMatch_t): Single; cdecl;
Procedure  pCvDMatchSet_distance(const wrapper: PCvDMatch_t; propval: Single); cdecl;
Function   pCvDMatchGet_imgIdx(const wrapper: PCvDMatch_t): Integer; cdecl;
Procedure  pCvDMatchSet_imgIdx(const wrapper: PCvDMatch_t; propval: Integer); cdecl;
Function   pCvDMatchGet_queryIdx(const wrapper: PCvDMatch_t): Integer; cdecl;
Procedure  pCvDMatchSet_queryIdx(const wrapper: PCvDMatch_t; propval: Integer); cdecl;
Function   pCvDMatchGet_trainIdx(const wrapper: PCvDMatch_t): Integer; cdecl;
Procedure  pCvDMatchSet_trainIdx(const wrapper: PCvDMatch_t; propval: Integer); cdecl;
Procedure  pCvDenseOpticalFlowcalc(const wrapper: PCvDenseOpticalFlow_t; I0: PCvMat_t; I1: PCvMat_t; 
                 flow: PCvMat_t); cdecl;
Procedure  pCvDenseOpticalFlowcalcV2(const wrapper: PCvDenseOpticalFlow_t; I0: PCvUMat_t; I1: PCvUMat_t; 
                 flow: PCvUMat_t); cdecl;
Procedure  pCvDenseOpticalFlowclear(const wrapper: PCvDenseOpticalFlow_t); cdecl;
Procedure  pCvDenseOpticalFlowcollectGarbage(const wrapper: PCvDenseOpticalFlow_t); cdecl;
Function   pCvDenseOpticalFlowempty(const wrapper: PCvDenseOpticalFlow_t): Boolean; cdecl;
Function   pCvDenseOpticalFlowgetDefaultName(const wrapper: PCvDenseOpticalFlow_t): PCvString_t; cdecl;
Procedure  pCvDenseOpticalFlowread(const wrapper: PCvDenseOpticalFlow_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvDenseOpticalFlowsave(const wrapper: PCvDenseOpticalFlow_t; filename: PCvString_t); cdecl;
Procedure  pCvDenseOpticalFlowwrite(const wrapper: PCvDenseOpticalFlow_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvDescriptorMatcheradd(const wrapper: PCvDescriptorMatcher_t; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvDescriptorMatcheraddV2(const wrapper: PCvDescriptorMatcher_t; descriptors: PCvvector_UMat); cdecl;
Procedure  pCvDescriptorMatcherclear(const wrapper: PCvDescriptorMatcher_t); cdecl;
Function   pCvDescriptorMatcherclone(const wrapper: PCvDescriptorMatcher_t; emptyTrainData: Boolean { default: false } = false): PCvPtr_DescriptorMatcher; cdecl;
Function   pCvDescriptorMatcher_create(descriptorMatcherType: PCvString_t): PCvPtr_DescriptorMatcher; cdecl;
Function   pCvDescriptorMatcher_createV2(matcherType: TCvDescriptorMatcher_MatcherType): PCvPtr_DescriptorMatcher; cdecl;
Function   pCvDescriptorMatcherempty(const wrapper: PCvDescriptorMatcher_t): Boolean; cdecl;
Function   pCvDescriptorMatchergetDefaultName(const wrapper: PCvDescriptorMatcher_t): PCvString_t; cdecl;
Function   pCvDescriptorMatchergetTrainDescriptors(const wrapper: PCvDescriptorMatcher_t): PCvvector_Mat; cdecl;
Function   pCvDescriptorMatcherisMaskSupported(const wrapper: PCvDescriptorMatcher_t): Boolean; cdecl;
Procedure  pCvDescriptorMatcherknnMatch(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; 
                 mask: PCvMat_t { default: Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherknnMatchV2(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_vector_DMatch; k: Integer; 
                 mask: PCvUMat_t { default: UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherknnMatchV3(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_vector_DMatch; k: Integer; 
                 masks: PCvvector_Mat { default: vector_Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherknnMatchV4(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_vector_DMatch; k: Integer; 
                 masks: PCvvector_UMat { default: vector_UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatchermatch(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_DMatch; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvDescriptorMatchermatchV2(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_DMatch; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvDescriptorMatchermatchV3(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_DMatch; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvDescriptorMatchermatchV4(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_DMatch; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvDescriptorMatcherradiusMatch(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 mask: PCvMat_t { default: Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherradiusMatchV2(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 mask: PCvUMat_t { default: UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherradiusMatchV3(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 masks: PCvvector_Mat { default: vector_Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherradiusMatchV4(const wrapper: PCvDescriptorMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 masks: PCvvector_UMat { default: vector_UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvDescriptorMatcherread(const wrapper: PCvDescriptorMatcher_t; fileName: PCvString_t); cdecl;
Procedure  pCvDescriptorMatcherreadV2(const wrapper: PCvDescriptorMatcher_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvDescriptorMatchersave(const wrapper: PCvDescriptorMatcher_t; filename: PCvString_t); cdecl;
Procedure  pCvDescriptorMatchertrain(const wrapper: PCvDescriptorMatcher_t); cdecl;
Procedure  pCvDescriptorMatcherwrite(const wrapper: PCvDescriptorMatcher_t; fileName: PCvString_t); cdecl;
Procedure  pCvDescriptorMatcherwriteV2(const wrapper: PCvDescriptorMatcher_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvFaceDetectorYN_create(model: PCvString_t; config: PCvString_t; input_size: PCvSize_t; 
                 score_threshold: Single { default: 0.9f } = 0.9; nms_threshold: Single { default: 0.3f } = 0.3; 
                 top_k: Integer { default: 5000 } = 5000; backend_id: Integer { default: 0 } = 0; 
                 target_id: Integer { default: 0 } = 0): PCvPtr_FaceDetectorYN; cdecl;
Function   pCvFaceDetectorYNdetect(const wrapper: PCvFaceDetectorYN_t; image: PCvMat_t; faces: PCvMat_t): Integer; cdecl;
Function   pCvFaceDetectorYNdetectV2(const wrapper: PCvFaceDetectorYN_t; image: PCvUMat_t; 
                 faces: PCvUMat_t): Integer; cdecl;
Function   pCvFaceDetectorYNgetInputSize(const wrapper: PCvFaceDetectorYN_t): PCvSize_t; cdecl;
Function   pCvFaceDetectorYNgetNMSThreshold(const wrapper: PCvFaceDetectorYN_t): Single; cdecl;
Function   pCvFaceDetectorYNgetScoreThreshold(const wrapper: PCvFaceDetectorYN_t): Single; cdecl;
Function   pCvFaceDetectorYNgetTopK(const wrapper: PCvFaceDetectorYN_t): Integer; cdecl;
Procedure  pCvFaceDetectorYNsetInputSize(const wrapper: PCvFaceDetectorYN_t; input_size: PCvSize_t); cdecl;
Procedure  pCvFaceDetectorYNsetNMSThreshold(const wrapper: PCvFaceDetectorYN_t; nms_threshold: Single); cdecl;
Procedure  pCvFaceDetectorYNsetScoreThreshold(const wrapper: PCvFaceDetectorYN_t; score_threshold: Single); cdecl;
Procedure  pCvFaceDetectorYNsetTopK(const wrapper: PCvFaceDetectorYN_t; top_k: Integer); cdecl;
Procedure  pCvFaceRecognizerSFalignCrop(const wrapper: PCvFaceRecognizerSF_t; src_img: PCvMat_t; 
                 face_box: PCvMat_t; aligned_img: PCvMat_t); cdecl;
Procedure  pCvFaceRecognizerSFalignCropV2(const wrapper: PCvFaceRecognizerSF_t; src_img: PCvUMat_t; 
                 face_box: PCvUMat_t; aligned_img: PCvUMat_t); cdecl;
Function   pCvFaceRecognizerSF_create(model: PCvString_t; config: PCvString_t; 
                 backend_id: Integer { default: 0 } = 0; target_id: Integer { default: 0 } = 0): PCvPtr_FaceRecognizerSF; cdecl;
Procedure  pCvFaceRecognizerSFfeature(const wrapper: PCvFaceRecognizerSF_t; aligned_img: PCvMat_t; 
                 face_feature: PCvMat_t); cdecl;
Procedure  pCvFaceRecognizerSFfeatureV2(const wrapper: PCvFaceRecognizerSF_t; aligned_img: PCvUMat_t; 
                 face_feature: PCvUMat_t); cdecl;
Function   pCvFaceRecognizerSFmatch(const wrapper: PCvFaceRecognizerSF_t; face_feature1: PCvMat_t; 
                 face_feature2: PCvMat_t; 
                 dis_type: Integer { default: FaceRecognizerSF::FR_COSINE } = ord(TCvFaceRecognizerSF_DisType.FR_COSINE)): Double; cdecl;
Function   pCvFaceRecognizerSFmatchV2(const wrapper: PCvFaceRecognizerSF_t; face_feature1: PCvUMat_t; 
                 face_feature2: PCvUMat_t; 
                 dis_type: Integer { default: FaceRecognizerSF::FR_COSINE } = ord(TCvFaceRecognizerSF_DisType.FR_COSINE)): Double; cdecl;
Procedure  pCvFarnebackOpticalFlowcalc(const wrapper: PCvFarnebackOpticalFlow_t; I0: PCvMat_t; 
                 I1: PCvMat_t; flow: PCvMat_t); cdecl;
Procedure  pCvFarnebackOpticalFlowcalcV2(const wrapper: PCvFarnebackOpticalFlow_t; I0: PCvUMat_t; 
                 I1: PCvUMat_t; flow: PCvUMat_t); cdecl;
Procedure  pCvFarnebackOpticalFlowclear(const wrapper: PCvFarnebackOpticalFlow_t); cdecl;
Procedure  pCvFarnebackOpticalFlowcollectGarbage(const wrapper: PCvFarnebackOpticalFlow_t); cdecl;
Function   pCvFarnebackOpticalFlow_create(numLevels: Integer { default: 5 } = 5; 
                 pyrScale: Double { default: 0.5 } = 0.5; fastPyramids: Boolean { default: false } = false; 
                 winSize: Integer { default: 13 } = 13; numIters: Integer { default: 10 } = 10; 
                 polyN: Integer { default: 5 } = 5; polySigma: Double { default: 1.1 } = 1.1; 
                 flags: Integer { default: 0 } = 0): PCvPtr_FarnebackOpticalFlow; cdecl;
Function   pCvFarnebackOpticalFlowempty(const wrapper: PCvFarnebackOpticalFlow_t): Boolean; cdecl;
Function   pCvFarnebackOpticalFlowgetDefaultName(const wrapper: PCvFarnebackOpticalFlow_t): PCvString_t; cdecl;
Function   pCvFarnebackOpticalFlowgetFastPyramids(const wrapper: PCvFarnebackOpticalFlow_t): Boolean; cdecl;
Function   pCvFarnebackOpticalFlowgetFlags(const wrapper: PCvFarnebackOpticalFlow_t): Integer; cdecl;
Function   pCvFarnebackOpticalFlowgetNumIters(const wrapper: PCvFarnebackOpticalFlow_t): Integer; cdecl;
Function   pCvFarnebackOpticalFlowgetNumLevels(const wrapper: PCvFarnebackOpticalFlow_t): Integer; cdecl;
Function   pCvFarnebackOpticalFlowgetPolyN(const wrapper: PCvFarnebackOpticalFlow_t): Integer; cdecl;
Function   pCvFarnebackOpticalFlowgetPolySigma(const wrapper: PCvFarnebackOpticalFlow_t): Double; cdecl;
Function   pCvFarnebackOpticalFlowgetPyrScale(const wrapper: PCvFarnebackOpticalFlow_t): Double; cdecl;
Function   pCvFarnebackOpticalFlowgetWinSize(const wrapper: PCvFarnebackOpticalFlow_t): Integer; cdecl;
Procedure  pCvFarnebackOpticalFlowread(const wrapper: PCvFarnebackOpticalFlow_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvFarnebackOpticalFlowsave(const wrapper: PCvFarnebackOpticalFlow_t; filename: PCvString_t); cdecl;
Procedure  pCvFarnebackOpticalFlowsetFastPyramids(const wrapper: PCvFarnebackOpticalFlow_t; fastPyramids: Boolean); cdecl;
Procedure  pCvFarnebackOpticalFlowsetFlags(const wrapper: PCvFarnebackOpticalFlow_t; flags: Integer); cdecl;
Procedure  pCvFarnebackOpticalFlowsetNumIters(const wrapper: PCvFarnebackOpticalFlow_t; numIters: Integer); cdecl;
Procedure  pCvFarnebackOpticalFlowsetNumLevels(const wrapper: PCvFarnebackOpticalFlow_t; numLevels: Integer); cdecl;
Procedure  pCvFarnebackOpticalFlowsetPolyN(const wrapper: PCvFarnebackOpticalFlow_t; polyN: Integer); cdecl;
Procedure  pCvFarnebackOpticalFlowsetPolySigma(const wrapper: PCvFarnebackOpticalFlow_t; polySigma: Double); cdecl;
Procedure  pCvFarnebackOpticalFlowsetPyrScale(const wrapper: PCvFarnebackOpticalFlow_t; pyrScale: Double); cdecl;
Procedure  pCvFarnebackOpticalFlowsetWinSize(const wrapper: PCvFarnebackOpticalFlow_t; winSize: Integer); cdecl;
Procedure  pCvFarnebackOpticalFlowwrite(const wrapper: PCvFarnebackOpticalFlow_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvFastFeatureDetectorclear(const wrapper: PCvFastFeatureDetector_t); cdecl;
Procedure  pCvFastFeatureDetectorcompute(const wrapper: PCvFastFeatureDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvFastFeatureDetectorcomputeV2(const wrapper: PCvFastFeatureDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t); cdecl;
Procedure  pCvFastFeatureDetectorcomputeV3(const wrapper: PCvFastFeatureDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvFastFeatureDetectorcomputeV4(const wrapper: PCvFastFeatureDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvFastFeatureDetector_create(threshold: Integer { default: 10 } = 10; 
                 nonmaxSuppression: Boolean { default: true } = true; 
                 _type: TCvFastFeatureDetector_DetectorType { default: FastFeatureDetector::TYPE_9_16 } = TCvFastFeatureDetector_DetectorType.TYPE_9_16): PCvPtr_FastFeatureDetector; cdecl;
Function   pCvFastFeatureDetectordefaultNorm(const wrapper: PCvFastFeatureDetector_t): Integer; cdecl;
Function   pCvFastFeatureDetectordescriptorSize(const wrapper: PCvFastFeatureDetector_t): Integer; cdecl;
Function   pCvFastFeatureDetectordescriptorType(const wrapper: PCvFastFeatureDetector_t): Integer; cdecl;
Procedure  pCvFastFeatureDetectordetect(const wrapper: PCvFastFeatureDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvFastFeatureDetectordetectV2(const wrapper: PCvFastFeatureDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvFastFeatureDetectordetectV3(const wrapper: PCvFastFeatureDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvFastFeatureDetectordetectV4(const wrapper: PCvFastFeatureDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvFastFeatureDetectordetectAndCompute(const wrapper: PCvFastFeatureDetector_t; image: PCvMat_t; 
                 mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvFastFeatureDetectordetectAndComputeV2(const wrapper: PCvFastFeatureDetector_t; image: PCvUMat_t; 
                 mask: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvFastFeatureDetectorempty(const wrapper: PCvFastFeatureDetector_t): Boolean; cdecl;
Function   pCvFastFeatureDetectorgetDefaultName(const wrapper: PCvFastFeatureDetector_t): PCvString_t; cdecl;
Function   pCvFastFeatureDetectorgetNonmaxSuppression(const wrapper: PCvFastFeatureDetector_t): Boolean; cdecl;
Function   pCvFastFeatureDetectorgetThreshold(const wrapper: PCvFastFeatureDetector_t): Integer; cdecl;
Function   pCvFastFeatureDetectorgetType(const wrapper: PCvFastFeatureDetector_t): TCvFastFeatureDetector_DetectorType; cdecl;
Procedure  pCvFastFeatureDetectorread(const wrapper: PCvFastFeatureDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvFastFeatureDetectorreadV2(const wrapper: PCvFastFeatureDetector_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvFastFeatureDetectorsave(const wrapper: PCvFastFeatureDetector_t; filename: PCvString_t); cdecl;
Procedure  pCvFastFeatureDetectorsetNonmaxSuppression(const wrapper: PCvFastFeatureDetector_t; f: Boolean); cdecl;
Procedure  pCvFastFeatureDetectorsetThreshold(const wrapper: PCvFastFeatureDetector_t; threshold: Integer); cdecl;
Procedure  pCvFastFeatureDetectorsetType(const wrapper: PCvFastFeatureDetector_t; _type: TCvFastFeatureDetector_DetectorType); cdecl;
Procedure  pCvFastFeatureDetectorwrite(const wrapper: PCvFastFeatureDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvFastFeatureDetectorwriteV2(const wrapper: PCvFastFeatureDetector_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvFeature2Dclear(const wrapper: PCvFeature2D_t); cdecl;
Procedure  pCvFeature2Dcompute(const wrapper: PCvFeature2D_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvFeature2DcomputeV2(const wrapper: PCvFeature2D_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t); cdecl;
Procedure  pCvFeature2DcomputeV3(const wrapper: PCvFeature2D_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvFeature2DcomputeV4(const wrapper: PCvFeature2D_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvFeature2DdefaultNorm(const wrapper: PCvFeature2D_t): Integer; cdecl;
Function   pCvFeature2DdescriptorSize(const wrapper: PCvFeature2D_t): Integer; cdecl;
Function   pCvFeature2DdescriptorType(const wrapper: PCvFeature2D_t): Integer; cdecl;
Procedure  pCvFeature2Ddetect(const wrapper: PCvFeature2D_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvFeature2DdetectV2(const wrapper: PCvFeature2D_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvFeature2DdetectV3(const wrapper: PCvFeature2D_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvFeature2DdetectV4(const wrapper: PCvFeature2D_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvFeature2DdetectAndCompute(const wrapper: PCvFeature2D_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvFeature2DdetectAndComputeV2(const wrapper: PCvFeature2D_t; image: PCvUMat_t; 
                 mask: PCvUMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvFeature2Dempty(const wrapper: PCvFeature2D_t): Boolean; cdecl;
Function   pCvFeature2DgetDefaultName(const wrapper: PCvFeature2D_t): PCvString_t; cdecl;
Procedure  pCvFeature2Dread(const wrapper: PCvFeature2D_t; fileName: PCvString_t); cdecl;
Procedure  pCvFeature2DreadV2(const wrapper: PCvFeature2D_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvFeature2Dsave(const wrapper: PCvFeature2D_t; filename: PCvString_t); cdecl;
Procedure  pCvFeature2Dwrite(const wrapper: PCvFeature2D_t; fileName: PCvString_t); cdecl;
Procedure  pCvFeature2DwriteV2(const wrapper: PCvFeature2D_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvFileNodeat(const wrapper: PCvFileNode_t; i: Integer): PCvFileNode_t; cdecl;
Function   pCvFileNodeempty(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodegetNode(const wrapper: PCvFileNode_t; nodename: PAnsiChar): PCvFileNode_t; cdecl;
Function   pCvFileNodeisInt(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisMap(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisNamed(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisNone(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisReal(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisSeq(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodeisString(const wrapper: PCvFileNode_t): Boolean; cdecl;
Function   pCvFileNodekeys(const wrapper: PCvFileNode_t): PCvvector_String; cdecl;
Function   pCvFileNodemat(const wrapper: PCvFileNode_t): PCvMat_t; cdecl;
Function   pCvFileNodename(const wrapper: PCvFileNode_t): PCvString_t; cdecl;
Function   pCvFileNoderawSize(const wrapper: PCvFileNode_t): UInt64; cdecl;
Function   pCvFileNodereal(const wrapper: PCvFileNode_t): Double; cdecl;
Function   pCvFileNodesize(const wrapper: PCvFileNode_t): UInt64; cdecl;
Function   pCvFileNodestring(const wrapper: PCvFileNode_t): PCvString_t; cdecl;
Function   pCvFileNodetype(const wrapper: PCvFileNode_t): Integer; cdecl;
Procedure  pCvFileStorageendWriteStruct(const wrapper: PCvFileStorage_t); cdecl;
Function   pCvFileStoragegetFirstTopLevelNode(const wrapper: PCvFileStorage_t): PCvFileNode_t; cdecl;
Function   pCvFileStoragegetFormat(const wrapper: PCvFileStorage_t): Integer; cdecl;
Function   pCvFileStoragegetNode(const wrapper: PCvFileStorage_t; nodename: PAnsiChar): PCvFileNode_t; cdecl;
Function   pCvFileStorageisOpened(const wrapper: PCvFileStorage_t): Boolean; cdecl;
Function   pCvFileStorageopen(const wrapper: PCvFileStorage_t; filename: PCvString_t; flags: Integer; 
                 encoding: PCvString_t { default: String() } = nil): Boolean; cdecl;
Procedure  pCvFileStoragerelease(const wrapper: PCvFileStorage_t); cdecl;
Function   pCvFileStoragereleaseAndGetString(const wrapper: PCvFileStorage_t): PCvString_t; cdecl;
Function   pCvFileStorageroot(const wrapper: PCvFileStorage_t; streamidx: Integer { default: 0 } = 0): PCvFileNode_t; cdecl;
Procedure  pCvFileStoragestartWriteStruct(const wrapper: PCvFileStorage_t; name: PCvString_t; 
                 flags: Integer; typeName: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvFileStoragewrite(const wrapper: PCvFileStorage_t; name: PCvString_t; _val: Integer); cdecl;
Procedure  pCvFileStoragewriteV2(const wrapper: PCvFileStorage_t; name: PCvString_t; _val: Double); cdecl;
Procedure  pCvFileStoragewriteV3(const wrapper: PCvFileStorage_t; name: PCvString_t; _val: PCvString_t); cdecl;
Procedure  pCvFileStoragewriteV4(const wrapper: PCvFileStorage_t; name: PCvString_t; _val: PCvMat_t); cdecl;
Procedure  pCvFileStoragewriteV5(const wrapper: PCvFileStorage_t; name: PCvString_t; 
                 _val: PCvvector_String); cdecl;
Procedure  pCvFileStoragewriteComment(const wrapper: PCvFileStorage_t; comment: PCvString_t; 
                 _append: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcheradd(const wrapper: PCvFlannBasedMatcher_t; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvFlannBasedMatcheraddV2(const wrapper: PCvFlannBasedMatcher_t; descriptors: PCvvector_UMat); cdecl;
Procedure  pCvFlannBasedMatcherclear(const wrapper: PCvFlannBasedMatcher_t); cdecl;
Function   pCvFlannBasedMatcherclone(const wrapper: PCvFlannBasedMatcher_t; emptyTrainData: Boolean { default: false } = false): PCvPtr_DescriptorMatcher; cdecl;
Function   pCvFlannBasedMatcher_create(): PCvPtr_FlannBasedMatcher; cdecl;
Function   pCvFlannBasedMatcherempty(const wrapper: PCvFlannBasedMatcher_t): Boolean; cdecl;
Function   pCvFlannBasedMatchergetDefaultName(const wrapper: PCvFlannBasedMatcher_t): PCvString_t; cdecl;
Function   pCvFlannBasedMatchergetTrainDescriptors(const wrapper: PCvFlannBasedMatcher_t): PCvvector_Mat; cdecl;
Function   pCvFlannBasedMatcherisMaskSupported(const wrapper: PCvFlannBasedMatcher_t): Boolean; cdecl;
Procedure  pCvFlannBasedMatcherknnMatch(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; k: Integer; 
                 mask: PCvMat_t { default: Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcherknnMatchV2(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_vector_DMatch; k: Integer; 
                 mask: PCvUMat_t { default: UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcherknnMatchV3(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_vector_DMatch; k: Integer; 
                 masks: PCvvector_Mat { default: vector_Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcherknnMatchV4(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_vector_DMatch; k: Integer; 
                 masks: PCvvector_UMat { default: vector_UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatchermatch(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_DMatch; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvFlannBasedMatchermatchV2(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_DMatch; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvFlannBasedMatchermatchV3(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_DMatch; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvFlannBasedMatchermatchV4(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_DMatch; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvFlannBasedMatcherradiusMatch(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; 
                 trainDescriptors: PCvMat_t; matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 mask: PCvMat_t { default: Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcherradiusMatchV2(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvUMat_t; 
                 trainDescriptors: PCvUMat_t; matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 mask: PCvUMat_t { default: UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcherradiusMatchV3(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvMat_t; 
                 matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 masks: PCvvector_Mat { default: vector_Mat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatcherradiusMatchV4(const wrapper: PCvFlannBasedMatcher_t; queryDescriptors: PCvUMat_t; 
                 matches: PCvvector_vector_DMatch; maxDistance: Single; 
                 masks: PCvvector_UMat { default: vector_UMat() } = nil; compactResult: Boolean { default: false } = false); cdecl;
Procedure  pCvFlannBasedMatchersave(const wrapper: PCvFlannBasedMatcher_t; filename: PCvString_t); cdecl;
Procedure  pCvFlannBasedMatchertrain(const wrapper: PCvFlannBasedMatcher_t); cdecl;
Procedure  pCvGFTTDetectorclear(const wrapper: PCvGFTTDetector_t); cdecl;
Procedure  pCvGFTTDetectorcompute(const wrapper: PCvGFTTDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvGFTTDetectorcomputeV2(const wrapper: PCvGFTTDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t); cdecl;
Procedure  pCvGFTTDetectorcomputeV3(const wrapper: PCvGFTTDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvGFTTDetectorcomputeV4(const wrapper: PCvGFTTDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvGFTTDetector_create(maxCorners: Integer { default: 1000 } = 1000; 
                 qualityLevel: Double { default: 0.01 } = 0.01; minDistance: Double { default: 1 } = 1; 
                 blockSize: Integer { default: 3 } = 3; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04): PCvPtr_GFTTDetector; cdecl;
Function   pCvGFTTDetector_createV2(maxCorners: Integer; qualityLevel: Double; minDistance: Double; 
                 blockSize: Integer; gradiantSize: Integer; 
                 useHarrisDetector: Boolean { default: false } = false; k: Double { default: 0.04 } = 0.04): PCvPtr_GFTTDetector; cdecl;
Function   pCvGFTTDetectordefaultNorm(const wrapper: PCvGFTTDetector_t): Integer; cdecl;
Function   pCvGFTTDetectordescriptorSize(const wrapper: PCvGFTTDetector_t): Integer; cdecl;
Function   pCvGFTTDetectordescriptorType(const wrapper: PCvGFTTDetector_t): Integer; cdecl;
Procedure  pCvGFTTDetectordetect(const wrapper: PCvGFTTDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGFTTDetectordetectV2(const wrapper: PCvGFTTDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvGFTTDetectordetectV3(const wrapper: PCvGFTTDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvGFTTDetectordetectV4(const wrapper: PCvGFTTDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvGFTTDetectordetectAndCompute(const wrapper: PCvGFTTDetector_t; image: PCvMat_t; 
                 mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvGFTTDetectordetectAndComputeV2(const wrapper: PCvGFTTDetector_t; image: PCvUMat_t; 
                 mask: PCvUMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvGFTTDetectorempty(const wrapper: PCvGFTTDetector_t): Boolean; cdecl;
Function   pCvGFTTDetectorgetBlockSize(const wrapper: PCvGFTTDetector_t): Integer; cdecl;
Function   pCvGFTTDetectorgetDefaultName(const wrapper: PCvGFTTDetector_t): PCvString_t; cdecl;
Function   pCvGFTTDetectorgetHarrisDetector(const wrapper: PCvGFTTDetector_t): Boolean; cdecl;
Function   pCvGFTTDetectorgetK(const wrapper: PCvGFTTDetector_t): Double; cdecl;
Function   pCvGFTTDetectorgetMaxFeatures(const wrapper: PCvGFTTDetector_t): Integer; cdecl;
Function   pCvGFTTDetectorgetMinDistance(const wrapper: PCvGFTTDetector_t): Double; cdecl;
Function   pCvGFTTDetectorgetQualityLevel(const wrapper: PCvGFTTDetector_t): Double; cdecl;
Procedure  pCvGFTTDetectorread(const wrapper: PCvGFTTDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvGFTTDetectorreadV2(const wrapper: PCvGFTTDetector_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvGFTTDetectorsave(const wrapper: PCvGFTTDetector_t; filename: PCvString_t); cdecl;
Procedure  pCvGFTTDetectorsetBlockSize(const wrapper: PCvGFTTDetector_t; blockSize: Integer); cdecl;
Procedure  pCvGFTTDetectorsetHarrisDetector(const wrapper: PCvGFTTDetector_t; _val: Boolean); cdecl;
Procedure  pCvGFTTDetectorsetK(const wrapper: PCvGFTTDetector_t; k: Double); cdecl;
Procedure  pCvGFTTDetectorsetMaxFeatures(const wrapper: PCvGFTTDetector_t; maxFeatures: Integer); cdecl;
Procedure  pCvGFTTDetectorsetMinDistance(const wrapper: PCvGFTTDetector_t; minDistance: Double); cdecl;
Procedure  pCvGFTTDetectorsetQualityLevel(const wrapper: PCvGFTTDetector_t; qlevel: Double); cdecl;
Procedure  pCvGFTTDetectorwrite(const wrapper: PCvGFTTDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvGFTTDetectorwriteV2(const wrapper: PCvGFTTDetector_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvGeneralizedHoughclear(const wrapper: PCvGeneralizedHough_t); cdecl;
Procedure  pCvGeneralizedHoughdetect(const wrapper: PCvGeneralizedHough_t; image: PCvMat_t; 
                 positions: PCvMat_t; votes: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughdetectV2(const wrapper: PCvGeneralizedHough_t; image: PCvUMat_t; 
                 positions: PCvUMat_t; votes: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughdetectV3(const wrapper: PCvGeneralizedHough_t; edges: PCvMat_t; 
                 dx: PCvMat_t; dy: PCvMat_t; positions: PCvMat_t; 
                 votes: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughdetectV4(const wrapper: PCvGeneralizedHough_t; edges: PCvUMat_t; 
                 dx: PCvUMat_t; dy: PCvUMat_t; positions: PCvUMat_t; 
                 votes: PCvUMat_t { default: UMat() } = nil); cdecl;
Function   pCvGeneralizedHoughempty(const wrapper: PCvGeneralizedHough_t): Boolean; cdecl;
Function   pCvGeneralizedHoughgetCannyHighThresh(const wrapper: PCvGeneralizedHough_t): Integer; cdecl;
Function   pCvGeneralizedHoughgetCannyLowThresh(const wrapper: PCvGeneralizedHough_t): Integer; cdecl;
Function   pCvGeneralizedHoughgetDefaultName(const wrapper: PCvGeneralizedHough_t): PCvString_t; cdecl;
Function   pCvGeneralizedHoughgetDp(const wrapper: PCvGeneralizedHough_t): Double; cdecl;
Function   pCvGeneralizedHoughgetMaxBufferSize(const wrapper: PCvGeneralizedHough_t): Integer; cdecl;
Function   pCvGeneralizedHoughgetMinDist(const wrapper: PCvGeneralizedHough_t): Double; cdecl;
Procedure  pCvGeneralizedHoughread(const wrapper: PCvGeneralizedHough_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvGeneralizedHoughsave(const wrapper: PCvGeneralizedHough_t; filename: PCvString_t); cdecl;
Procedure  pCvGeneralizedHoughsetCannyHighThresh(const wrapper: PCvGeneralizedHough_t; cannyHighThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughsetCannyLowThresh(const wrapper: PCvGeneralizedHough_t; cannyLowThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughsetDp(const wrapper: PCvGeneralizedHough_t; dp: Double); cdecl;
Procedure  pCvGeneralizedHoughsetMaxBufferSize(const wrapper: PCvGeneralizedHough_t; maxBufferSize: Integer); cdecl;
Procedure  pCvGeneralizedHoughsetMinDist(const wrapper: PCvGeneralizedHough_t; minDist: Double); cdecl;
Procedure  pCvGeneralizedHoughsetTemplate(const wrapper: PCvGeneralizedHough_t; templ: PCvMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughsetTemplateV2(const wrapper: PCvGeneralizedHough_t; templ: PCvUMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughsetTemplateV3(const wrapper: PCvGeneralizedHough_t; edges: PCvMat_t; 
                 dx: PCvMat_t; dy: PCvMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughsetTemplateV4(const wrapper: PCvGeneralizedHough_t; edges: PCvUMat_t; 
                 dx: PCvUMat_t; dy: PCvUMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughwrite(const wrapper: PCvGeneralizedHough_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallardclear(const wrapper: PCvGeneralizedHoughBallard_t); cdecl;
Procedure  pCvGeneralizedHoughBallarddetect(const wrapper: PCvGeneralizedHoughBallard_t; image: PCvMat_t; 
                 positions: PCvMat_t; votes: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallarddetectV2(const wrapper: PCvGeneralizedHoughBallard_t; image: PCvUMat_t; 
                 positions: PCvUMat_t; votes: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallarddetectV3(const wrapper: PCvGeneralizedHoughBallard_t; edges: PCvMat_t; 
                 dx: PCvMat_t; dy: PCvMat_t; positions: PCvMat_t; 
                 votes: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallarddetectV4(const wrapper: PCvGeneralizedHoughBallard_t; edges: PCvUMat_t; 
                 dx: PCvUMat_t; dy: PCvUMat_t; positions: PCvUMat_t; 
                 votes: PCvUMat_t { default: UMat() } = nil); cdecl;
Function   pCvGeneralizedHoughBallardempty(const wrapper: PCvGeneralizedHoughBallard_t): Boolean; cdecl;
Function   pCvGeneralizedHoughBallardgetCannyHighThresh(const wrapper: PCvGeneralizedHoughBallard_t): Integer; cdecl;
Function   pCvGeneralizedHoughBallardgetCannyLowThresh(const wrapper: PCvGeneralizedHoughBallard_t): Integer; cdecl;
Function   pCvGeneralizedHoughBallardgetDefaultName(const wrapper: PCvGeneralizedHoughBallard_t): PCvString_t; cdecl;
Function   pCvGeneralizedHoughBallardgetDp(const wrapper: PCvGeneralizedHoughBallard_t): Double; cdecl;
Function   pCvGeneralizedHoughBallardgetLevels(const wrapper: PCvGeneralizedHoughBallard_t): Integer; cdecl;
Function   pCvGeneralizedHoughBallardgetMaxBufferSize(const wrapper: PCvGeneralizedHoughBallard_t): Integer; cdecl;
Function   pCvGeneralizedHoughBallardgetMinDist(const wrapper: PCvGeneralizedHoughBallard_t): Double; cdecl;
Function   pCvGeneralizedHoughBallardgetVotesThreshold(const wrapper: PCvGeneralizedHoughBallard_t): Integer; cdecl;
Procedure  pCvGeneralizedHoughBallardread(const wrapper: PCvGeneralizedHoughBallard_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvGeneralizedHoughBallardsave(const wrapper: PCvGeneralizedHoughBallard_t; filename: PCvString_t); cdecl;
Procedure  pCvGeneralizedHoughBallardsetCannyHighThresh(const wrapper: PCvGeneralizedHoughBallard_t; cannyHighThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughBallardsetCannyLowThresh(const wrapper: PCvGeneralizedHoughBallard_t; cannyLowThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughBallardsetDp(const wrapper: PCvGeneralizedHoughBallard_t; dp: Double); cdecl;
Procedure  pCvGeneralizedHoughBallardsetLevels(const wrapper: PCvGeneralizedHoughBallard_t; levels: Integer); cdecl;
Procedure  pCvGeneralizedHoughBallardsetMaxBufferSize(const wrapper: PCvGeneralizedHoughBallard_t; maxBufferSize: Integer); cdecl;
Procedure  pCvGeneralizedHoughBallardsetMinDist(const wrapper: PCvGeneralizedHoughBallard_t; minDist: Double); cdecl;
Procedure  pCvGeneralizedHoughBallardsetTemplate(const wrapper: PCvGeneralizedHoughBallard_t; templ: PCvMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallardsetTemplateV2(const wrapper: PCvGeneralizedHoughBallard_t; templ: PCvUMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallardsetTemplateV3(const wrapper: PCvGeneralizedHoughBallard_t; edges: PCvMat_t; 
                 dx: PCvMat_t; dy: PCvMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallardsetTemplateV4(const wrapper: PCvGeneralizedHoughBallard_t; edges: PCvUMat_t; 
                 dx: PCvUMat_t; dy: PCvUMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughBallardsetVotesThreshold(const wrapper: PCvGeneralizedHoughBallard_t; votesThreshold: Integer); cdecl;
Procedure  pCvGeneralizedHoughBallardwrite(const wrapper: PCvGeneralizedHoughBallard_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuilclear(const wrapper: PCvGeneralizedHoughGuil_t); cdecl;
Procedure  pCvGeneralizedHoughGuildetect(const wrapper: PCvGeneralizedHoughGuil_t; image: PCvMat_t; 
                 positions: PCvMat_t; votes: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuildetectV2(const wrapper: PCvGeneralizedHoughGuil_t; image: PCvUMat_t; 
                 positions: PCvUMat_t; votes: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuildetectV3(const wrapper: PCvGeneralizedHoughGuil_t; edges: PCvMat_t; 
                 dx: PCvMat_t; dy: PCvMat_t; positions: PCvMat_t; 
                 votes: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuildetectV4(const wrapper: PCvGeneralizedHoughGuil_t; edges: PCvUMat_t; 
                 dx: PCvUMat_t; dy: PCvUMat_t; positions: PCvUMat_t; 
                 votes: PCvUMat_t { default: UMat() } = nil); cdecl;
Function   pCvGeneralizedHoughGuilempty(const wrapper: PCvGeneralizedHoughGuil_t): Boolean; cdecl;
Function   pCvGeneralizedHoughGuilgetAngleEpsilon(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetAngleStep(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetAngleThresh(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetCannyHighThresh(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetCannyLowThresh(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetDefaultName(const wrapper: PCvGeneralizedHoughGuil_t): PCvString_t; cdecl;
Function   pCvGeneralizedHoughGuilgetDp(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetLevels(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetMaxAngle(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetMaxBufferSize(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetMaxScale(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetMinAngle(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetMinDist(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetMinScale(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetPosThresh(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetScaleStep(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Function   pCvGeneralizedHoughGuilgetScaleThresh(const wrapper: PCvGeneralizedHoughGuil_t): Integer; cdecl;
Function   pCvGeneralizedHoughGuilgetXi(const wrapper: PCvGeneralizedHoughGuil_t): Double; cdecl;
Procedure  pCvGeneralizedHoughGuilread(const wrapper: PCvGeneralizedHoughGuil_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvGeneralizedHoughGuilsave(const wrapper: PCvGeneralizedHoughGuil_t; filename: PCvString_t); cdecl;
Procedure  pCvGeneralizedHoughGuilsetAngleEpsilon(const wrapper: PCvGeneralizedHoughGuil_t; angleEpsilon: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetAngleStep(const wrapper: PCvGeneralizedHoughGuil_t; angleStep: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetAngleThresh(const wrapper: PCvGeneralizedHoughGuil_t; angleThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetCannyHighThresh(const wrapper: PCvGeneralizedHoughGuil_t; cannyHighThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetCannyLowThresh(const wrapper: PCvGeneralizedHoughGuil_t; cannyLowThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetDp(const wrapper: PCvGeneralizedHoughGuil_t; dp: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetLevels(const wrapper: PCvGeneralizedHoughGuil_t; levels: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetMaxAngle(const wrapper: PCvGeneralizedHoughGuil_t; maxAngle: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetMaxBufferSize(const wrapper: PCvGeneralizedHoughGuil_t; maxBufferSize: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetMaxScale(const wrapper: PCvGeneralizedHoughGuil_t; maxScale: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetMinAngle(const wrapper: PCvGeneralizedHoughGuil_t; minAngle: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetMinDist(const wrapper: PCvGeneralizedHoughGuil_t; minDist: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetMinScale(const wrapper: PCvGeneralizedHoughGuil_t; minScale: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetPosThresh(const wrapper: PCvGeneralizedHoughGuil_t; posThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetScaleStep(const wrapper: PCvGeneralizedHoughGuil_t; scaleStep: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilsetScaleThresh(const wrapper: PCvGeneralizedHoughGuil_t; scaleThresh: Integer); cdecl;
Procedure  pCvGeneralizedHoughGuilsetTemplate(const wrapper: PCvGeneralizedHoughGuil_t; templ: PCvMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuilsetTemplateV2(const wrapper: PCvGeneralizedHoughGuil_t; templ: PCvUMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuilsetTemplateV3(const wrapper: PCvGeneralizedHoughGuil_t; edges: PCvMat_t; 
                 dx: PCvMat_t; dy: PCvMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuilsetTemplateV4(const wrapper: PCvGeneralizedHoughGuil_t; edges: PCvUMat_t; 
                 dx: PCvUMat_t; dy: PCvUMat_t; 
                 templCenter: PCvPoint_t { default: Point(-1, -1) } = nil); cdecl;
Procedure  pCvGeneralizedHoughGuilsetXi(const wrapper: PCvGeneralizedHoughGuil_t; xi: Double); cdecl;
Procedure  pCvGeneralizedHoughGuilwrite(const wrapper: PCvGeneralizedHoughGuil_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvHOGDescriptorcheckDetectorSize(const wrapper: PCvHOGDescriptor_t): Boolean; cdecl;
Procedure  pCvHOGDescriptorcompute(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; 
                 descriptors: PCvvector_float; winStride: PCvSize_t { default: Size() } = nil; 
                 padding: PCvSize_t { default: Size() } = nil; locations: PCvvector_Point { default: std::vector<Point>() } = nil); cdecl;
Procedure  pCvHOGDescriptorcomputeV2(const wrapper: PCvHOGDescriptor_t; img: PCvUMat_t; 
                 descriptors: PCvvector_float; winStride: PCvSize_t { default: Size() } = nil; 
                 padding: PCvSize_t { default: Size() } = nil; 
                 locations: PCvvector_Point { default: std::vector<Point>() } = nil); cdecl;
Procedure  pCvHOGDescriptorcomputeGradient(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; 
                 grad: PCvMat_t; angleOfs: PCvMat_t; 
                 paddingTL: PCvSize_t { default: Size() } = nil; paddingBR: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvHOGDescriptorcomputeGradientV2(const wrapper: PCvHOGDescriptor_t; img: PCvUMat_t; 
                 grad: PCvUMat_t; angleOfs: PCvUMat_t; 
                 paddingTL: PCvSize_t { default: Size() } = nil; paddingBR: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvHOGDescriptordetect(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; 
                 foundLocations: PCvvector_Point; weights: PCvvector_double; hitThreshold: Double { default: 0 } = 0; 
                 winStride: PCvSize_t { default: Size() } = nil; padding: PCvSize_t { default: Size() } = nil; 
                 searchLocations: PCvvector_Point { default: std::vector<Point>() } = nil); cdecl;
Procedure  pCvHOGDescriptordetectV2(const wrapper: PCvHOGDescriptor_t; img: PCvUMat_t; 
                 foundLocations: PCvvector_Point; weights: PCvvector_double; hitThreshold: Double { default: 0 } = 0; 
                 winStride: PCvSize_t { default: Size() } = nil; padding: PCvSize_t { default: Size() } = nil; 
                 searchLocations: PCvvector_Point { default: std::vector<Point>() } = nil); cdecl;
Procedure  pCvHOGDescriptordetectMultiScale(const wrapper: PCvHOGDescriptor_t; img: PCvMat_t; 
                 foundLocations: PCvvector_Rect; foundWeights: PCvvector_double; 
                 hitThreshold: Double { default: 0 } = 0; winStride: PCvSize_t { default: Size() } = nil; 
                 padding: PCvSize_t { default: Size() } = nil; scale: Double { default: 1.05 } = 1.05; 
                 groupThreshold: Double { default: 2.0 } = 2.0; useMeanshiftGrouping: Boolean { default: false } = false); cdecl;
Procedure  pCvHOGDescriptordetectMultiScaleV2(const wrapper: PCvHOGDescriptor_t; img: PCvUMat_t; 
                 foundLocations: PCvvector_Rect; foundWeights: PCvvector_double; 
                 hitThreshold: Double { default: 0 } = 0; winStride: PCvSize_t { default: Size() } = nil; 
                 padding: PCvSize_t { default: Size() } = nil; scale: Double { default: 1.05 } = 1.05; 
                 groupThreshold: Double { default: 2.0 } = 2.0; useMeanshiftGrouping: Boolean { default: false } = false); cdecl;
Function   pCvHOGDescriptorgetDaimlerPeopleDetector(): PCvvector_float; cdecl;
Function   pCvHOGDescriptorgetDefaultPeopleDetector(): PCvvector_float; cdecl;
Function   pCvHOGDescriptorgetDescriptorSize(const wrapper: PCvHOGDescriptor_t): UInt64; cdecl;
Function   pCvHOGDescriptorgetWinSigma(const wrapper: PCvHOGDescriptor_t): Double; cdecl;
Function   pCvHOGDescriptorload(const wrapper: PCvHOGDescriptor_t; filename: PCvString_t; 
                 objname: PCvString_t { default: String() } = nil): Boolean; cdecl;
Procedure  pCvHOGDescriptorsave(const wrapper: PCvHOGDescriptor_t; filename: PCvString_t; 
                 objname: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvHOGDescriptorsetSVMDetector(const wrapper: PCvHOGDescriptor_t; svmdetector: PCvMat_t); cdecl;
Procedure  pCvHOGDescriptorsetSVMDetectorV2(const wrapper: PCvHOGDescriptor_t; svmdetector: PCvUMat_t); cdecl;
Function   pCvHOGDescriptorGet_L2HysThreshold(const wrapper: PCvHOGDescriptor_t): Double; cdecl;
Function   pCvHOGDescriptorGet_blockSize(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Function   pCvHOGDescriptorGet_blockStride(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Function   pCvHOGDescriptorGet_cellSize(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Function   pCvHOGDescriptorGet_derivAperture(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_gammaCorrection(const wrapper: PCvHOGDescriptor_t): Boolean; cdecl;
Function   pCvHOGDescriptorGet_histogramNormType(const wrapper: PCvHOGDescriptor_t): TCvHOGDescriptor_HistogramNormType; cdecl;
Function   pCvHOGDescriptorGet_nbins(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_nlevels(const wrapper: PCvHOGDescriptor_t): Integer; cdecl;
Function   pCvHOGDescriptorGet_signedGradient(const wrapper: PCvHOGDescriptor_t): Boolean; cdecl;
Function   pCvHOGDescriptorGet_svmDetector(const wrapper: PCvHOGDescriptor_t): PCvvector_float; cdecl;
Function   pCvHOGDescriptorGet_winSigma(const wrapper: PCvHOGDescriptor_t): Double; cdecl;
Function   pCvHOGDescriptorGet_winSize(const wrapper: PCvHOGDescriptor_t): PCvSize_t; cdecl;
Procedure  pCvKAZEclear(const wrapper: PCvKAZE_t); cdecl;
Procedure  pCvKAZEcompute(const wrapper: PCvKAZE_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t); cdecl;
Procedure  pCvKAZEcomputeV2(const wrapper: PCvKAZE_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t); cdecl;
Procedure  pCvKAZEcomputeV3(const wrapper: PCvKAZE_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvKAZEcomputeV4(const wrapper: PCvKAZE_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvKAZE_create(extended: Boolean { default: false } = false; 
                 upright: Boolean { default: false } = false; threshold: Single { default: 0.001f } = 0.001; 
                 nOctaves: Integer { default: 4 } = 4; nOctaveLayers: Integer { default: 4 } = 4; 
                 diffusivity: TCvKAZE_DiffusivityType { default: KAZE::DIFF_PM_G2 } = TCvKAZE_DiffusivityType.DIFF_PM_G2): PCvPtr_KAZE; cdecl;
Function   pCvKAZEdefaultNorm(const wrapper: PCvKAZE_t): Integer; cdecl;
Function   pCvKAZEdescriptorSize(const wrapper: PCvKAZE_t): Integer; cdecl;
Function   pCvKAZEdescriptorType(const wrapper: PCvKAZE_t): Integer; cdecl;
Procedure  pCvKAZEdetect(const wrapper: PCvKAZE_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvKAZEdetectV2(const wrapper: PCvKAZE_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvKAZEdetectV3(const wrapper: PCvKAZE_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvKAZEdetectV4(const wrapper: PCvKAZE_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvKAZEdetectAndCompute(const wrapper: PCvKAZE_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvKAZEdetectAndComputeV2(const wrapper: PCvKAZE_t; image: PCvUMat_t; mask: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvKAZEempty(const wrapper: PCvKAZE_t): Boolean; cdecl;
Function   pCvKAZEgetDefaultName(const wrapper: PCvKAZE_t): PCvString_t; cdecl;
Function   pCvKAZEgetDiffusivity(const wrapper: PCvKAZE_t): TCvKAZE_DiffusivityType; cdecl;
Function   pCvKAZEgetExtended(const wrapper: PCvKAZE_t): Boolean; cdecl;
Function   pCvKAZEgetNOctaveLayers(const wrapper: PCvKAZE_t): Integer; cdecl;
Function   pCvKAZEgetNOctaves(const wrapper: PCvKAZE_t): Integer; cdecl;
Function   pCvKAZEgetThreshold(const wrapper: PCvKAZE_t): Double; cdecl;
Function   pCvKAZEgetUpright(const wrapper: PCvKAZE_t): Boolean; cdecl;
Procedure  pCvKAZEread(const wrapper: PCvKAZE_t; fileName: PCvString_t); cdecl;
Procedure  pCvKAZEreadV2(const wrapper: PCvKAZE_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvKAZEsave(const wrapper: PCvKAZE_t; filename: PCvString_t); cdecl;
Procedure  pCvKAZEsetDiffusivity(const wrapper: PCvKAZE_t; diff: TCvKAZE_DiffusivityType); cdecl;
Procedure  pCvKAZEsetExtended(const wrapper: PCvKAZE_t; extended: Boolean); cdecl;
Procedure  pCvKAZEsetNOctaveLayers(const wrapper: PCvKAZE_t; octaveLayers: Integer); cdecl;
Procedure  pCvKAZEsetNOctaves(const wrapper: PCvKAZE_t; octaves: Integer); cdecl;
Procedure  pCvKAZEsetThreshold(const wrapper: PCvKAZE_t; threshold: Double); cdecl;
Procedure  pCvKAZEsetUpright(const wrapper: PCvKAZE_t; upright: Boolean); cdecl;
Procedure  pCvKAZEwrite(const wrapper: PCvKAZE_t; fileName: PCvString_t); cdecl;
Procedure  pCvKAZEwriteV2(const wrapper: PCvKAZE_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvKalmanFiltercorrect(const wrapper: PCvKalmanFilter_t; measurement: PCvMat_t): PCvMat_t; cdecl;
Function   pCvKalmanFilterpredict(const wrapper: PCvKalmanFilter_t; control: PCvMat_t { default: Mat() } = nil): PCvMat_t; cdecl;
Function   pCvKalmanFilterGet_controlMatrix(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_controlMatrix(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_errorCovPost(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_errorCovPost(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_errorCovPre(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_errorCovPre(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_gain(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_gain(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_measurementMatrix(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_measurementMatrix(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_measurementNoiseCov(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_measurementNoiseCov(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_processNoiseCov(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_processNoiseCov(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_statePost(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_statePost(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_statePre(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_statePre(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Function   pCvKalmanFilterGet_transitionMatrix(const wrapper: PCvKalmanFilter_t): PCvMat_t; cdecl;
Procedure  pCvKalmanFilterSet_transitionMatrix(const wrapper: PCvKalmanFilter_t; propval: PCvMat_t); cdecl;
Procedure  pCvKeyPointconvert(keypoints: PCvvector_KeyPoint; points2f: PCvvector_Point2f; 
                 keypointIndexes: PCvvector_int { default: std::vector<int>() } = nil); cdecl;
Procedure  pCvKeyPointconvertV2(points2f: PCvvector_Point2f; keypoints: PCvvector_KeyPoint; 
                 size: Single { default: 1 } = 1; response: Single { default: 1 } = 1; 
                 octave: Integer { default: 0 } = 0; class_id: Integer { default: -1 } = ord(-1)); cdecl;
Function   pCvKeyPointoverlap(kp1: PCvKeyPoint_t; kp2: PCvKeyPoint_t): Single; cdecl;
Function   pCvKeyPointGet_angle(const wrapper: PCvKeyPoint_t): Single; cdecl;
Procedure  pCvKeyPointSet_angle(const wrapper: PCvKeyPoint_t; propval: Single); cdecl;
Function   pCvKeyPointGet_class_id(const wrapper: PCvKeyPoint_t): Integer; cdecl;
Procedure  pCvKeyPointSet_class_id(const wrapper: PCvKeyPoint_t; propval: Integer); cdecl;
Function   pCvKeyPointGet_octave(const wrapper: PCvKeyPoint_t): Integer; cdecl;
Procedure  pCvKeyPointSet_octave(const wrapper: PCvKeyPoint_t; propval: Integer); cdecl;
Function   pCvKeyPointGet_pt(const wrapper: PCvKeyPoint_t): PCvPoint2f_t; cdecl;
Procedure  pCvKeyPointSet_pt(const wrapper: PCvKeyPoint_t; propval: PCvPoint2f_t); cdecl;
Function   pCvKeyPointGet_response(const wrapper: PCvKeyPoint_t): Single; cdecl;
Procedure  pCvKeyPointSet_response(const wrapper: PCvKeyPoint_t; propval: Single); cdecl;
Function   pCvKeyPointGet_size(const wrapper: PCvKeyPoint_t): Single; cdecl;
Procedure  pCvKeyPointSet_size(const wrapper: PCvKeyPoint_t; propval: Single); cdecl;
Procedure  pCvLineSegmentDetectorclear(const wrapper: PCvLineSegmentDetector_t); cdecl;
Function   pCvLineSegmentDetectorcompareSegments(const wrapper: PCvLineSegmentDetector_t; size: PCvSize_t; 
                 lines1: PCvMat_t; lines2: PCvMat_t; 
                 image: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvLineSegmentDetectorcompareSegmentsV2(const wrapper: PCvLineSegmentDetector_t; size: PCvSize_t; 
                 lines1: PCvUMat_t; lines2: PCvUMat_t; 
                 image: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Procedure  pCvLineSegmentDetectordetect(const wrapper: PCvLineSegmentDetector_t; image: PCvMat_t; 
                 lines: PCvMat_t; width: PCvMat_t { default: Mat() } = nil; 
                 prec: PCvMat_t { default: Mat() } = nil; nfa: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvLineSegmentDetectordetectV2(const wrapper: PCvLineSegmentDetector_t; image: PCvUMat_t; 
                 lines: PCvUMat_t; width: PCvUMat_t { default: UMat() } = nil; 
                 prec: PCvUMat_t { default: UMat() } = nil; nfa: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvLineSegmentDetectordrawSegments(const wrapper: PCvLineSegmentDetector_t; image: PCvMat_t; 
                 lines: PCvMat_t); cdecl;
Procedure  pCvLineSegmentDetectordrawSegmentsV2(const wrapper: PCvLineSegmentDetector_t; image: PCvUMat_t; 
                 lines: PCvUMat_t); cdecl;
Function   pCvLineSegmentDetectorempty(const wrapper: PCvLineSegmentDetector_t): Boolean; cdecl;
Function   pCvLineSegmentDetectorgetDefaultName(const wrapper: PCvLineSegmentDetector_t): PCvString_t; cdecl;
Procedure  pCvLineSegmentDetectorread(const wrapper: PCvLineSegmentDetector_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvLineSegmentDetectorsave(const wrapper: PCvLineSegmentDetector_t; filename: PCvString_t); cdecl;
Procedure  pCvLineSegmentDetectorwrite(const wrapper: PCvLineSegmentDetector_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvMSERclear(const wrapper: PCvMSER_t); cdecl;
Procedure  pCvMSERcompute(const wrapper: PCvMSER_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t); cdecl;
Procedure  pCvMSERcomputeV2(const wrapper: PCvMSER_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t); cdecl;
Procedure  pCvMSERcomputeV3(const wrapper: PCvMSER_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvMSERcomputeV4(const wrapper: PCvMSER_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvMSER_create(delta: Integer { default: 5 } = 5; min_area: Integer { default: 60 } = 60; 
                 max_area: Integer { default: 14400 } = 14400; max_variation: Double { default: 0.25 } = 0.25; 
                 min_diversity: Double { default: .2 } = 0.2; max_evolution: Integer { default: 200 } = 200; 
                 area_threshold: Double { default: 1.01 } = 1.01; min_margin: Double { default: 0.003 } = 0.003; 
                 edge_blur_size: Integer { default: 5 } = 5): PCvPtr_MSER; cdecl;
Function   pCvMSERdefaultNorm(const wrapper: PCvMSER_t): Integer; cdecl;
Function   pCvMSERdescriptorSize(const wrapper: PCvMSER_t): Integer; cdecl;
Function   pCvMSERdescriptorType(const wrapper: PCvMSER_t): Integer; cdecl;
Procedure  pCvMSERdetect(const wrapper: PCvMSER_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvMSERdetectV2(const wrapper: PCvMSER_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvMSERdetectV3(const wrapper: PCvMSER_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvMSERdetectV4(const wrapper: PCvMSER_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvMSERdetectAndCompute(const wrapper: PCvMSER_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvMSERdetectAndComputeV2(const wrapper: PCvMSER_t; image: PCvUMat_t; mask: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvMSERdetectRegions(const wrapper: PCvMSER_t; image: PCvMat_t; msers: PCvvector_vector_Point; 
                 bboxes: PCvvector_Rect); cdecl;
Procedure  pCvMSERdetectRegionsV2(const wrapper: PCvMSER_t; image: PCvUMat_t; 
                 msers: PCvvector_vector_Point; bboxes: PCvvector_Rect); cdecl;
Function   pCvMSERempty(const wrapper: PCvMSER_t): Boolean; cdecl;
Function   pCvMSERgetDefaultName(const wrapper: PCvMSER_t): PCvString_t; cdecl;
Function   pCvMSERgetDelta(const wrapper: PCvMSER_t): Integer; cdecl;
Function   pCvMSERgetMaxArea(const wrapper: PCvMSER_t): Integer; cdecl;
Function   pCvMSERgetMinArea(const wrapper: PCvMSER_t): Integer; cdecl;
Function   pCvMSERgetPass2Only(const wrapper: PCvMSER_t): Boolean; cdecl;
Procedure  pCvMSERread(const wrapper: PCvMSER_t; fileName: PCvString_t); cdecl;
Procedure  pCvMSERreadV2(const wrapper: PCvMSER_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvMSERsave(const wrapper: PCvMSER_t; filename: PCvString_t); cdecl;
Procedure  pCvMSERsetDelta(const wrapper: PCvMSER_t; delta: Integer); cdecl;
Procedure  pCvMSERsetMaxArea(const wrapper: PCvMSER_t; maxArea: Integer); cdecl;
Procedure  pCvMSERsetMinArea(const wrapper: PCvMSER_t; minArea: Integer); cdecl;
Procedure  pCvMSERsetPass2Only(const wrapper: PCvMSER_t; f: Boolean); cdecl;
Procedure  pCvMSERwrite(const wrapper: PCvMSER_t; fileName: PCvString_t); cdecl;
Procedure  pCvMSERwriteV2(const wrapper: PCvMSER_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvMergeDebevecclear(const wrapper: PCvMergeDebevec_t); cdecl;
Function   pCvMergeDebevecempty(const wrapper: PCvMergeDebevec_t): Boolean; cdecl;
Function   pCvMergeDebevecgetDefaultName(const wrapper: PCvMergeDebevec_t): PCvString_t; cdecl;
Procedure  pCvMergeDebevecprocess(const wrapper: PCvMergeDebevec_t; src: PCvvector_Mat; dst: PCvMat_t; 
                 times: PCvMat_t; response: PCvMat_t); cdecl;
Procedure  pCvMergeDebevecprocessV2(const wrapper: PCvMergeDebevec_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t; response: PCvUMat_t); cdecl;
Procedure  pCvMergeDebevecprocessV3(const wrapper: PCvMergeDebevec_t; src: PCvvector_Mat; dst: PCvMat_t; 
                 times: PCvMat_t); cdecl;
Procedure  pCvMergeDebevecprocessV4(const wrapper: PCvMergeDebevec_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t); cdecl;
Procedure  pCvMergeDebevecread(const wrapper: PCvMergeDebevec_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvMergeDebevecsave(const wrapper: PCvMergeDebevec_t; filename: PCvString_t); cdecl;
Procedure  pCvMergeDebevecwrite(const wrapper: PCvMergeDebevec_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvMergeExposuresclear(const wrapper: PCvMergeExposures_t); cdecl;
Function   pCvMergeExposuresempty(const wrapper: PCvMergeExposures_t): Boolean; cdecl;
Function   pCvMergeExposuresgetDefaultName(const wrapper: PCvMergeExposures_t): PCvString_t; cdecl;
Procedure  pCvMergeExposuresprocess(const wrapper: PCvMergeExposures_t; src: PCvvector_Mat; 
                 dst: PCvMat_t; times: PCvMat_t; response: PCvMat_t); cdecl;
Procedure  pCvMergeExposuresprocessV2(const wrapper: PCvMergeExposures_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t; response: PCvUMat_t); cdecl;
Procedure  pCvMergeExposuresread(const wrapper: PCvMergeExposures_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvMergeExposuressave(const wrapper: PCvMergeExposures_t; filename: PCvString_t); cdecl;
Procedure  pCvMergeExposureswrite(const wrapper: PCvMergeExposures_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvMergeMertensclear(const wrapper: PCvMergeMertens_t); cdecl;
Function   pCvMergeMertensempty(const wrapper: PCvMergeMertens_t): Boolean; cdecl;
Function   pCvMergeMertensgetContrastWeight(const wrapper: PCvMergeMertens_t): Single; cdecl;
Function   pCvMergeMertensgetDefaultName(const wrapper: PCvMergeMertens_t): PCvString_t; cdecl;
Function   pCvMergeMertensgetExposureWeight(const wrapper: PCvMergeMertens_t): Single; cdecl;
Function   pCvMergeMertensgetSaturationWeight(const wrapper: PCvMergeMertens_t): Single; cdecl;
Procedure  pCvMergeMertensprocess(const wrapper: PCvMergeMertens_t; src: PCvvector_Mat; dst: PCvMat_t; 
                 times: PCvMat_t; response: PCvMat_t); cdecl;
Procedure  pCvMergeMertensprocessV2(const wrapper: PCvMergeMertens_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t; response: PCvUMat_t); cdecl;
Procedure  pCvMergeMertensprocessV3(const wrapper: PCvMergeMertens_t; src: PCvvector_Mat; dst: PCvMat_t); cdecl;
Procedure  pCvMergeMertensprocessV4(const wrapper: PCvMergeMertens_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t); cdecl;
Procedure  pCvMergeMertensread(const wrapper: PCvMergeMertens_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvMergeMertenssave(const wrapper: PCvMergeMertens_t; filename: PCvString_t); cdecl;
Procedure  pCvMergeMertenssetContrastWeight(const wrapper: PCvMergeMertens_t; contrast_weiht: Single); cdecl;
Procedure  pCvMergeMertenssetExposureWeight(const wrapper: PCvMergeMertens_t; exposure_weight: Single); cdecl;
Procedure  pCvMergeMertenssetSaturationWeight(const wrapper: PCvMergeMertens_t; saturation_weight: Single); cdecl;
Procedure  pCvMergeMertenswrite(const wrapper: PCvMergeMertens_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvMergeRobertsonclear(const wrapper: PCvMergeRobertson_t); cdecl;
Function   pCvMergeRobertsonempty(const wrapper: PCvMergeRobertson_t): Boolean; cdecl;
Function   pCvMergeRobertsongetDefaultName(const wrapper: PCvMergeRobertson_t): PCvString_t; cdecl;
Procedure  pCvMergeRobertsonprocess(const wrapper: PCvMergeRobertson_t; src: PCvvector_Mat; 
                 dst: PCvMat_t; times: PCvMat_t; response: PCvMat_t); cdecl;
Procedure  pCvMergeRobertsonprocessV2(const wrapper: PCvMergeRobertson_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t; response: PCvUMat_t); cdecl;
Procedure  pCvMergeRobertsonprocessV3(const wrapper: PCvMergeRobertson_t; src: PCvvector_Mat; 
                 dst: PCvMat_t; times: PCvMat_t); cdecl;
Procedure  pCvMergeRobertsonprocessV4(const wrapper: PCvMergeRobertson_t; src: PCvvector_UMat; 
                 dst: PCvUMat_t; times: PCvUMat_t); cdecl;
Procedure  pCvMergeRobertsonread(const wrapper: PCvMergeRobertson_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvMergeRobertsonsave(const wrapper: PCvMergeRobertson_t; filename: PCvString_t); cdecl;
Procedure  pCvMergeRobertsonwrite(const wrapper: PCvMergeRobertson_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvMomentsGet_m00(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m00(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m01(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m01(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m02(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m02(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m03(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m03(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m10(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m10(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m11(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m11(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m12(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m12(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m20(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m20(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m21(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m21(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_m30(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_m30(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu02(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu02(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu03(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu03(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu11(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu11(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu12(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu12(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu20(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu20(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu21(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu21(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_mu30(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_mu30(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu02(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu02(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu03(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu03(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu11(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu11(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu12(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu12(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu20(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu20(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu21(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu21(const wrapper: PCvMoments_t; propval: Double); cdecl;
Function   pCvMomentsGet_nu30(const wrapper: PCvMoments_t): Double; cdecl;
Procedure  pCvMomentsSet_nu30(const wrapper: PCvMoments_t; propval: Double); cdecl;
Procedure  pCvORBclear(const wrapper: PCvORB_t); cdecl;
Procedure  pCvORBcompute(const wrapper: PCvORB_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t); cdecl;
Procedure  pCvORBcomputeV2(const wrapper: PCvORB_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t); cdecl;
Procedure  pCvORBcomputeV3(const wrapper: PCvORB_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvORBcomputeV4(const wrapper: PCvORB_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvORB_create(nfeatures: Integer { default: 500 } = 500; 
                 scaleFactor: Single { default: 1.2f } = 1.2; nlevels: Integer { default: 8 } = 8; 
                 edgeThreshold: Integer { default: 31 } = 31; firstLevel: Integer { default: 0 } = 0; WTA_K: Integer { default: 2 } = 2; 
                 scoreType: TCvORB_ScoreType { default: ORB::HARRIS_SCORE } = TCvORB_ScoreType.HARRIS_SCORE; patchSize: Integer { default: 31 } = 31; 
                 fastThreshold: Integer { default: 20 } = 20): PCvPtr_ORB; cdecl;
Function   pCvORBdefaultNorm(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBdescriptorSize(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBdescriptorType(const wrapper: PCvORB_t): Integer; cdecl;
Procedure  pCvORBdetect(const wrapper: PCvORB_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvORBdetectV2(const wrapper: PCvORB_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvORBdetectV3(const wrapper: PCvORB_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvORBdetectV4(const wrapper: PCvORB_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvORBdetectAndCompute(const wrapper: PCvORB_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvORBdetectAndComputeV2(const wrapper: PCvORB_t; image: PCvUMat_t; mask: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvORBempty(const wrapper: PCvORB_t): Boolean; cdecl;
Function   pCvORBgetDefaultName(const wrapper: PCvORB_t): PCvString_t; cdecl;
Function   pCvORBgetEdgeThreshold(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBgetFastThreshold(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBgetFirstLevel(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBgetMaxFeatures(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBgetNLevels(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBgetPatchSize(const wrapper: PCvORB_t): Integer; cdecl;
Function   pCvORBgetScaleFactor(const wrapper: PCvORB_t): Double; cdecl;
Function   pCvORBgetScoreType(const wrapper: PCvORB_t): TCvORB_ScoreType; cdecl;
Function   pCvORBgetWTA_K(const wrapper: PCvORB_t): Integer; cdecl;
Procedure  pCvORBread(const wrapper: PCvORB_t; fileName: PCvString_t); cdecl;
Procedure  pCvORBreadV2(const wrapper: PCvORB_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvORBsave(const wrapper: PCvORB_t; filename: PCvString_t); cdecl;
Procedure  pCvORBsetEdgeThreshold(const wrapper: PCvORB_t; edgeThreshold: Integer); cdecl;
Procedure  pCvORBsetFastThreshold(const wrapper: PCvORB_t; fastThreshold: Integer); cdecl;
Procedure  pCvORBsetFirstLevel(const wrapper: PCvORB_t; firstLevel: Integer); cdecl;
Procedure  pCvORBsetMaxFeatures(const wrapper: PCvORB_t; maxFeatures: Integer); cdecl;
Procedure  pCvORBsetNLevels(const wrapper: PCvORB_t; nlevels: Integer); cdecl;
Procedure  pCvORBsetPatchSize(const wrapper: PCvORB_t; patchSize: Integer); cdecl;
Procedure  pCvORBsetScaleFactor(const wrapper: PCvORB_t; scaleFactor: Double); cdecl;
Procedure  pCvORBsetScoreType(const wrapper: PCvORB_t; scoreType: TCvORB_ScoreType); cdecl;
Procedure  pCvORBsetWTA_K(const wrapper: PCvORB_t; wta_k: Integer); cdecl;
Procedure  pCvORBwrite(const wrapper: PCvORB_t; fileName: PCvString_t); cdecl;
Procedure  pCvORBwriteV2(const wrapper: PCvORB_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvPyRotationWarperbuildMaps(const wrapper: PCvPyRotationWarper_t; src_size: PCvSize_t; 
                 K: PCvMat_t; R: PCvMat_t; xmap: PCvMat_t; ymap: PCvMat_t): PCvRect_t; cdecl;
Function   pCvPyRotationWarperbuildMapsV2(const wrapper: PCvPyRotationWarper_t; src_size: PCvSize_t; 
                 K: PCvUMat_t; R: PCvUMat_t; xmap: PCvUMat_t; ymap: PCvUMat_t): PCvRect_t; cdecl;
Function   pCvPyRotationWarpergetScale(const wrapper: PCvPyRotationWarper_t): Single; cdecl;
Procedure  pCvPyRotationWarpersetScale(const wrapper: PCvPyRotationWarper_t; arg1: Single); cdecl;
Function   pCvPyRotationWarperwarp(const wrapper: PCvPyRotationWarper_t; src: PCvMat_t; K: PCvMat_t; 
                 R: PCvMat_t; interp_mode: Integer; border_mode: Integer; dst: PCvMat_t): PCvPoint_t; cdecl;
Function   pCvPyRotationWarperwarpV2(const wrapper: PCvPyRotationWarper_t; src: PCvUMat_t; K: PCvUMat_t; 
                 R: PCvUMat_t; interp_mode: Integer; border_mode: Integer; dst: PCvUMat_t): PCvPoint_t; cdecl;
Procedure  pCvPyRotationWarperwarpBackward(const wrapper: PCvPyRotationWarper_t; src: PCvMat_t; 
                 K: PCvMat_t; R: PCvMat_t; interp_mode: Integer; border_mode: Integer; 
                 dst_size: PCvSize_t; dst: PCvMat_t); cdecl;
Procedure  pCvPyRotationWarperwarpBackwardV2(const wrapper: PCvPyRotationWarper_t; src: PCvUMat_t; 
                 K: PCvUMat_t; R: PCvUMat_t; interp_mode: Integer; border_mode: Integer; 
                 dst_size: PCvSize_t; dst: PCvUMat_t); cdecl;
Function   pCvPyRotationWarperwarpPoint(const wrapper: PCvPyRotationWarper_t; pt: PCvPoint2f_t; 
                 K: PCvMat_t; R: PCvMat_t): PCvPoint2f_t; cdecl;
Function   pCvPyRotationWarperwarpPointV2(const wrapper: PCvPyRotationWarper_t; pt: PCvPoint2f_t; 
                 K: PCvUMat_t; R: PCvUMat_t): PCvPoint2f_t; cdecl;
Function   pCvPyRotationWarperwarpPointBackward(const wrapper: PCvPyRotationWarper_t; pt: PCvPoint2f_t; 
                 K: PCvMat_t; R: PCvMat_t): PCvPoint2f_t; cdecl;
Function   pCvPyRotationWarperwarpPointBackwardV2(const wrapper: PCvPyRotationWarper_t; pt: PCvPoint2f_t; 
                 K: PCvUMat_t; R: PCvUMat_t): PCvPoint2f_t; cdecl;
Function   pCvPyRotationWarperwarpPointBackwardV3(const wrapper: PCvPyRotationWarper_t; pt: PCvPoint2f_t; 
                 K: PCvMat_t; R: PCvMat_t): PCvPoint2f_t; cdecl;
Function   pCvPyRotationWarperwarpPointBackwardV4(const wrapper: PCvPyRotationWarper_t; pt: PCvPoint2f_t; 
                 K: PCvUMat_t; R: PCvUMat_t): PCvPoint2f_t; cdecl;
Function   pCvPyRotationWarperwarpRoi(const wrapper: PCvPyRotationWarper_t; src_size: PCvSize_t; 
                 K: PCvMat_t; R: PCvMat_t): PCvRect_t; cdecl;
Function   pCvPyRotationWarperwarpRoiV2(const wrapper: PCvPyRotationWarper_t; src_size: PCvSize_t; 
                 K: PCvUMat_t; R: PCvUMat_t): PCvRect_t; cdecl;
Function   pCvQRCodeDetectordecode(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; points: PCvMat_t; 
                 straight_qrcode: PCvMat_t { default: Mat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordecodeV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t; straight_qrcode: PCvUMat_t { default: UMat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordecodeCurved(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; 
                 points: PCvMat_t; straight_qrcode: PCvMat_t { default: Mat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordecodeCurvedV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t; straight_qrcode: PCvUMat_t { default: UMat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordecodeMulti(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; 
                 points: PCvMat_t; decoded_info: PCvvector_string; 
                 straight_qrcode: PCvvector_Mat { default: vector_Mat() } = nil): Boolean; cdecl;
Function   pCvQRCodeDetectordecodeMultiV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t; decoded_info: PCvvector_string; 
                 straight_qrcode: PCvvector_UMat { default: vector_UMat() } = nil): Boolean; cdecl;
Function   pCvQRCodeDetectordetect(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; points: PCvMat_t): Boolean; cdecl;
Function   pCvQRCodeDetectordetectV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t): Boolean; cdecl;
Function   pCvQRCodeDetectordetectAndDecode(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; 
                 points: PCvMat_t { default: Mat() } = nil; straight_qrcode: PCvMat_t { default: Mat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordetectAndDecodeV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t { default: UMat() } = nil; straight_qrcode: PCvUMat_t { default: UMat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordetectAndDecodeCurved(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; 
                 points: PCvMat_t { default: Mat() } = nil; straight_qrcode: PCvMat_t { default: Mat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordetectAndDecodeCurvedV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t { default: UMat() } = nil; 
                 straight_qrcode: PCvUMat_t { default: UMat() } = nil): PCvString_t; cdecl;
Function   pCvQRCodeDetectordetectAndDecodeMulti(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; 
                 decoded_info: PCvvector_string; points: PCvMat_t { default: Mat() } = nil; 
                 straight_qrcode: PCvvector_Mat { default: vector_Mat() } = nil): Boolean; cdecl;
Function   pCvQRCodeDetectordetectAndDecodeMultiV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 decoded_info: PCvvector_string; points: PCvUMat_t { default: UMat() } = nil; 
                 straight_qrcode: PCvvector_UMat { default: vector_UMat() } = nil): Boolean; cdecl;
Function   pCvQRCodeDetectordetectMulti(const wrapper: PCvQRCodeDetector_t; img: PCvMat_t; 
                 points: PCvMat_t): Boolean; cdecl;
Function   pCvQRCodeDetectordetectMultiV2(const wrapper: PCvQRCodeDetector_t; img: PCvUMat_t; 
                 points: PCvUMat_t): Boolean; cdecl;
Procedure  pCvQRCodeDetectorsetEpsX(const wrapper: PCvQRCodeDetector_t; epsX: Double); cdecl;
Procedure  pCvQRCodeDetectorsetEpsY(const wrapper: PCvQRCodeDetector_t; epsY: Double); cdecl;
Function   pCvQRCodeEncoder_create(
                 parameters: PCvQRCodeEncoder_Params_t { default: QRCodeEncoder::Params() } = nil): PCvPtr_QRCodeEncoder; cdecl;
Procedure  pCvQRCodeEncoderencode(const wrapper: PCvQRCodeEncoder_t; encoded_info: PCvString_t; 
                 qrcode: PCvMat_t); cdecl;
Procedure  pCvQRCodeEncoderencodeV2(const wrapper: PCvQRCodeEncoder_t; encoded_info: PCvString_t; 
                 qrcode: PCvUMat_t); cdecl;
Procedure  pCvQRCodeEncoderencodeStructuredAppend(const wrapper: PCvQRCodeEncoder_t; encoded_info: PCvString_t; 
                 qrcodes: PCvvector_Mat); cdecl;
Procedure  pCvQRCodeEncoderencodeStructuredAppendV2(const wrapper: PCvQRCodeEncoder_t; encoded_info: PCvString_t; 
                 qrcodes: PCvvector_UMat); cdecl;
Function   pCvQRCodeEncoder_ParamsGet_correction_level(const wrapper: PCvQRCodeEncoder_Params_t): TCvQRCodeEncoder_CorrectionLevel; cdecl;
Procedure  pCvQRCodeEncoder_ParamsSet_correction_level(const wrapper: PCvQRCodeEncoder_Params_t; propval: TCvQRCodeEncoder_CorrectionLevel); cdecl;
Function   pCvQRCodeEncoder_ParamsGet_mode(const wrapper: PCvQRCodeEncoder_Params_t): TCvQRCodeEncoder_EncodeMode; cdecl;
Procedure  pCvQRCodeEncoder_ParamsSet_mode(const wrapper: PCvQRCodeEncoder_Params_t; propval: TCvQRCodeEncoder_EncodeMode); cdecl;
Function   pCvQRCodeEncoder_ParamsGet_structure_number(const wrapper: PCvQRCodeEncoder_Params_t): Integer; cdecl;
Procedure  pCvQRCodeEncoder_ParamsSet_structure_number(const wrapper: PCvQRCodeEncoder_Params_t; propval: Integer); cdecl;
Function   pCvQRCodeEncoder_ParamsGet_version(const wrapper: PCvQRCodeEncoder_Params_t): Integer; cdecl;
Procedure  pCvQRCodeEncoder_ParamsSet_version(const wrapper: PCvQRCodeEncoder_Params_t; propval: Integer); cdecl;
Procedure  pCvSIFTclear(const wrapper: PCvSIFT_t); cdecl;
Procedure  pCvSIFTcompute(const wrapper: PCvSIFT_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvMat_t); cdecl;
Procedure  pCvSIFTcomputeV2(const wrapper: PCvSIFT_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t); cdecl;
Procedure  pCvSIFTcomputeV3(const wrapper: PCvSIFT_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvSIFTcomputeV4(const wrapper: PCvSIFT_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvSIFT_create(nfeatures: Integer { default: 0 } = 0; 
                 nOctaveLayers: Integer { default: 3 } = 3; contrastThreshold: Double { default: 0.04 } = 0.04; 
                 edgeThreshold: Double { default: 10 } = 10; sigma: Double { default: 1.6 } = 1.6): PCvPtr_SIFT; cdecl;
Function   pCvSIFT_createV2(nfeatures: Integer; nOctaveLayers: Integer; contrastThreshold: Double; 
                 edgeThreshold: Double; sigma: Double; descriptorType: Integer): PCvPtr_SIFT; cdecl;
Function   pCvSIFTdefaultNorm(const wrapper: PCvSIFT_t): Integer; cdecl;
Function   pCvSIFTdescriptorSize(const wrapper: PCvSIFT_t): Integer; cdecl;
Function   pCvSIFTdescriptorType(const wrapper: PCvSIFT_t): Integer; cdecl;
Procedure  pCvSIFTdetect(const wrapper: PCvSIFT_t; image: PCvMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvSIFTdetectV2(const wrapper: PCvSIFT_t; image: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvSIFTdetectV3(const wrapper: PCvSIFT_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvSIFTdetectV4(const wrapper: PCvSIFT_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvSIFTdetectAndCompute(const wrapper: PCvSIFT_t; image: PCvMat_t; mask: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvSIFTdetectAndComputeV2(const wrapper: PCvSIFT_t; image: PCvUMat_t; mask: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvSIFTempty(const wrapper: PCvSIFT_t): Boolean; cdecl;
Function   pCvSIFTgetDefaultName(const wrapper: PCvSIFT_t): PCvString_t; cdecl;
Procedure  pCvSIFTread(const wrapper: PCvSIFT_t; fileName: PCvString_t); cdecl;
Procedure  pCvSIFTreadV2(const wrapper: PCvSIFT_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvSIFTsave(const wrapper: PCvSIFT_t; filename: PCvString_t); cdecl;
Procedure  pCvSIFTwrite(const wrapper: PCvSIFT_t; fileName: PCvString_t); cdecl;
Procedure  pCvSIFTwriteV2(const wrapper: PCvSIFT_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvSimpleBlobDetectorclear(const wrapper: PCvSimpleBlobDetector_t); cdecl;
Procedure  pCvSimpleBlobDetectorcompute(const wrapper: PCvSimpleBlobDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t); cdecl;
Procedure  pCvSimpleBlobDetectorcomputeV2(const wrapper: PCvSimpleBlobDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; descriptors: PCvUMat_t); cdecl;
Procedure  pCvSimpleBlobDetectorcomputeV3(const wrapper: PCvSimpleBlobDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_Mat); cdecl;
Procedure  pCvSimpleBlobDetectorcomputeV4(const wrapper: PCvSimpleBlobDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; descriptors: PCvvector_UMat); cdecl;
Function   pCvSimpleBlobDetector_create(
                 parameters: PCvSimpleBlobDetector_Params_t { default: SimpleBlobDetector::Params() } = nil): PCvPtr_SimpleBlobDetector; cdecl;
Function   pCvSimpleBlobDetectordefaultNorm(const wrapper: PCvSimpleBlobDetector_t): Integer; cdecl;
Function   pCvSimpleBlobDetectordescriptorSize(const wrapper: PCvSimpleBlobDetector_t): Integer; cdecl;
Function   pCvSimpleBlobDetectordescriptorType(const wrapper: PCvSimpleBlobDetector_t): Integer; cdecl;
Procedure  pCvSimpleBlobDetectordetect(const wrapper: PCvSimpleBlobDetector_t; image: PCvMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvSimpleBlobDetectordetectV2(const wrapper: PCvSimpleBlobDetector_t; image: PCvUMat_t; 
                 keypoints: PCvvector_KeyPoint; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvSimpleBlobDetectordetectV3(const wrapper: PCvSimpleBlobDetector_t; images: PCvvector_Mat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvSimpleBlobDetectordetectV4(const wrapper: PCvSimpleBlobDetector_t; images: PCvvector_UMat; 
                 keypoints: PCvvector_vector_KeyPoint; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvSimpleBlobDetectordetectAndCompute(const wrapper: PCvSimpleBlobDetector_t; image: PCvMat_t; 
                 mask: PCvMat_t; keypoints: PCvvector_KeyPoint; descriptors: PCvMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Procedure  pCvSimpleBlobDetectordetectAndComputeV2(const wrapper: PCvSimpleBlobDetector_t; image: PCvUMat_t; 
                 mask: PCvUMat_t; keypoints: PCvvector_KeyPoint; 
                 descriptors: PCvUMat_t; 
                 useProvidedKeypoints: Boolean { default: false } = false); cdecl;
Function   pCvSimpleBlobDetectorempty(const wrapper: PCvSimpleBlobDetector_t): Boolean; cdecl;
Function   pCvSimpleBlobDetectorgetDefaultName(const wrapper: PCvSimpleBlobDetector_t): PCvString_t; cdecl;
Procedure  pCvSimpleBlobDetectorread(const wrapper: PCvSimpleBlobDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvSimpleBlobDetectorreadV2(const wrapper: PCvSimpleBlobDetector_t; arg1: PCvFileNode_t); cdecl;
Procedure  pCvSimpleBlobDetectorsave(const wrapper: PCvSimpleBlobDetector_t; filename: PCvString_t); cdecl;
Procedure  pCvSimpleBlobDetectorwrite(const wrapper: PCvSimpleBlobDetector_t; fileName: PCvString_t); cdecl;
Procedure  pCvSimpleBlobDetectorwriteV2(const wrapper: PCvSimpleBlobDetector_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_blobColor(const wrapper: PCvSimpleBlobDetector_Params_t): Byte; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_blobColor(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Byte); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByArea(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByArea(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByCircularity(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByCircularity(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByColor(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByColor(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByConvexity(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByConvexity(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_filterByInertia(const wrapper: PCvSimpleBlobDetector_Params_t): Boolean; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_filterByInertia(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Boolean); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxArea(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxArea(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxCircularity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxCircularity(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxConvexity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxConvexity(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_maxThreshold(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_maxThreshold(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minArea(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minArea(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minCircularity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minCircularity(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minConvexity(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minConvexity(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minDistBetweenBlobs(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minDistBetweenBlobs(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minInertiaRatio(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minRepeatability(const wrapper: PCvSimpleBlobDetector_Params_t): UInt64; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minRepeatability(const wrapper: PCvSimpleBlobDetector_Params_t; propval: UInt64); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_minThreshold(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_minThreshold(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Function   pCvSimpleBlobDetector_ParamsGet_thresholdStep(const wrapper: PCvSimpleBlobDetector_Params_t): Single; cdecl;
Procedure  pCvSimpleBlobDetector_ParamsSet_thresholdStep(const wrapper: PCvSimpleBlobDetector_Params_t; propval: Single); cdecl;
Procedure  pCvSparseOpticalFlowcalc(const wrapper: PCvSparseOpticalFlow_t; prevImg: PCvMat_t; 
                 nextImg: PCvMat_t; prevPts: PCvMat_t; nextPts: PCvMat_t; status: PCvMat_t; 
                 err: PCvMat_t { default: cv::Mat() } = nil); cdecl;
Procedure  pCvSparseOpticalFlowcalcV2(const wrapper: PCvSparseOpticalFlow_t; prevImg: PCvUMat_t; 
                 nextImg: PCvUMat_t; prevPts: PCvUMat_t; nextPts: PCvUMat_t; status: PCvUMat_t; 
                 err: PCvUMat_t { default: cv::UMat() } = nil); cdecl;
Procedure  pCvSparseOpticalFlowclear(const wrapper: PCvSparseOpticalFlow_t); cdecl;
Function   pCvSparseOpticalFlowempty(const wrapper: PCvSparseOpticalFlow_t): Boolean; cdecl;
Function   pCvSparseOpticalFlowgetDefaultName(const wrapper: PCvSparseOpticalFlow_t): PCvString_t; cdecl;
Procedure  pCvSparseOpticalFlowread(const wrapper: PCvSparseOpticalFlow_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvSparseOpticalFlowsave(const wrapper: PCvSparseOpticalFlow_t; filename: PCvString_t); cdecl;
Procedure  pCvSparseOpticalFlowwrite(const wrapper: PCvSparseOpticalFlow_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowcalc(const wrapper: PCvSparsePyrLKOpticalFlow_t; prevImg: PCvMat_t; 
                 nextImg: PCvMat_t; prevPts: PCvMat_t; nextPts: PCvMat_t; status: PCvMat_t; 
                 err: PCvMat_t { default: cv::Mat() } = nil); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowcalcV2(const wrapper: PCvSparsePyrLKOpticalFlow_t; prevImg: PCvUMat_t; 
                 nextImg: PCvUMat_t; prevPts: PCvUMat_t; nextPts: PCvUMat_t; status: PCvUMat_t; 
                 err: PCvUMat_t { default: cv::UMat() } = nil); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowclear(const wrapper: PCvSparsePyrLKOpticalFlow_t); cdecl;
Function   pCvSparsePyrLKOpticalFlow_create(winSize: PCvSize_t { default: Size(21, 21) } = nil; 
                 maxLevel: Integer { default: 3 } = 3; 
                 crit: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01) } = nil; flags: Integer { default: 0 } = 0; 
                 minEigThreshold: Double { default: 1e-4 } = 1e-4): PCvPtr_SparsePyrLKOpticalFlow; cdecl;
Function   pCvSparsePyrLKOpticalFlowempty(const wrapper: PCvSparsePyrLKOpticalFlow_t): Boolean; cdecl;
Function   pCvSparsePyrLKOpticalFlowgetDefaultName(const wrapper: PCvSparsePyrLKOpticalFlow_t): PCvString_t; cdecl;
Function   pCvSparsePyrLKOpticalFlowgetFlags(const wrapper: PCvSparsePyrLKOpticalFlow_t): Integer; cdecl;
Function   pCvSparsePyrLKOpticalFlowgetMaxLevel(const wrapper: PCvSparsePyrLKOpticalFlow_t): Integer; cdecl;
Function   pCvSparsePyrLKOpticalFlowgetMinEigThreshold(const wrapper: PCvSparsePyrLKOpticalFlow_t): Double; cdecl;
Function   pCvSparsePyrLKOpticalFlowgetTermCriteria(const wrapper: PCvSparsePyrLKOpticalFlow_t): PCvTermCriteria_t; cdecl;
Function   pCvSparsePyrLKOpticalFlowgetWinSize(const wrapper: PCvSparsePyrLKOpticalFlow_t): PCvSize_t; cdecl;
Procedure  pCvSparsePyrLKOpticalFlowread(const wrapper: PCvSparsePyrLKOpticalFlow_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowsave(const wrapper: PCvSparsePyrLKOpticalFlow_t; filename: PCvString_t); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowsetFlags(const wrapper: PCvSparsePyrLKOpticalFlow_t; flags: Integer); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowsetMaxLevel(const wrapper: PCvSparsePyrLKOpticalFlow_t; maxLevel: Integer); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowsetMinEigThreshold(const wrapper: PCvSparsePyrLKOpticalFlow_t; minEigThreshold: Double); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowsetTermCriteria(const wrapper: PCvSparsePyrLKOpticalFlow_t; crit: PCvTermCriteria_t); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowsetWinSize(const wrapper: PCvSparsePyrLKOpticalFlow_t; winSize: PCvSize_t); cdecl;
Procedure  pCvSparsePyrLKOpticalFlowwrite(const wrapper: PCvSparsePyrLKOpticalFlow_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvStereoBMclear(const wrapper: PCvStereoBM_t); cdecl;
Procedure  pCvStereoBMcompute(const wrapper: PCvStereoBM_t; left: PCvMat_t; right: PCvMat_t; 
                 disparity: PCvMat_t); cdecl;
Procedure  pCvStereoBMcomputeV2(const wrapper: PCvStereoBM_t; left: PCvUMat_t; right: PCvUMat_t; 
                 disparity: PCvUMat_t); cdecl;
Function   pCvStereoBM_create(numDisparities: Integer { default: 0 } = 0; 
                 blockSize: Integer { default: 21 } = 21): PCvPtr_StereoBM; cdecl;
Function   pCvStereoBMempty(const wrapper: PCvStereoBM_t): Boolean; cdecl;
Function   pCvStereoBMgetBlockSize(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetDefaultName(const wrapper: PCvStereoBM_t): PCvString_t; cdecl;
Function   pCvStereoBMgetDisp12MaxDiff(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetMinDisparity(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetNumDisparities(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetPreFilterCap(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetPreFilterSize(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetPreFilterType(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetROI1(const wrapper: PCvStereoBM_t): PCvRect_t; cdecl;
Function   pCvStereoBMgetROI2(const wrapper: PCvStereoBM_t): PCvRect_t; cdecl;
Function   pCvStereoBMgetSmallerBlockSize(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetSpeckleRange(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetSpeckleWindowSize(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetTextureThreshold(const wrapper: PCvStereoBM_t): Integer; cdecl;
Function   pCvStereoBMgetUniquenessRatio(const wrapper: PCvStereoBM_t): Integer; cdecl;
Procedure  pCvStereoBMread(const wrapper: PCvStereoBM_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvStereoBMsave(const wrapper: PCvStereoBM_t; filename: PCvString_t); cdecl;
Procedure  pCvStereoBMsetBlockSize(const wrapper: PCvStereoBM_t; blockSize: Integer); cdecl;
Procedure  pCvStereoBMsetDisp12MaxDiff(const wrapper: PCvStereoBM_t; disp12MaxDiff: Integer); cdecl;
Procedure  pCvStereoBMsetMinDisparity(const wrapper: PCvStereoBM_t; minDisparity: Integer); cdecl;
Procedure  pCvStereoBMsetNumDisparities(const wrapper: PCvStereoBM_t; numDisparities: Integer); cdecl;
Procedure  pCvStereoBMsetPreFilterCap(const wrapper: PCvStereoBM_t; preFilterCap: Integer); cdecl;
Procedure  pCvStereoBMsetPreFilterSize(const wrapper: PCvStereoBM_t; preFilterSize: Integer); cdecl;
Procedure  pCvStereoBMsetPreFilterType(const wrapper: PCvStereoBM_t; preFilterType: Integer); cdecl;
Procedure  pCvStereoBMsetROI1(const wrapper: PCvStereoBM_t; roi1: PCvRect_t); cdecl;
Procedure  pCvStereoBMsetROI2(const wrapper: PCvStereoBM_t; roi2: PCvRect_t); cdecl;
Procedure  pCvStereoBMsetSmallerBlockSize(const wrapper: PCvStereoBM_t; blockSize: Integer); cdecl;
Procedure  pCvStereoBMsetSpeckleRange(const wrapper: PCvStereoBM_t; speckleRange: Integer); cdecl;
Procedure  pCvStereoBMsetSpeckleWindowSize(const wrapper: PCvStereoBM_t; speckleWindowSize: Integer); cdecl;
Procedure  pCvStereoBMsetTextureThreshold(const wrapper: PCvStereoBM_t; textureThreshold: Integer); cdecl;
Procedure  pCvStereoBMsetUniquenessRatio(const wrapper: PCvStereoBM_t; uniquenessRatio: Integer); cdecl;
Procedure  pCvStereoBMwrite(const wrapper: PCvStereoBM_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvStereoMatcherclear(const wrapper: PCvStereoMatcher_t); cdecl;
Procedure  pCvStereoMatchercompute(const wrapper: PCvStereoMatcher_t; left: PCvMat_t; right: PCvMat_t; 
                 disparity: PCvMat_t); cdecl;
Procedure  pCvStereoMatchercomputeV2(const wrapper: PCvStereoMatcher_t; left: PCvUMat_t; 
                 right: PCvUMat_t; disparity: PCvUMat_t); cdecl;
Function   pCvStereoMatcherempty(const wrapper: PCvStereoMatcher_t): Boolean; cdecl;
Function   pCvStereoMatchergetBlockSize(const wrapper: PCvStereoMatcher_t): Integer; cdecl;
Function   pCvStereoMatchergetDefaultName(const wrapper: PCvStereoMatcher_t): PCvString_t; cdecl;
Function   pCvStereoMatchergetDisp12MaxDiff(const wrapper: PCvStereoMatcher_t): Integer; cdecl;
Function   pCvStereoMatchergetMinDisparity(const wrapper: PCvStereoMatcher_t): Integer; cdecl;
Function   pCvStereoMatchergetNumDisparities(const wrapper: PCvStereoMatcher_t): Integer; cdecl;
Function   pCvStereoMatchergetSpeckleRange(const wrapper: PCvStereoMatcher_t): Integer; cdecl;
Function   pCvStereoMatchergetSpeckleWindowSize(const wrapper: PCvStereoMatcher_t): Integer; cdecl;
Procedure  pCvStereoMatcherread(const wrapper: PCvStereoMatcher_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvStereoMatchersave(const wrapper: PCvStereoMatcher_t; filename: PCvString_t); cdecl;
Procedure  pCvStereoMatchersetBlockSize(const wrapper: PCvStereoMatcher_t; blockSize: Integer); cdecl;
Procedure  pCvStereoMatchersetDisp12MaxDiff(const wrapper: PCvStereoMatcher_t; disp12MaxDiff: Integer); cdecl;
Procedure  pCvStereoMatchersetMinDisparity(const wrapper: PCvStereoMatcher_t; minDisparity: Integer); cdecl;
Procedure  pCvStereoMatchersetNumDisparities(const wrapper: PCvStereoMatcher_t; numDisparities: Integer); cdecl;
Procedure  pCvStereoMatchersetSpeckleRange(const wrapper: PCvStereoMatcher_t; speckleRange: Integer); cdecl;
Procedure  pCvStereoMatchersetSpeckleWindowSize(const wrapper: PCvStereoMatcher_t; speckleWindowSize: Integer); cdecl;
Procedure  pCvStereoMatcherwrite(const wrapper: PCvStereoMatcher_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvStereoSGBMclear(const wrapper: PCvStereoSGBM_t); cdecl;
Procedure  pCvStereoSGBMcompute(const wrapper: PCvStereoSGBM_t; left: PCvMat_t; right: PCvMat_t; 
                 disparity: PCvMat_t); cdecl;
Procedure  pCvStereoSGBMcomputeV2(const wrapper: PCvStereoSGBM_t; left: PCvUMat_t; right: PCvUMat_t; 
                 disparity: PCvUMat_t); cdecl;
Function   pCvStereoSGBM_create(minDisparity: Integer { default: 0 } = 0; 
                 numDisparities: Integer { default: 16 } = 16; blockSize: Integer { default: 3 } = 3; P1: Integer { default: 0 } = 0; 
                 P2: Integer { default: 0 } = 0; disp12MaxDiff: Integer { default: 0 } = 0; 
                 preFilterCap: Integer { default: 0 } = 0; uniquenessRatio: Integer { default: 0 } = 0; 
                 speckleWindowSize: Integer { default: 0 } = 0; speckleRange: Integer { default: 0 } = 0; 
                 mode: Integer { default: StereoSGBM::MODE_SGBM } = ord(StereoSGBM_MODE_SGBM)): PCvPtr_StereoSGBM; cdecl;
Function   pCvStereoSGBMempty(const wrapper: PCvStereoSGBM_t): Boolean; cdecl;
Function   pCvStereoSGBMgetBlockSize(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetDefaultName(const wrapper: PCvStereoSGBM_t): PCvString_t; cdecl;
Function   pCvStereoSGBMgetDisp12MaxDiff(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetMinDisparity(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetMode(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetNumDisparities(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetP1(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetP2(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetPreFilterCap(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetSpeckleRange(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetSpeckleWindowSize(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Function   pCvStereoSGBMgetUniquenessRatio(const wrapper: PCvStereoSGBM_t): Integer; cdecl;
Procedure  pCvStereoSGBMread(const wrapper: PCvStereoSGBM_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvStereoSGBMsave(const wrapper: PCvStereoSGBM_t; filename: PCvString_t); cdecl;
Procedure  pCvStereoSGBMsetBlockSize(const wrapper: PCvStereoSGBM_t; blockSize: Integer); cdecl;
Procedure  pCvStereoSGBMsetDisp12MaxDiff(const wrapper: PCvStereoSGBM_t; disp12MaxDiff: Integer); cdecl;
Procedure  pCvStereoSGBMsetMinDisparity(const wrapper: PCvStereoSGBM_t; minDisparity: Integer); cdecl;
Procedure  pCvStereoSGBMsetMode(const wrapper: PCvStereoSGBM_t; mode: Integer); cdecl;
Procedure  pCvStereoSGBMsetNumDisparities(const wrapper: PCvStereoSGBM_t; numDisparities: Integer); cdecl;
Procedure  pCvStereoSGBMsetP1(const wrapper: PCvStereoSGBM_t; P1: Integer); cdecl;
Procedure  pCvStereoSGBMsetP2(const wrapper: PCvStereoSGBM_t; P2: Integer); cdecl;
Procedure  pCvStereoSGBMsetPreFilterCap(const wrapper: PCvStereoSGBM_t; preFilterCap: Integer); cdecl;
Procedure  pCvStereoSGBMsetSpeckleRange(const wrapper: PCvStereoSGBM_t; speckleRange: Integer); cdecl;
Procedure  pCvStereoSGBMsetSpeckleWindowSize(const wrapper: PCvStereoSGBM_t; speckleWindowSize: Integer); cdecl;
Procedure  pCvStereoSGBMsetUniquenessRatio(const wrapper: PCvStereoSGBM_t; uniquenessRatio: Integer); cdecl;
Procedure  pCvStereoSGBMwrite(const wrapper: PCvStereoSGBM_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvStitchercomposePanorama(const wrapper: PCvStitcher_t; pano: PCvMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitchercomposePanoramaV2(const wrapper: PCvStitcher_t; pano: PCvUMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitchercomposePanoramaV3(const wrapper: PCvStitcher_t; images: PCvvector_Mat; 
                 pano: PCvMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitchercomposePanoramaV4(const wrapper: PCvStitcher_t; images: PCvvector_UMat; 
                 pano: PCvUMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitchercompositingResol(const wrapper: PCvStitcher_t): Double; cdecl;
Function   pCvStitcher_create(
                 mode: TCvStitcher_Mode { default: Stitcher::PANORAMA } = TCvStitcher_Mode.PANORAMA): PCvPtr_Stitcher; cdecl;
Function   pCvStitcherestimateTransform(const wrapper: PCvStitcher_t; images: PCvvector_Mat; 
                 masks: PCvvector_Mat { default: vector_Mat() } = nil): TCvStitcher_Status; cdecl;
Function   pCvStitcherestimateTransformV2(const wrapper: PCvStitcher_t; images: PCvvector_UMat; 
                 masks: PCvvector_UMat { default: vector_UMat() } = nil): TCvStitcher_Status; cdecl;
Function   pCvStitcherinterpolationFlags(const wrapper: PCvStitcher_t): TCvInterpolationFlags; cdecl;
Function   pCvStitcherpanoConfidenceThresh(const wrapper: PCvStitcher_t): Double; cdecl;
Function   pCvStitcherregistrationResol(const wrapper: PCvStitcher_t): Double; cdecl;
Function   pCvStitcherseamEstimationResol(const wrapper: PCvStitcher_t): Double; cdecl;
Procedure  pCvStitchersetCompositingResol(const wrapper: PCvStitcher_t; resol_mpx: Double); cdecl;
Procedure  pCvStitchersetInterpolationFlags(const wrapper: PCvStitcher_t; interp_flags: TCvInterpolationFlags); cdecl;
Procedure  pCvStitchersetPanoConfidenceThresh(const wrapper: PCvStitcher_t; conf_thresh: Double); cdecl;
Procedure  pCvStitchersetRegistrationResol(const wrapper: PCvStitcher_t; resol_mpx: Double); cdecl;
Procedure  pCvStitchersetSeamEstimationResol(const wrapper: PCvStitcher_t; resol_mpx: Double); cdecl;
Procedure  pCvStitchersetWaveCorrection(const wrapper: PCvStitcher_t; flag: Boolean); cdecl;
Function   pCvStitcherstitch(const wrapper: PCvStitcher_t; images: PCvvector_Mat; pano: PCvMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitcherstitchV2(const wrapper: PCvStitcher_t; images: PCvvector_UMat; pano: PCvUMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitcherstitchV3(const wrapper: PCvStitcher_t; images: PCvvector_Mat; masks: PCvvector_Mat; 
                 pano: PCvMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitcherstitchV4(const wrapper: PCvStitcher_t; images: PCvvector_UMat; 
                 masks: PCvvector_UMat; pano: PCvUMat_t): TCvStitcher_Status; cdecl;
Function   pCvStitcherwaveCorrection(const wrapper: PCvStitcher_t): Boolean; cdecl;
Function   pCvStitcherworkScale(const wrapper: PCvStitcher_t): Double; cdecl;
Function   pCvSubdiv2DedgeDst(const wrapper: PCvSubdiv2D_t; edge: Integer; 
                 dstpt: PCvPoint2f_t { default: 0 } = 0): Integer; cdecl;
Function   pCvSubdiv2DedgeOrg(const wrapper: PCvSubdiv2D_t; edge: Integer; 
                 orgpt: PCvPoint2f_t { default: 0 } = 0): Integer; cdecl;
Function   pCvSubdiv2DfindNearest(const wrapper: PCvSubdiv2D_t; pt: PCvPoint2f_t; 
                 nearestPt: PCvPoint2f_t { default: 0 } = 0): Integer; cdecl;
Function   pCvSubdiv2DgetEdge(const wrapper: PCvSubdiv2D_t; edge: Integer; nextEdgeType: Integer): Integer; cdecl;
Procedure  pCvSubdiv2DgetEdgeList(const wrapper: PCvSubdiv2D_t; edgeList: PCvvector_Vec4f); cdecl;
Procedure  pCvSubdiv2DgetLeadingEdgeList(const wrapper: PCvSubdiv2D_t; leadingEdgeList: PCvvector_int); cdecl;
Procedure  pCvSubdiv2DgetTriangleList(const wrapper: PCvSubdiv2D_t; triangleList: PCvvector_Vec6f); cdecl;
Function   pCvSubdiv2DgetVertex(const wrapper: PCvSubdiv2D_t; vertex: Integer; 
                 firstEdge: PInteger { default: 0 } = 0): PCvPoint2f_t; cdecl;
Procedure  pCvSubdiv2DgetVoronoiFacetList(const wrapper: PCvSubdiv2D_t; idx: PCvvector_int; 
                 facetList: PCvvector_vector_Point2f; facetCenters: PCvvector_Point2f); cdecl;
Procedure  pCvSubdiv2DinitDelaunay(const wrapper: PCvSubdiv2D_t; rect: PCvRect_t); cdecl;
Function   pCvSubdiv2Dinsert(const wrapper: PCvSubdiv2D_t; pt: PCvPoint2f_t): Integer; cdecl;
Procedure  pCvSubdiv2DinsertV2(const wrapper: PCvSubdiv2D_t; ptvec: PCvvector_Point2f); cdecl;
Function   pCvSubdiv2Dlocate(const wrapper: PCvSubdiv2D_t; pt: PCvPoint2f_t; edge: Integer; 
                 vertex: Integer): Integer; cdecl;
Function   pCvSubdiv2DnextEdge(const wrapper: PCvSubdiv2D_t; edge: Integer): Integer; cdecl;
Function   pCvSubdiv2DrotateEdge(const wrapper: PCvSubdiv2D_t; edge: Integer; rotate: Integer): Integer; cdecl;
Function   pCvSubdiv2DsymEdge(const wrapper: PCvSubdiv2D_t; edge: Integer): Integer; cdecl;
Function   pCvTickMetergetAvgTimeMilli(const wrapper: PCvTickMeter_t): Double; cdecl;
Function   pCvTickMetergetAvgTimeSec(const wrapper: PCvTickMeter_t): Double; cdecl;
Function   pCvTickMetergetCounter(const wrapper: PCvTickMeter_t): Int64; cdecl;
Function   pCvTickMetergetFPS(const wrapper: PCvTickMeter_t): Double; cdecl;
Function   pCvTickMetergetTimeMicro(const wrapper: PCvTickMeter_t): Double; cdecl;
Function   pCvTickMetergetTimeMilli(const wrapper: PCvTickMeter_t): Double; cdecl;
Function   pCvTickMetergetTimeSec(const wrapper: PCvTickMeter_t): Double; cdecl;
Function   pCvTickMetergetTimeTicks(const wrapper: PCvTickMeter_t): Int64; cdecl;
Procedure  pCvTickMeterreset(const wrapper: PCvTickMeter_t); cdecl;
Procedure  pCvTickMeterstart(const wrapper: PCvTickMeter_t); cdecl;
Procedure  pCvTickMeterstop(const wrapper: PCvTickMeter_t); cdecl;
Procedure  pCvTonemapclear(const wrapper: PCvTonemap_t); cdecl;
Function   pCvTonemapempty(const wrapper: PCvTonemap_t): Boolean; cdecl;
Function   pCvTonemapgetDefaultName(const wrapper: PCvTonemap_t): PCvString_t; cdecl;
Function   pCvTonemapgetGamma(const wrapper: PCvTonemap_t): Single; cdecl;
Procedure  pCvTonemapprocess(const wrapper: PCvTonemap_t; src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvTonemapprocessV2(const wrapper: PCvTonemap_t; src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvTonemapread(const wrapper: PCvTonemap_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvTonemapsave(const wrapper: PCvTonemap_t; filename: PCvString_t); cdecl;
Procedure  pCvTonemapsetGamma(const wrapper: PCvTonemap_t; gamma: Single); cdecl;
Procedure  pCvTonemapwrite(const wrapper: PCvTonemap_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvTonemapDragoclear(const wrapper: PCvTonemapDrago_t); cdecl;
Function   pCvTonemapDragoempty(const wrapper: PCvTonemapDrago_t): Boolean; cdecl;
Function   pCvTonemapDragogetBias(const wrapper: PCvTonemapDrago_t): Single; cdecl;
Function   pCvTonemapDragogetDefaultName(const wrapper: PCvTonemapDrago_t): PCvString_t; cdecl;
Function   pCvTonemapDragogetGamma(const wrapper: PCvTonemapDrago_t): Single; cdecl;
Function   pCvTonemapDragogetSaturation(const wrapper: PCvTonemapDrago_t): Single; cdecl;
Procedure  pCvTonemapDragoprocess(const wrapper: PCvTonemapDrago_t; src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvTonemapDragoprocessV2(const wrapper: PCvTonemapDrago_t; src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvTonemapDragoread(const wrapper: PCvTonemapDrago_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvTonemapDragosave(const wrapper: PCvTonemapDrago_t; filename: PCvString_t); cdecl;
Procedure  pCvTonemapDragosetBias(const wrapper: PCvTonemapDrago_t; bias: Single); cdecl;
Procedure  pCvTonemapDragosetGamma(const wrapper: PCvTonemapDrago_t; gamma: Single); cdecl;
Procedure  pCvTonemapDragosetSaturation(const wrapper: PCvTonemapDrago_t; saturation: Single); cdecl;
Procedure  pCvTonemapDragowrite(const wrapper: PCvTonemapDrago_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvTonemapMantiukclear(const wrapper: PCvTonemapMantiuk_t); cdecl;
Function   pCvTonemapMantiukempty(const wrapper: PCvTonemapMantiuk_t): Boolean; cdecl;
Function   pCvTonemapMantiukgetDefaultName(const wrapper: PCvTonemapMantiuk_t): PCvString_t; cdecl;
Function   pCvTonemapMantiukgetGamma(const wrapper: PCvTonemapMantiuk_t): Single; cdecl;
Function   pCvTonemapMantiukgetSaturation(const wrapper: PCvTonemapMantiuk_t): Single; cdecl;
Function   pCvTonemapMantiukgetScale(const wrapper: PCvTonemapMantiuk_t): Single; cdecl;
Procedure  pCvTonemapMantiukprocess(const wrapper: PCvTonemapMantiuk_t; src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvTonemapMantiukprocessV2(const wrapper: PCvTonemapMantiuk_t; src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvTonemapMantiukread(const wrapper: PCvTonemapMantiuk_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvTonemapMantiuksave(const wrapper: PCvTonemapMantiuk_t; filename: PCvString_t); cdecl;
Procedure  pCvTonemapMantiuksetGamma(const wrapper: PCvTonemapMantiuk_t; gamma: Single); cdecl;
Procedure  pCvTonemapMantiuksetSaturation(const wrapper: PCvTonemapMantiuk_t; saturation: Single); cdecl;
Procedure  pCvTonemapMantiuksetScale(const wrapper: PCvTonemapMantiuk_t; scale: Single); cdecl;
Procedure  pCvTonemapMantiukwrite(const wrapper: PCvTonemapMantiuk_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvTonemapReinhardclear(const wrapper: PCvTonemapReinhard_t); cdecl;
Function   pCvTonemapReinhardempty(const wrapper: PCvTonemapReinhard_t): Boolean; cdecl;
Function   pCvTonemapReinhardgetColorAdaptation(const wrapper: PCvTonemapReinhard_t): Single; cdecl;
Function   pCvTonemapReinhardgetDefaultName(const wrapper: PCvTonemapReinhard_t): PCvString_t; cdecl;
Function   pCvTonemapReinhardgetGamma(const wrapper: PCvTonemapReinhard_t): Single; cdecl;
Function   pCvTonemapReinhardgetIntensity(const wrapper: PCvTonemapReinhard_t): Single; cdecl;
Function   pCvTonemapReinhardgetLightAdaptation(const wrapper: PCvTonemapReinhard_t): Single; cdecl;
Procedure  pCvTonemapReinhardprocess(const wrapper: PCvTonemapReinhard_t; src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvTonemapReinhardprocessV2(const wrapper: PCvTonemapReinhard_t; src: PCvUMat_t; 
                 dst: PCvUMat_t); cdecl;
Procedure  pCvTonemapReinhardread(const wrapper: PCvTonemapReinhard_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvTonemapReinhardsave(const wrapper: PCvTonemapReinhard_t; filename: PCvString_t); cdecl;
Procedure  pCvTonemapReinhardsetColorAdaptation(const wrapper: PCvTonemapReinhard_t; color_adapt: Single); cdecl;
Procedure  pCvTonemapReinhardsetGamma(const wrapper: PCvTonemapReinhard_t; gamma: Single); cdecl;
Procedure  pCvTonemapReinhardsetIntensity(const wrapper: PCvTonemapReinhard_t; intensity: Single); cdecl;
Procedure  pCvTonemapReinhardsetLightAdaptation(const wrapper: PCvTonemapReinhard_t; light_adapt: Single); cdecl;
Procedure  pCvTonemapReinhardwrite(const wrapper: PCvTonemapReinhard_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvTrackerinit(const wrapper: PCvTracker_t; image: PCvMat_t; boundingBox: PCvRect_t); cdecl;
Procedure  pCvTrackerinitV2(const wrapper: PCvTracker_t; image: PCvUMat_t; boundingBox: PCvRect_t); cdecl;
Function   pCvTrackerupdate(const wrapper: PCvTracker_t; image: PCvMat_t; boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerupdateV2(const wrapper: PCvTracker_t; image: PCvUMat_t; boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerDaSiamRPN_create(
                 parameters: PCvTrackerDaSiamRPN_Params_t { default: TrackerDaSiamRPN::Params() } = nil): PCvPtr_TrackerDaSiamRPN; cdecl;
Function   pCvTrackerDaSiamRPNgetTrackingScore(const wrapper: PCvTrackerDaSiamRPN_t): Single; cdecl;
Procedure  pCvTrackerDaSiamRPNinit(const wrapper: PCvTrackerDaSiamRPN_t; image: PCvMat_t; 
                 boundingBox: PCvRect_t); cdecl;
Procedure  pCvTrackerDaSiamRPNinitV2(const wrapper: PCvTrackerDaSiamRPN_t; image: PCvUMat_t; 
                 boundingBox: PCvRect_t); cdecl;
Function   pCvTrackerDaSiamRPNupdate(const wrapper: PCvTrackerDaSiamRPN_t; image: PCvMat_t; 
                 boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerDaSiamRPNupdateV2(const wrapper: PCvTrackerDaSiamRPN_t; image: PCvUMat_t; 
                 boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerDaSiamRPN_ParamsGet_backend(const wrapper: PCvTrackerDaSiamRPN_Params_t): Integer; cdecl;
Procedure  pCvTrackerDaSiamRPN_ParamsSet_backend(const wrapper: PCvTrackerDaSiamRPN_Params_t; propval: Integer); cdecl;
Function   pCvTrackerDaSiamRPN_ParamsGet_kernel_cls1(const wrapper: PCvTrackerDaSiamRPN_Params_t): PCvString_t; cdecl;
Procedure  pCvTrackerDaSiamRPN_ParamsSet_kernel_cls1(const wrapper: PCvTrackerDaSiamRPN_Params_t; propval: PCvString_t); cdecl;
Function   pCvTrackerDaSiamRPN_ParamsGet_kernel_r1(const wrapper: PCvTrackerDaSiamRPN_Params_t): PCvString_t; cdecl;
Procedure  pCvTrackerDaSiamRPN_ParamsSet_kernel_r1(const wrapper: PCvTrackerDaSiamRPN_Params_t; propval: PCvString_t); cdecl;
Function   pCvTrackerDaSiamRPN_ParamsGet_model(const wrapper: PCvTrackerDaSiamRPN_Params_t): PCvString_t; cdecl;
Procedure  pCvTrackerDaSiamRPN_ParamsSet_model(const wrapper: PCvTrackerDaSiamRPN_Params_t; propval: PCvString_t); cdecl;
Function   pCvTrackerDaSiamRPN_ParamsGet_target(const wrapper: PCvTrackerDaSiamRPN_Params_t): Integer; cdecl;
Procedure  pCvTrackerDaSiamRPN_ParamsSet_target(const wrapper: PCvTrackerDaSiamRPN_Params_t; propval: Integer); cdecl;
Function   pCvTrackerGOTURN_create(
                 parameters: PCvTrackerGOTURN_Params_t { default: TrackerGOTURN::Params() } = nil): PCvPtr_TrackerGOTURN; cdecl;
Procedure  pCvTrackerGOTURNinit(const wrapper: PCvTrackerGOTURN_t; image: PCvMat_t; 
                 boundingBox: PCvRect_t); cdecl;
Procedure  pCvTrackerGOTURNinitV2(const wrapper: PCvTrackerGOTURN_t; image: PCvUMat_t; 
                 boundingBox: PCvRect_t); cdecl;
Function   pCvTrackerGOTURNupdate(const wrapper: PCvTrackerGOTURN_t; image: PCvMat_t; 
                 boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerGOTURNupdateV2(const wrapper: PCvTrackerGOTURN_t; image: PCvUMat_t; 
                 boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerGOTURN_ParamsGet_modelBin(const wrapper: PCvTrackerGOTURN_Params_t): PCvString_t; cdecl;
Procedure  pCvTrackerGOTURN_ParamsSet_modelBin(const wrapper: PCvTrackerGOTURN_Params_t; propval: PCvString_t); cdecl;
Function   pCvTrackerGOTURN_ParamsGet_modelTxt(const wrapper: PCvTrackerGOTURN_Params_t): PCvString_t; cdecl;
Procedure  pCvTrackerGOTURN_ParamsSet_modelTxt(const wrapper: PCvTrackerGOTURN_Params_t; propval: PCvString_t); cdecl;
Function   pCvTrackerMIL_create(
                 parameters: PCvTrackerMIL_Params_t { default: TrackerMIL::Params() } = nil): PCvPtr_TrackerMIL; cdecl;
Procedure  pCvTrackerMILinit(const wrapper: PCvTrackerMIL_t; image: PCvMat_t; boundingBox: PCvRect_t); cdecl;
Procedure  pCvTrackerMILinitV2(const wrapper: PCvTrackerMIL_t; image: PCvUMat_t; boundingBox: PCvRect_t); cdecl;
Function   pCvTrackerMILupdate(const wrapper: PCvTrackerMIL_t; image: PCvMat_t; boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerMILupdateV2(const wrapper: PCvTrackerMIL_t; image: PCvUMat_t; 
                 boundingBox: PCvRect_t): Boolean; cdecl;
Function   pCvTrackerMIL_ParamsGet_featureSetNumFeatures(const wrapper: PCvTrackerMIL_Params_t): Integer; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_featureSetNumFeatures(const wrapper: PCvTrackerMIL_Params_t; propval: Integer); cdecl;
Function   pCvTrackerMIL_ParamsGet_samplerInitInRadius(const wrapper: PCvTrackerMIL_Params_t): Single; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_samplerInitInRadius(const wrapper: PCvTrackerMIL_Params_t; propval: Single); cdecl;
Function   pCvTrackerMIL_ParamsGet_samplerInitMaxNegNum(const wrapper: PCvTrackerMIL_Params_t): Integer; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_samplerInitMaxNegNum(const wrapper: PCvTrackerMIL_Params_t; propval: Integer); cdecl;
Function   pCvTrackerMIL_ParamsGet_samplerSearchWinSize(const wrapper: PCvTrackerMIL_Params_t): Single; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_samplerSearchWinSize(const wrapper: PCvTrackerMIL_Params_t; propval: Single); cdecl;
Function   pCvTrackerMIL_ParamsGet_samplerTrackInRadius(const wrapper: PCvTrackerMIL_Params_t): Single; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_samplerTrackInRadius(const wrapper: PCvTrackerMIL_Params_t; propval: Single); cdecl;
Function   pCvTrackerMIL_ParamsGet_samplerTrackMaxNegNum(const wrapper: PCvTrackerMIL_Params_t): Integer; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_samplerTrackMaxNegNum(const wrapper: PCvTrackerMIL_Params_t; propval: Integer); cdecl;
Function   pCvTrackerMIL_ParamsGet_samplerTrackMaxPosNum(const wrapper: PCvTrackerMIL_Params_t): Integer; cdecl;
Procedure  pCvTrackerMIL_ParamsSet_samplerTrackMaxPosNum(const wrapper: PCvTrackerMIL_Params_t; propval: Integer); cdecl;
Function   pCvUMathandle(const wrapper: PCvUMat_t; accessFlags: TCvAccessFlag): Pointer; cdecl;
Function   pCvUMatisContinuous(const wrapper: PCvUMat_t): Boolean; cdecl;
Function   pCvUMatisSubmatrix(const wrapper: PCvUMat_t): Boolean; cdecl;
Function   pCvUMatGet_offset(const wrapper: PCvUMat_t): UInt64; cdecl;
Procedure  pCvUMatSet_offset(const wrapper: PCvUMat_t; propval: UInt64); cdecl;
Function   pCvUsacParamsGet_confidence(const wrapper: PCvUsacParams_t): Double; cdecl;
Procedure  pCvUsacParamsSet_confidence(const wrapper: PCvUsacParams_t; propval: Double); cdecl;
Function   pCvUsacParamsGet_isParallel(const wrapper: PCvUsacParams_t): Boolean; cdecl;
Procedure  pCvUsacParamsSet_isParallel(const wrapper: PCvUsacParams_t; propval: Boolean); cdecl;
Function   pCvUsacParamsGet_loIterations(const wrapper: PCvUsacParams_t): Integer; cdecl;
Procedure  pCvUsacParamsSet_loIterations(const wrapper: PCvUsacParams_t; propval: Integer); cdecl;
Function   pCvUsacParamsGet_loMethod(const wrapper: PCvUsacParams_t): TCvLocalOptimMethod; cdecl;
Procedure  pCvUsacParamsSet_loMethod(const wrapper: PCvUsacParams_t; propval: TCvLocalOptimMethod); cdecl;
Function   pCvUsacParamsGet_loSampleSize(const wrapper: PCvUsacParams_t): Integer; cdecl;
Procedure  pCvUsacParamsSet_loSampleSize(const wrapper: PCvUsacParams_t; propval: Integer); cdecl;
Function   pCvUsacParamsGet_maxIterations(const wrapper: PCvUsacParams_t): Integer; cdecl;
Procedure  pCvUsacParamsSet_maxIterations(const wrapper: PCvUsacParams_t; propval: Integer); cdecl;
Function   pCvUsacParamsGet_neighborsSearch(const wrapper: PCvUsacParams_t): TCvNeighborSearchMethod; cdecl;
Procedure  pCvUsacParamsSet_neighborsSearch(const wrapper: PCvUsacParams_t; propval: TCvNeighborSearchMethod); cdecl;
Function   pCvUsacParamsGet_randomGeneratorState(const wrapper: PCvUsacParams_t): Integer; cdecl;
Procedure  pCvUsacParamsSet_randomGeneratorState(const wrapper: PCvUsacParams_t; propval: Integer); cdecl;
Function   pCvUsacParamsGet_sampler(const wrapper: PCvUsacParams_t): TCvSamplingMethod; cdecl;
Procedure  pCvUsacParamsSet_sampler(const wrapper: PCvUsacParams_t; propval: TCvSamplingMethod); cdecl;
Function   pCvUsacParamsGet_score(const wrapper: PCvUsacParams_t): TCvScoreMethod; cdecl;
Procedure  pCvUsacParamsSet_score(const wrapper: PCvUsacParams_t; propval: TCvScoreMethod); cdecl;
Function   pCvUsacParamsGet_threshold(const wrapper: PCvUsacParams_t): Double; cdecl;
Procedure  pCvUsacParamsSet_threshold(const wrapper: PCvUsacParams_t; propval: Double); cdecl;
Procedure  pCvVariationalRefinementcalc(const wrapper: PCvVariationalRefinement_t; I0: PCvMat_t; 
                 I1: PCvMat_t; flow: PCvMat_t); cdecl;
Procedure  pCvVariationalRefinementcalcV2(const wrapper: PCvVariationalRefinement_t; I0: PCvUMat_t; 
                 I1: PCvUMat_t; flow: PCvUMat_t); cdecl;
Procedure  pCvVariationalRefinementcalcUV(const wrapper: PCvVariationalRefinement_t; I0: PCvMat_t; 
                 I1: PCvMat_t; flow_u: PCvMat_t; flow_v: PCvMat_t); cdecl;
Procedure  pCvVariationalRefinementcalcUVV2(const wrapper: PCvVariationalRefinement_t; I0: PCvUMat_t; 
                 I1: PCvUMat_t; flow_u: PCvUMat_t; flow_v: PCvUMat_t); cdecl;
Procedure  pCvVariationalRefinementclear(const wrapper: PCvVariationalRefinement_t); cdecl;
Procedure  pCvVariationalRefinementcollectGarbage(const wrapper: PCvVariationalRefinement_t); cdecl;
Function   pCvVariationalRefinement_create(): PCvPtr_VariationalRefinement; cdecl;
Function   pCvVariationalRefinementempty(const wrapper: PCvVariationalRefinement_t): Boolean; cdecl;
Function   pCvVariationalRefinementgetAlpha(const wrapper: PCvVariationalRefinement_t): Single; cdecl;
Function   pCvVariationalRefinementgetDefaultName(const wrapper: PCvVariationalRefinement_t): PCvString_t; cdecl;
Function   pCvVariationalRefinementgetDelta(const wrapper: PCvVariationalRefinement_t): Single; cdecl;
Function   pCvVariationalRefinementgetFixedPointIterations(const wrapper: PCvVariationalRefinement_t): Integer; cdecl;
Function   pCvVariationalRefinementgetGamma(const wrapper: PCvVariationalRefinement_t): Single; cdecl;
Function   pCvVariationalRefinementgetOmega(const wrapper: PCvVariationalRefinement_t): Single; cdecl;
Function   pCvVariationalRefinementgetSorIterations(const wrapper: PCvVariationalRefinement_t): Integer; cdecl;
Procedure  pCvVariationalRefinementread(const wrapper: PCvVariationalRefinement_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvVariationalRefinementsave(const wrapper: PCvVariationalRefinement_t; filename: PCvString_t); cdecl;
Procedure  pCvVariationalRefinementsetAlpha(const wrapper: PCvVariationalRefinement_t; _val: Single); cdecl;
Procedure  pCvVariationalRefinementsetDelta(const wrapper: PCvVariationalRefinement_t; _val: Single); cdecl;
Procedure  pCvVariationalRefinementsetFixedPointIterations(const wrapper: PCvVariationalRefinement_t; _val: Integer); cdecl;
Procedure  pCvVariationalRefinementsetGamma(const wrapper: PCvVariationalRefinement_t; _val: Single); cdecl;
Procedure  pCvVariationalRefinementsetOmega(const wrapper: PCvVariationalRefinement_t; _val: Single); cdecl;
Procedure  pCvVariationalRefinementsetSorIterations(const wrapper: PCvVariationalRefinement_t; _val: Integer); cdecl;
Procedure  pCvVariationalRefinementwrite(const wrapper: PCvVariationalRefinement_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvVideoCaptureget(const wrapper: PCvVideoCapture_t; propId: Integer): Double; cdecl;
Function   pCvVideoCapturegetBackendName(const wrapper: PCvVideoCapture_t): PCvString_t; cdecl;
Function   pCvVideoCapturegetExceptionMode(const wrapper: PCvVideoCapture_t): Boolean; cdecl;
Function   pCvVideoCapturegrab(const wrapper: PCvVideoCapture_t): Boolean; cdecl;
Function   pCvVideoCaptureisOpened(const wrapper: PCvVideoCapture_t): Boolean; cdecl;
Function   pCvVideoCaptureopen(const wrapper: PCvVideoCapture_t; filename: PCvString_t; 
                 apiPreference: Integer { default: CAP_ANY } = ord(CAP_ANY)): Boolean; cdecl;
Function   pCvVideoCaptureopenV2(const wrapper: PCvVideoCapture_t; filename: PCvString_t; 
                 apiPreference: Integer; params: PCvvector_int): Boolean; cdecl;
Function   pCvVideoCaptureopenV3(const wrapper: PCvVideoCapture_t; index: Integer; 
                 apiPreference: Integer { default: CAP_ANY } = ord(CAP_ANY)): Boolean; cdecl;
Function   pCvVideoCaptureopenV4(const wrapper: PCvVideoCapture_t; index: Integer; 
                 apiPreference: Integer; params: PCvvector_int): Boolean; cdecl;
Function   pCvVideoCaptureread(const wrapper: PCvVideoCapture_t; image: PCvMat_t): Boolean; cdecl;
Function   pCvVideoCapturereadV2(const wrapper: PCvVideoCapture_t; image: PCvUMat_t): Boolean; cdecl;
Procedure  pCvVideoCapturerelease(const wrapper: PCvVideoCapture_t); cdecl;
Function   pCvVideoCaptureretrieve(const wrapper: PCvVideoCapture_t; image: PCvMat_t; 
                 flag: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvVideoCaptureretrieveV2(const wrapper: PCvVideoCapture_t; image: PCvUMat_t; 
                 flag: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvVideoCaptureset(const wrapper: PCvVideoCapture_t; propId: Integer; value: Double): Boolean; cdecl;
Procedure  pCvVideoCapturesetExceptionMode(const wrapper: PCvVideoCapture_t; enable: Boolean); cdecl;
Function   pCvVideoWriterfourcc(c1: Char; c2: Char; c3: Char; c4: Char): Integer; cdecl;
Function   pCvVideoWriterget(const wrapper: PCvVideoWriter_t; propId: Integer): Double; cdecl;
Function   pCvVideoWritergetBackendName(const wrapper: PCvVideoWriter_t): PCvString_t; cdecl;
Function   pCvVideoWriterisOpened(const wrapper: PCvVideoWriter_t): Boolean; cdecl;
Function   pCvVideoWriteropen(const wrapper: PCvVideoWriter_t; filename: PCvString_t; fourcc: Integer; 
                 fps: Double; frameSize: PCvSize_t; isColor: Boolean { default: true } = true): Boolean; cdecl;
Function   pCvVideoWriteropenV2(const wrapper: PCvVideoWriter_t; filename: PCvString_t; 
                 apiPreference: Integer; fourcc: Integer; fps: Double; frameSize: PCvSize_t; 
                 isColor: Boolean { default: true } = true): Boolean; cdecl;
Function   pCvVideoWriteropenV3(const wrapper: PCvVideoWriter_t; filename: PCvString_t; fourcc: Integer; 
                 fps: Double; frameSize: PCvSize_t; params: PCvvector_int): Boolean; cdecl;
Function   pCvVideoWriteropenV4(const wrapper: PCvVideoWriter_t; filename: PCvString_t; 
                 apiPreference: Integer; fourcc: Integer; fps: Double; frameSize: PCvSize_t; 
                 params: PCvvector_int): Boolean; cdecl;
Procedure  pCvVideoWriterrelease(const wrapper: PCvVideoWriter_t); cdecl;
Function   pCvVideoWriterset(const wrapper: PCvVideoWriter_t; propId: Integer; value: Double): Boolean; cdecl;
Procedure  pCvVideoWriterwrite(const wrapper: PCvVideoWriter_t; image: PCvMat_t); cdecl;
Procedure  pCvVideoWriterwriteV2(const wrapper: PCvVideoWriter_t; image: PCvUMat_t); cdecl;
Function   pCvdetail_AffineBasedEstimatorapply(const wrapper: PCvdetail_AffineBasedEstimator_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Procedure  pCvdetail_AffineBestOf2NearestMatcherapply(const wrapper: PCvdetail_AffineBestOf2NearestMatcher_t; features1: PCvdetail_ImageFeatures_t; 
                 features2: PCvdetail_ImageFeatures_t; matches_info: PCvdetail_MatchesInfo_t); cdecl;
Procedure  pCvdetail_AffineBestOf2NearestMatcherapply2(const wrapper: PCvdetail_AffineBestOf2NearestMatcher_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; mask: PCvUMat_t { default: cv::UMat() } = nil); cdecl;
Procedure  pCvdetail_AffineBestOf2NearestMatchercollectGarbage(const wrapper: PCvdetail_AffineBestOf2NearestMatcher_t); cdecl;
Function   pCvdetail_AffineBestOf2NearestMatcher_create(
                 try_use_gpu: Boolean { default: false } = false; match_conf: Single { default: 0.3f } = 0.3; 
                 num_matches_thresh1: Integer { default: 6 } = 6; 
                 num_matches_thresh2: Integer { default: 6 } = 6): PCvPtr_BestOf2NearestMatcher; cdecl;
Function   pCvdetail_AffineBestOf2NearestMatcherisThreadSafe(const wrapper: PCvdetail_AffineBestOf2NearestMatcher_t): Boolean; cdecl;
Procedure  pCvdetail_BestOf2NearestMatcherapply(const wrapper: PCvdetail_BestOf2NearestMatcher_t; features1: PCvdetail_ImageFeatures_t; 
                 features2: PCvdetail_ImageFeatures_t; matches_info: PCvdetail_MatchesInfo_t); cdecl;
Procedure  pCvdetail_BestOf2NearestMatcherapply2(const wrapper: PCvdetail_BestOf2NearestMatcher_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; mask: PCvUMat_t { default: cv::UMat() } = nil); cdecl;
Procedure  pCvdetail_BestOf2NearestMatchercollectGarbage(const wrapper: PCvdetail_BestOf2NearestMatcher_t); cdecl;
Function   pCvdetail_BestOf2NearestMatcher_create(try_use_gpu: Boolean { default: false } = false; 
                 match_conf: Single { default: 0.3f } = 0.3; num_matches_thresh1: Integer { default: 6 } = 6; 
                 num_matches_thresh2: Integer { default: 6 } = 6): PCvPtr_BestOf2NearestMatcher; cdecl;
Function   pCvdetail_BestOf2NearestMatcherisThreadSafe(const wrapper: PCvdetail_BestOf2NearestMatcher_t): Boolean; cdecl;
Procedure  pCvdetail_BestOf2NearestRangeMatcherapply2(const wrapper: PCvdetail_BestOf2NearestRangeMatcher_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; mask: PCvUMat_t { default: cv::UMat() } = nil); cdecl;
Procedure  pCvdetail_BestOf2NearestRangeMatchercollectGarbage(const wrapper: PCvdetail_BestOf2NearestRangeMatcher_t); cdecl;
Function   pCvdetail_BestOf2NearestRangeMatcher_create(try_use_gpu: Boolean { default: false } = false; 
                 match_conf: Single { default: 0.3f } = 0.3; num_matches_thresh1: Integer { default: 6 } = 6; 
                 num_matches_thresh2: Integer { default: 6 } = 6): PCvPtr_BestOf2NearestMatcher; cdecl;
Function   pCvdetail_BestOf2NearestRangeMatcherisThreadSafe(const wrapper: PCvdetail_BestOf2NearestRangeMatcher_t): Boolean; cdecl;
Procedure  pCvdetail_Blenderblend(const wrapper: PCvdetail_Blender_t; dst: PCvMat_t; dst_mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BlenderblendV2(const wrapper: PCvdetail_Blender_t; dst: PCvUMat_t; 
                 dst_mask: PCvUMat_t); cdecl;
Function   pCvdetail_BlendercreateDefault(_type: Integer; try_gpu: Boolean { default: false } = false): PCvPtr_Blender; cdecl;
Procedure  pCvdetail_Blenderfeed(const wrapper: PCvdetail_Blender_t; img: PCvMat_t; mask: PCvMat_t; 
                 tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_BlenderfeedV2(const wrapper: PCvdetail_Blender_t; img: PCvUMat_t; mask: PCvUMat_t; 
                 tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_Blenderprepare(const wrapper: PCvdetail_Blender_t; corners: PCvvector_Point; 
                 sizes: PCvvector_Size); cdecl;
Procedure  pCvdetail_BlenderprepareV2(const wrapper: PCvdetail_Blender_t; dst_roi: PCvRect_t); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorapply(const wrapper: PCvdetail_BlocksChannelsCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorapplyV2(const wrapper: PCvdetail_BlocksChannelsCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvUMat_t; mask: PCvUMat_t); cdecl;
Function   pCvdetail_BlocksChannelsCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Function   pCvdetail_BlocksChannelsCompensatorgetBlockSize(const wrapper: PCvdetail_BlocksChannelsCompensator_t): PCvSize_t; cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorgetMatGains(const wrapper: PCvdetail_BlocksChannelsCompensator_t; umv: PCvvector_Mat); cdecl;
Function   pCvdetail_BlocksChannelsCompensatorgetNrFeeds(const wrapper: PCvdetail_BlocksChannelsCompensator_t): Integer; cdecl;
Function   pCvdetail_BlocksChannelsCompensatorgetNrGainsFilteringIterations(const wrapper: PCvdetail_BlocksChannelsCompensator_t): Integer; cdecl;
Function   pCvdetail_BlocksChannelsCompensatorgetSimilarityThreshold(const wrapper: PCvdetail_BlocksChannelsCompensator_t): Double; cdecl;
Function   pCvdetail_BlocksChannelsCompensatorgetUpdateGain(const wrapper: PCvdetail_BlocksChannelsCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetBlockSize(const wrapper: PCvdetail_BlocksChannelsCompensator_t; width: Integer; 
                 height: Integer); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetBlockSizeV2(const wrapper: PCvdetail_BlocksChannelsCompensator_t; size: PCvSize_t); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetMatGains(const wrapper: PCvdetail_BlocksChannelsCompensator_t; umv: PCvvector_Mat); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetNrFeeds(const wrapper: PCvdetail_BlocksChannelsCompensator_t; nr_feeds: Integer); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetNrGainsFilteringIterations(const wrapper: PCvdetail_BlocksChannelsCompensator_t; nr_iterations: Integer); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetSimilarityThreshold(const wrapper: PCvdetail_BlocksChannelsCompensator_t; similarity_threshold: Double); cdecl;
Procedure  pCvdetail_BlocksChannelsCompensatorsetUpdateGain(const wrapper: PCvdetail_BlocksChannelsCompensator_t; b: Boolean); cdecl;
Procedure  pCvdetail_BlocksCompensatorapply(const wrapper: PCvdetail_BlocksCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BlocksCompensatorapplyV2(const wrapper: PCvdetail_BlocksCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvUMat_t; mask: PCvUMat_t); cdecl;
Function   pCvdetail_BlocksCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Function   pCvdetail_BlocksCompensatorgetBlockSize(const wrapper: PCvdetail_BlocksCompensator_t): PCvSize_t; cdecl;
Procedure  pCvdetail_BlocksCompensatorgetMatGains(const wrapper: PCvdetail_BlocksCompensator_t; umv: PCvvector_Mat); cdecl;
Function   pCvdetail_BlocksCompensatorgetNrFeeds(const wrapper: PCvdetail_BlocksCompensator_t): Integer; cdecl;
Function   pCvdetail_BlocksCompensatorgetNrGainsFilteringIterations(const wrapper: PCvdetail_BlocksCompensator_t): Integer; cdecl;
Function   pCvdetail_BlocksCompensatorgetSimilarityThreshold(const wrapper: PCvdetail_BlocksCompensator_t): Double; cdecl;
Function   pCvdetail_BlocksCompensatorgetUpdateGain(const wrapper: PCvdetail_BlocksCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_BlocksCompensatorsetBlockSize(const wrapper: PCvdetail_BlocksCompensator_t; width: Integer; 
                 height: Integer); cdecl;
Procedure  pCvdetail_BlocksCompensatorsetBlockSizeV2(const wrapper: PCvdetail_BlocksCompensator_t; size: PCvSize_t); cdecl;
Procedure  pCvdetail_BlocksCompensatorsetMatGains(const wrapper: PCvdetail_BlocksCompensator_t; umv: PCvvector_Mat); cdecl;
Procedure  pCvdetail_BlocksCompensatorsetNrFeeds(const wrapper: PCvdetail_BlocksCompensator_t; nr_feeds: Integer); cdecl;
Procedure  pCvdetail_BlocksCompensatorsetNrGainsFilteringIterations(const wrapper: PCvdetail_BlocksCompensator_t; nr_iterations: Integer); cdecl;
Procedure  pCvdetail_BlocksCompensatorsetSimilarityThreshold(const wrapper: PCvdetail_BlocksCompensator_t; similarity_threshold: Double); cdecl;
Procedure  pCvdetail_BlocksCompensatorsetUpdateGain(const wrapper: PCvdetail_BlocksCompensator_t; b: Boolean); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorapply(const wrapper: PCvdetail_BlocksGainCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorapplyV2(const wrapper: PCvdetail_BlocksGainCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvUMat_t; mask: PCvUMat_t); cdecl;
Function   pCvdetail_BlocksGainCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Function   pCvdetail_BlocksGainCompensatorgetBlockSize(const wrapper: PCvdetail_BlocksGainCompensator_t): PCvSize_t; cdecl;
Procedure  pCvdetail_BlocksGainCompensatorgetMatGains(const wrapper: PCvdetail_BlocksGainCompensator_t; umv: PCvvector_Mat); cdecl;
Function   pCvdetail_BlocksGainCompensatorgetNrFeeds(const wrapper: PCvdetail_BlocksGainCompensator_t): Integer; cdecl;
Function   pCvdetail_BlocksGainCompensatorgetNrGainsFilteringIterations(const wrapper: PCvdetail_BlocksGainCompensator_t): Integer; cdecl;
Function   pCvdetail_BlocksGainCompensatorgetSimilarityThreshold(const wrapper: PCvdetail_BlocksGainCompensator_t): Double; cdecl;
Function   pCvdetail_BlocksGainCompensatorgetUpdateGain(const wrapper: PCvdetail_BlocksGainCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetBlockSize(const wrapper: PCvdetail_BlocksGainCompensator_t; width: Integer; 
                 height: Integer); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetBlockSizeV2(const wrapper: PCvdetail_BlocksGainCompensator_t; size: PCvSize_t); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetMatGains(const wrapper: PCvdetail_BlocksGainCompensator_t; umv: PCvvector_Mat); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetNrFeeds(const wrapper: PCvdetail_BlocksGainCompensator_t; nr_feeds: Integer); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetNrGainsFilteringIterations(const wrapper: PCvdetail_BlocksGainCompensator_t; nr_iterations: Integer); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetSimilarityThreshold(const wrapper: PCvdetail_BlocksGainCompensator_t; similarity_threshold: Double); cdecl;
Procedure  pCvdetail_BlocksGainCompensatorsetUpdateGain(const wrapper: PCvdetail_BlocksGainCompensator_t; b: Boolean); cdecl;
Function   pCvdetail_BundleAdjusterAffineapply(const wrapper: PCvdetail_BundleAdjusterAffine_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_BundleAdjusterAffineconfThresh(const wrapper: PCvdetail_BundleAdjusterAffine_t): Double; cdecl;
Function   pCvdetail_BundleAdjusterAffinerefinementMask(const wrapper: PCvdetail_BundleAdjusterAffine_t): PCvMat_t; cdecl;
Procedure  pCvdetail_BundleAdjusterAffinesetConfThresh(const wrapper: PCvdetail_BundleAdjusterAffine_t; conf_thresh: Double); cdecl;
Procedure  pCvdetail_BundleAdjusterAffinesetRefinementMask(const wrapper: PCvdetail_BundleAdjusterAffine_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BundleAdjusterAffinesetTermCriteria(const wrapper: PCvdetail_BundleAdjusterAffine_t; term_criteria: PCvTermCriteria_t); cdecl;
Function   pCvdetail_BundleAdjusterAffinetermCriteria(const wrapper: PCvdetail_BundleAdjusterAffine_t): PCvTermCriteria_t; cdecl;
Function   pCvdetail_BundleAdjusterAffinePartialapply(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_BundleAdjusterAffinePartialconfThresh(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t): Double; cdecl;
Function   pCvdetail_BundleAdjusterAffinePartialrefinementMask(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t): PCvMat_t; cdecl;
Procedure  pCvdetail_BundleAdjusterAffinePartialsetConfThresh(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t; conf_thresh: Double); cdecl;
Procedure  pCvdetail_BundleAdjusterAffinePartialsetRefinementMask(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BundleAdjusterAffinePartialsetTermCriteria(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t; term_criteria: PCvTermCriteria_t); cdecl;
Function   pCvdetail_BundleAdjusterAffinePartialtermCriteria(const wrapper: PCvdetail_BundleAdjusterAffinePartial_t): PCvTermCriteria_t; cdecl;
Function   pCvdetail_BundleAdjusterBaseapply(const wrapper: PCvdetail_BundleAdjusterBase_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_BundleAdjusterBaseconfThresh(const wrapper: PCvdetail_BundleAdjusterBase_t): Double; cdecl;
Function   pCvdetail_BundleAdjusterBaserefinementMask(const wrapper: PCvdetail_BundleAdjusterBase_t): PCvMat_t; cdecl;
Procedure  pCvdetail_BundleAdjusterBasesetConfThresh(const wrapper: PCvdetail_BundleAdjusterBase_t; conf_thresh: Double); cdecl;
Procedure  pCvdetail_BundleAdjusterBasesetRefinementMask(const wrapper: PCvdetail_BundleAdjusterBase_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BundleAdjusterBasesetTermCriteria(const wrapper: PCvdetail_BundleAdjusterBase_t; term_criteria: PCvTermCriteria_t); cdecl;
Function   pCvdetail_BundleAdjusterBasetermCriteria(const wrapper: PCvdetail_BundleAdjusterBase_t): PCvTermCriteria_t; cdecl;
Function   pCvdetail_BundleAdjusterRayapply(const wrapper: PCvdetail_BundleAdjusterRay_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_BundleAdjusterRayconfThresh(const wrapper: PCvdetail_BundleAdjusterRay_t): Double; cdecl;
Function   pCvdetail_BundleAdjusterRayrefinementMask(const wrapper: PCvdetail_BundleAdjusterRay_t): PCvMat_t; cdecl;
Procedure  pCvdetail_BundleAdjusterRaysetConfThresh(const wrapper: PCvdetail_BundleAdjusterRay_t; conf_thresh: Double); cdecl;
Procedure  pCvdetail_BundleAdjusterRaysetRefinementMask(const wrapper: PCvdetail_BundleAdjusterRay_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BundleAdjusterRaysetTermCriteria(const wrapper: PCvdetail_BundleAdjusterRay_t; term_criteria: PCvTermCriteria_t); cdecl;
Function   pCvdetail_BundleAdjusterRaytermCriteria(const wrapper: PCvdetail_BundleAdjusterRay_t): PCvTermCriteria_t; cdecl;
Function   pCvdetail_BundleAdjusterReprojapply(const wrapper: PCvdetail_BundleAdjusterReproj_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_BundleAdjusterReprojconfThresh(const wrapper: PCvdetail_BundleAdjusterReproj_t): Double; cdecl;
Function   pCvdetail_BundleAdjusterReprojrefinementMask(const wrapper: PCvdetail_BundleAdjusterReproj_t): PCvMat_t; cdecl;
Procedure  pCvdetail_BundleAdjusterReprojsetConfThresh(const wrapper: PCvdetail_BundleAdjusterReproj_t; conf_thresh: Double); cdecl;
Procedure  pCvdetail_BundleAdjusterReprojsetRefinementMask(const wrapper: PCvdetail_BundleAdjusterReproj_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_BundleAdjusterReprojsetTermCriteria(const wrapper: PCvdetail_BundleAdjusterReproj_t; term_criteria: PCvTermCriteria_t); cdecl;
Function   pCvdetail_BundleAdjusterReprojtermCriteria(const wrapper: PCvdetail_BundleAdjusterReproj_t): PCvTermCriteria_t; cdecl;
Function   pCvdetail_CameraParamsK(const wrapper: PCvdetail_CameraParams_t): PCvMat_t; cdecl;
Function   pCvdetail_CameraParamsGet_R(const wrapper: PCvdetail_CameraParams_t): PCvMat_t; cdecl;
Procedure  pCvdetail_CameraParamsSet_R(const wrapper: PCvdetail_CameraParams_t; propval: PCvMat_t); cdecl;
Function   pCvdetail_CameraParamsGet_aspect(const wrapper: PCvdetail_CameraParams_t): Double; cdecl;
Procedure  pCvdetail_CameraParamsSet_aspect(const wrapper: PCvdetail_CameraParams_t; propval: Double); cdecl;
Function   pCvdetail_CameraParamsGet_focal(const wrapper: PCvdetail_CameraParams_t): Double; cdecl;
Procedure  pCvdetail_CameraParamsSet_focal(const wrapper: PCvdetail_CameraParams_t; propval: Double); cdecl;
Function   pCvdetail_CameraParamsGet_ppx(const wrapper: PCvdetail_CameraParams_t): Double; cdecl;
Procedure  pCvdetail_CameraParamsSet_ppx(const wrapper: PCvdetail_CameraParams_t; propval: Double); cdecl;
Function   pCvdetail_CameraParamsGet_ppy(const wrapper: PCvdetail_CameraParams_t): Double; cdecl;
Procedure  pCvdetail_CameraParamsSet_ppy(const wrapper: PCvdetail_CameraParams_t; propval: Double); cdecl;
Function   pCvdetail_CameraParamsGet_t(const wrapper: PCvdetail_CameraParams_t): PCvMat_t; cdecl;
Procedure  pCvdetail_CameraParamsSet_t(const wrapper: PCvdetail_CameraParams_t; propval: PCvMat_t); cdecl;
Procedure  pCvdetail_ChannelsCompensatorapply(const wrapper: PCvdetail_ChannelsCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_ChannelsCompensatorapplyV2(const wrapper: PCvdetail_ChannelsCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvUMat_t; mask: PCvUMat_t); cdecl;
Function   pCvdetail_ChannelsCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Procedure  pCvdetail_ChannelsCompensatorgetMatGains(const wrapper: PCvdetail_ChannelsCompensator_t; umv: PCvvector_Mat); cdecl;
Function   pCvdetail_ChannelsCompensatorgetNrFeeds(const wrapper: PCvdetail_ChannelsCompensator_t): Integer; cdecl;
Function   pCvdetail_ChannelsCompensatorgetSimilarityThreshold(const wrapper: PCvdetail_ChannelsCompensator_t): Double; cdecl;
Function   pCvdetail_ChannelsCompensatorgetUpdateGain(const wrapper: PCvdetail_ChannelsCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_ChannelsCompensatorsetMatGains(const wrapper: PCvdetail_ChannelsCompensator_t; umv: PCvvector_Mat); cdecl;
Procedure  pCvdetail_ChannelsCompensatorsetNrFeeds(const wrapper: PCvdetail_ChannelsCompensator_t; nr_feeds: Integer); cdecl;
Procedure  pCvdetail_ChannelsCompensatorsetSimilarityThreshold(const wrapper: PCvdetail_ChannelsCompensator_t; similarity_threshold: Double); cdecl;
Procedure  pCvdetail_ChannelsCompensatorsetUpdateGain(const wrapper: PCvdetail_ChannelsCompensator_t; b: Boolean); cdecl;
Function   pCvdetail_DpSeamFindercreateDefault(_type: Integer): PCvPtr_SeamFinder; cdecl;
Procedure  pCvdetail_DpSeamFinderfind(const wrapper: PCvdetail_DpSeamFinder_t; src: PCvvector_UMat; 
                 corners: PCvvector_Point; masks: PCvvector_UMat); cdecl;
Procedure  pCvdetail_DpSeamFindersetCostFunction(const wrapper: PCvdetail_DpSeamFinder_t; _val: PCvString_t); cdecl;
Function   pCvdetail_Estimatorapply(const wrapper: PCvdetail_Estimator_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Procedure  pCvdetail_ExposureCompensatorapply(const wrapper: PCvdetail_ExposureCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_ExposureCompensatorapplyV2(const wrapper: PCvdetail_ExposureCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvUMat_t; mask: PCvUMat_t); cdecl;
Function   pCvdetail_ExposureCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Procedure  pCvdetail_ExposureCompensatorfeed(const wrapper: PCvdetail_ExposureCompensator_t; corners: PCvvector_Point; 
                 images: PCvvector_UMat; masks: PCvvector_UMat); cdecl;
Procedure  pCvdetail_ExposureCompensatorgetMatGains(const wrapper: PCvdetail_ExposureCompensator_t; arg1: PCvvector_Mat); cdecl;
Function   pCvdetail_ExposureCompensatorgetUpdateGain(const wrapper: PCvdetail_ExposureCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_ExposureCompensatorsetMatGains(const wrapper: PCvdetail_ExposureCompensator_t; arg1: PCvvector_Mat); cdecl;
Procedure  pCvdetail_ExposureCompensatorsetUpdateGain(const wrapper: PCvdetail_ExposureCompensator_t; b: Boolean); cdecl;
Procedure  pCvdetail_FeatherBlenderblend(const wrapper: PCvdetail_FeatherBlender_t; dst: PCvMat_t; 
                 dst_mask: PCvMat_t); cdecl;
Procedure  pCvdetail_FeatherBlenderblendV2(const wrapper: PCvdetail_FeatherBlender_t; dst: PCvUMat_t; 
                 dst_mask: PCvUMat_t); cdecl;
Function   pCvdetail_FeatherBlendercreateDefault(_type: Integer; 
                 try_gpu: Boolean { default: false } = false): PCvPtr_Blender; cdecl;
Function   pCvdetail_FeatherBlendercreateWeightMaps(const wrapper: PCvdetail_FeatherBlender_t; masks: PCvvector_UMat; 
                 corners: PCvvector_Point; weight_maps: PCvvector_UMat): PCvRect_t; cdecl;
Procedure  pCvdetail_FeatherBlenderfeed(const wrapper: PCvdetail_FeatherBlender_t; img: PCvMat_t; 
                 mask: PCvMat_t; tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_FeatherBlenderfeedV2(const wrapper: PCvdetail_FeatherBlender_t; img: PCvUMat_t; 
                 mask: PCvUMat_t; tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_FeatherBlenderprepare(const wrapper: PCvdetail_FeatherBlender_t; dst_roi: PCvRect_t); cdecl;
Procedure  pCvdetail_FeatherBlendersetSharpness(const wrapper: PCvdetail_FeatherBlender_t; _val: Single); cdecl;
Function   pCvdetail_FeatherBlendersharpness(const wrapper: PCvdetail_FeatherBlender_t): Single; cdecl;
Procedure  pCvdetail_FeaturesMatcherapply(const wrapper: PCvdetail_FeaturesMatcher_t; features1: PCvdetail_ImageFeatures_t; 
                 features2: PCvdetail_ImageFeatures_t; matches_info: PCvdetail_MatchesInfo_t); cdecl;
Procedure  pCvdetail_FeaturesMatcherapply2(const wrapper: PCvdetail_FeaturesMatcher_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; mask: PCvUMat_t { default: cv::UMat() } = nil); cdecl;
Procedure  pCvdetail_FeaturesMatchercollectGarbage(const wrapper: PCvdetail_FeaturesMatcher_t); cdecl;
Function   pCvdetail_FeaturesMatcherisThreadSafe(const wrapper: PCvdetail_FeaturesMatcher_t): Boolean; cdecl;
Procedure  pCvdetail_GainCompensatorapply(const wrapper: PCvdetail_GainCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_GainCompensatorapplyV2(const wrapper: PCvdetail_GainCompensator_t; index: Integer; 
                 corner: PCvPoint_t; image: PCvUMat_t; mask: PCvUMat_t); cdecl;
Function   pCvdetail_GainCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Procedure  pCvdetail_GainCompensatorgetMatGains(const wrapper: PCvdetail_GainCompensator_t; umv: PCvvector_Mat); cdecl;
Function   pCvdetail_GainCompensatorgetNrFeeds(const wrapper: PCvdetail_GainCompensator_t): Integer; cdecl;
Function   pCvdetail_GainCompensatorgetSimilarityThreshold(const wrapper: PCvdetail_GainCompensator_t): Double; cdecl;
Function   pCvdetail_GainCompensatorgetUpdateGain(const wrapper: PCvdetail_GainCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_GainCompensatorsetMatGains(const wrapper: PCvdetail_GainCompensator_t; umv: PCvvector_Mat); cdecl;
Procedure  pCvdetail_GainCompensatorsetNrFeeds(const wrapper: PCvdetail_GainCompensator_t; nr_feeds: Integer); cdecl;
Procedure  pCvdetail_GainCompensatorsetSimilarityThreshold(const wrapper: PCvdetail_GainCompensator_t; similarity_threshold: Double); cdecl;
Procedure  pCvdetail_GainCompensatorsetUpdateGain(const wrapper: PCvdetail_GainCompensator_t; b: Boolean); cdecl;
Procedure  pCvdetail_GraphCutSeamFinderfind(const wrapper: PCvdetail_GraphCutSeamFinder_t; src: PCvvector_UMat; 
                 corners: PCvvector_Point; masks: PCvvector_UMat); cdecl;
Function   pCvdetail_HomographyBasedEstimatorapply(const wrapper: PCvdetail_HomographyBasedEstimator_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_ImageFeaturesgetKeypoints(const wrapper: PCvdetail_ImageFeatures_t): PCvvector_KeyPoint; cdecl;
Function   pCvdetail_ImageFeaturesGet_descriptors(const wrapper: PCvdetail_ImageFeatures_t): PCvUMat_t; cdecl;
Procedure  pCvdetail_ImageFeaturesSet_descriptors(const wrapper: PCvdetail_ImageFeatures_t; propval: PCvUMat_t); cdecl;
Function   pCvdetail_ImageFeaturesGet_img_idx(const wrapper: PCvdetail_ImageFeatures_t): Integer; cdecl;
Procedure  pCvdetail_ImageFeaturesSet_img_idx(const wrapper: PCvdetail_ImageFeatures_t; propval: Integer); cdecl;
Function   pCvdetail_ImageFeaturesGet_img_size(const wrapper: PCvdetail_ImageFeatures_t): PCvSize_t; cdecl;
Procedure  pCvdetail_ImageFeaturesSet_img_size(const wrapper: PCvdetail_ImageFeatures_t; propval: PCvSize_t); cdecl;
Function   pCvdetail_ImageFeaturesGet_keypoints(const wrapper: PCvdetail_ImageFeatures_t): PCvvector_KeyPoint; cdecl;
Procedure  pCvdetail_ImageFeaturesSet_keypoints(const wrapper: PCvdetail_ImageFeatures_t; propval: PCvvector_KeyPoint); cdecl;
Function   pCvdetail_MatchesInfogetInliers(const wrapper: PCvdetail_MatchesInfo_t): PCvvector_uchar; cdecl;
Function   pCvdetail_MatchesInfogetMatches(const wrapper: PCvdetail_MatchesInfo_t): PCvvector_DMatch; cdecl;
Function   pCvdetail_MatchesInfoGet_H(const wrapper: PCvdetail_MatchesInfo_t): PCvMat_t; cdecl;
Procedure  pCvdetail_MatchesInfoSet_H(const wrapper: PCvdetail_MatchesInfo_t; propval: PCvMat_t); cdecl;
Function   pCvdetail_MatchesInfoGet_confidence(const wrapper: PCvdetail_MatchesInfo_t): Double; cdecl;
Procedure  pCvdetail_MatchesInfoSet_confidence(const wrapper: PCvdetail_MatchesInfo_t; propval: Double); cdecl;
Function   pCvdetail_MatchesInfoGet_dst_img_idx(const wrapper: PCvdetail_MatchesInfo_t): Integer; cdecl;
Procedure  pCvdetail_MatchesInfoSet_dst_img_idx(const wrapper: PCvdetail_MatchesInfo_t; propval: Integer); cdecl;
Function   pCvdetail_MatchesInfoGet_inliers_mask(const wrapper: PCvdetail_MatchesInfo_t): PCvvector_uchar; cdecl;
Procedure  pCvdetail_MatchesInfoSet_inliers_mask(const wrapper: PCvdetail_MatchesInfo_t; propval: PCvvector_uchar); cdecl;
Function   pCvdetail_MatchesInfoGet_matches(const wrapper: PCvdetail_MatchesInfo_t): PCvvector_DMatch; cdecl;
Procedure  pCvdetail_MatchesInfoSet_matches(const wrapper: PCvdetail_MatchesInfo_t; propval: PCvvector_DMatch); cdecl;
Function   pCvdetail_MatchesInfoGet_num_inliers(const wrapper: PCvdetail_MatchesInfo_t): Integer; cdecl;
Procedure  pCvdetail_MatchesInfoSet_num_inliers(const wrapper: PCvdetail_MatchesInfo_t; propval: Integer); cdecl;
Function   pCvdetail_MatchesInfoGet_src_img_idx(const wrapper: PCvdetail_MatchesInfo_t): Integer; cdecl;
Procedure  pCvdetail_MatchesInfoSet_src_img_idx(const wrapper: PCvdetail_MatchesInfo_t; propval: Integer); cdecl;
Procedure  pCvdetail_MultiBandBlenderblend(const wrapper: PCvdetail_MultiBandBlender_t; dst: PCvMat_t; 
                 dst_mask: PCvMat_t); cdecl;
Procedure  pCvdetail_MultiBandBlenderblendV2(const wrapper: PCvdetail_MultiBandBlender_t; dst: PCvUMat_t; 
                 dst_mask: PCvUMat_t); cdecl;
Function   pCvdetail_MultiBandBlendercreateDefault(_type: Integer; 
                 try_gpu: Boolean { default: false } = false): PCvPtr_Blender; cdecl;
Procedure  pCvdetail_MultiBandBlenderfeed(const wrapper: PCvdetail_MultiBandBlender_t; img: PCvMat_t; 
                 mask: PCvMat_t; tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_MultiBandBlenderfeedV2(const wrapper: PCvdetail_MultiBandBlender_t; img: PCvUMat_t; 
                 mask: PCvUMat_t; tl: PCvPoint_t); cdecl;
Function   pCvdetail_MultiBandBlendernumBands(const wrapper: PCvdetail_MultiBandBlender_t): Integer; cdecl;
Procedure  pCvdetail_MultiBandBlenderprepare(const wrapper: PCvdetail_MultiBandBlender_t; dst_roi: PCvRect_t); cdecl;
Procedure  pCvdetail_MultiBandBlendersetNumBands(const wrapper: PCvdetail_MultiBandBlender_t; _val: Integer); cdecl;
Function   pCvdetail_NoBundleAdjusterapply(const wrapper: PCvdetail_NoBundleAdjuster_t; features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; cameras: PCvvector_CameraParams): Boolean; cdecl;
Function   pCvdetail_NoBundleAdjusterconfThresh(const wrapper: PCvdetail_NoBundleAdjuster_t): Double; cdecl;
Function   pCvdetail_NoBundleAdjusterrefinementMask(const wrapper: PCvdetail_NoBundleAdjuster_t): PCvMat_t; cdecl;
Procedure  pCvdetail_NoBundleAdjustersetConfThresh(const wrapper: PCvdetail_NoBundleAdjuster_t; conf_thresh: Double); cdecl;
Procedure  pCvdetail_NoBundleAdjustersetRefinementMask(const wrapper: PCvdetail_NoBundleAdjuster_t; mask: PCvMat_t); cdecl;
Procedure  pCvdetail_NoBundleAdjustersetTermCriteria(const wrapper: PCvdetail_NoBundleAdjuster_t; term_criteria: PCvTermCriteria_t); cdecl;
Function   pCvdetail_NoBundleAdjustertermCriteria(const wrapper: PCvdetail_NoBundleAdjuster_t): PCvTermCriteria_t; cdecl;
Procedure  pCvdetail_NoExposureCompensatorapply(const wrapper: PCvdetail_NoExposureCompensator_t; arg1: Integer; 
                 arg2: PCvPoint_t; arg3: PCvMat_t; arg4: PCvMat_t); cdecl;
Procedure  pCvdetail_NoExposureCompensatorapplyV2(const wrapper: PCvdetail_NoExposureCompensator_t; arg1: Integer; 
                 arg2: PCvPoint_t; arg3: PCvUMat_t; arg4: PCvUMat_t); cdecl;
Function   pCvdetail_NoExposureCompensatorcreateDefault(_type: Integer): PCvPtr_ExposureCompensator; cdecl;
Procedure  pCvdetail_NoExposureCompensatorgetMatGains(const wrapper: PCvdetail_NoExposureCompensator_t; umv: PCvvector_Mat); cdecl;
Function   pCvdetail_NoExposureCompensatorgetUpdateGain(const wrapper: PCvdetail_NoExposureCompensator_t): Boolean; cdecl;
Procedure  pCvdetail_NoExposureCompensatorsetMatGains(const wrapper: PCvdetail_NoExposureCompensator_t; umv: PCvvector_Mat); cdecl;
Procedure  pCvdetail_NoExposureCompensatorsetUpdateGain(const wrapper: PCvdetail_NoExposureCompensator_t; b: Boolean); cdecl;
Function   pCvdetail_NoSeamFindercreateDefault(_type: Integer): PCvPtr_SeamFinder; cdecl;
Procedure  pCvdetail_NoSeamFinderfind(const wrapper: PCvdetail_NoSeamFinder_t; arg1: PCvvector_UMat; 
                 arg2: PCvvector_Point; arg3: PCvvector_UMat); cdecl;
Function   pCvdetail_PairwiseSeamFindercreateDefault(_type: Integer): PCvPtr_SeamFinder; cdecl;
Procedure  pCvdetail_PairwiseSeamFinderfind(const wrapper: PCvdetail_PairwiseSeamFinder_t; src: PCvvector_UMat; 
                 corners: PCvvector_Point; masks: PCvvector_UMat); cdecl;
Function   pCvdetail_SeamFindercreateDefault(_type: Integer): PCvPtr_SeamFinder; cdecl;
Procedure  pCvdetail_SeamFinderfind(const wrapper: PCvdetail_SeamFinder_t; src: PCvvector_UMat; 
                 corners: PCvvector_Point; masks: PCvvector_UMat); cdecl;
Procedure  pCvdetail_SphericalProjectormapBackward(const wrapper: PCvdetail_SphericalProjector_t; u: Single; 
                 v: Single; x: Single; y: Single); cdecl;
Procedure  pCvdetail_SphericalProjectormapForward(const wrapper: PCvdetail_SphericalProjector_t; x: Single; 
                 y: Single; u: Single; v: Single); cdecl;
Function   pCvdetail_TimelapsercreateDefault(_type: Integer): PCvPtr_Timelapser; cdecl;
Function   pCvdetail_TimelapsergetDst(const wrapper: PCvdetail_Timelapser_t): PCvUMat_t; cdecl;
Procedure  pCvdetail_Timelapserinitialize(const wrapper: PCvdetail_Timelapser_t; corners: PCvvector_Point; 
                 sizes: PCvvector_Size); cdecl;
Procedure  pCvdetail_Timelapserprocess(const wrapper: PCvdetail_Timelapser_t; img: PCvMat_t; 
                 mask: PCvMat_t; tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_TimelapserprocessV2(const wrapper: PCvdetail_Timelapser_t; img: PCvUMat_t; 
                 mask: PCvUMat_t; tl: PCvPoint_t); cdecl;
Function   pCvdetail_TimelapserCropcreateDefault(_type: Integer): PCvPtr_Timelapser; cdecl;
Function   pCvdetail_TimelapserCropgetDst(const wrapper: PCvdetail_TimelapserCrop_t): PCvUMat_t; cdecl;
Procedure  pCvdetail_TimelapserCropinitialize(const wrapper: PCvdetail_TimelapserCrop_t; corners: PCvvector_Point; 
                 sizes: PCvvector_Size); cdecl;
Procedure  pCvdetail_TimelapserCropprocess(const wrapper: PCvdetail_TimelapserCrop_t; img: PCvMat_t; 
                 mask: PCvMat_t; tl: PCvPoint_t); cdecl;
Procedure  pCvdetail_TimelapserCropprocessV2(const wrapper: PCvdetail_TimelapserCrop_t; img: PCvUMat_t; 
                 mask: PCvUMat_t; tl: PCvPoint_t); cdecl;
Function   pCvdetail_VoronoiSeamFindercreateDefault(_type: Integer): PCvPtr_SeamFinder; cdecl;
Procedure  pCvdetail_VoronoiSeamFinderfind(const wrapper: PCvdetail_VoronoiSeamFinder_t; src: PCvvector_UMat; 
                 corners: PCvvector_Point; masks: PCvvector_UMat); cdecl;
Procedure  pCvdnn_ClassificationModelclassify(const wrapper: PCvdnn_ClassificationModel_t; frame: PCvMat_t; 
                 classId: Integer; conf: Single); cdecl;
Procedure  pCvdnn_ClassificationModelclassifyV2(const wrapper: PCvdnn_ClassificationModel_t; frame: PCvUMat_t; 
                 classId: Integer; conf: Single); cdecl;
Function   pCvdnn_ClassificationModelgetEnableSoftmaxPostProcessing(const wrapper: PCvdnn_ClassificationModel_t): Boolean; cdecl;
Procedure  pCvdnn_ClassificationModelpredict(const wrapper: PCvdnn_ClassificationModel_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_ClassificationModelpredictV2(const wrapper: PCvdnn_ClassificationModel_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_ClassificationModelsetEnableSoftmaxPostProcessing(const wrapper: PCvdnn_ClassificationModel_t; enable: Boolean): PCvdnn_ClassificationModel_t; cdecl;
Function   pCvdnn_ClassificationModelsetInputCrop(const wrapper: PCvdnn_ClassificationModel_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ClassificationModelsetInputMean(const wrapper: PCvdnn_ClassificationModel_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_ClassificationModelsetInputParams(const wrapper: PCvdnn_ClassificationModel_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_ClassificationModelsetInputScale(const wrapper: PCvdnn_ClassificationModel_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ClassificationModelsetInputSize(const wrapper: PCvdnn_ClassificationModel_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ClassificationModelsetInputSizeV2(const wrapper: PCvdnn_ClassificationModel_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ClassificationModelsetInputSwapRB(const wrapper: PCvdnn_ClassificationModel_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ClassificationModelsetPreferableBackend(const wrapper: PCvdnn_ClassificationModel_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ClassificationModelsetPreferableTarget(const wrapper: PCvdnn_ClassificationModel_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_DetectionModeldetect(const wrapper: PCvdnn_DetectionModel_t; frame: PCvMat_t; 
                 classIds: PCvvector_int; confidences: PCvvector_float; boxes: PCvvector_Rect; 
                 confThreshold: Single { default: 0.5f } = 0.5; nmsThreshold: Single { default: 0.0f } = 0.0); cdecl;
Procedure  pCvdnn_DetectionModeldetectV2(const wrapper: PCvdnn_DetectionModel_t; frame: PCvUMat_t; 
                 classIds: PCvvector_int; confidences: PCvvector_float; boxes: PCvvector_Rect; 
                 confThreshold: Single { default: 0.5f } = 0.5; nmsThreshold: Single { default: 0.0f } = 0.0); cdecl;
Function   pCvdnn_DetectionModelgetNmsAcrossClasses(const wrapper: PCvdnn_DetectionModel_t): Boolean; cdecl;
Procedure  pCvdnn_DetectionModelpredict(const wrapper: PCvdnn_DetectionModel_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_DetectionModelpredictV2(const wrapper: PCvdnn_DetectionModel_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_DetectionModelsetInputCrop(const wrapper: PCvdnn_DetectionModel_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DetectionModelsetInputMean(const wrapper: PCvdnn_DetectionModel_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_DetectionModelsetInputParams(const wrapper: PCvdnn_DetectionModel_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_DetectionModelsetInputScale(const wrapper: PCvdnn_DetectionModel_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DetectionModelsetInputSize(const wrapper: PCvdnn_DetectionModel_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DetectionModelsetInputSizeV2(const wrapper: PCvdnn_DetectionModel_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DetectionModelsetInputSwapRB(const wrapper: PCvdnn_DetectionModel_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DetectionModelsetNmsAcrossClasses(const wrapper: PCvdnn_DetectionModel_t; value: Boolean): PCvdnn_DetectionModel_t; cdecl;
Function   pCvdnn_DetectionModelsetPreferableBackend(const wrapper: PCvdnn_DetectionModel_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DetectionModelsetPreferableTarget(const wrapper: PCvdnn_DetectionModel_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Function   pCvdnn_DictValuegetIntValue(const wrapper: PCvdnn_DictValue_t; idx: Integer { default: -1 } = ord(-1)): Integer; cdecl;
Function   pCvdnn_DictValuegetRealValue(const wrapper: PCvdnn_DictValue_t; idx: Integer { default: -1 } = ord(-1)): Double; cdecl;
Function   pCvdnn_DictValuegetStringValue(const wrapper: PCvdnn_DictValue_t; idx: Integer { default: -1 } = ord(-1)): PCvString_t; cdecl;
Function   pCvdnn_DictValueisInt(const wrapper: PCvdnn_DictValue_t): Boolean; cdecl;
Function   pCvdnn_DictValueisReal(const wrapper: PCvdnn_DictValue_t): Boolean; cdecl;
Function   pCvdnn_DictValueisString(const wrapper: PCvdnn_DictValue_t): Boolean; cdecl;
Function   pCvdnn_KeypointsModelestimate(const wrapper: PCvdnn_KeypointsModel_t; frame: PCvMat_t; 
                 thresh: Single { default: 0.5 } = 0.5): PCvvector_Point2f; cdecl;
Function   pCvdnn_KeypointsModelestimateV2(const wrapper: PCvdnn_KeypointsModel_t; frame: PCvUMat_t; 
                 thresh: Single { default: 0.5 } = 0.5): PCvvector_Point2f; cdecl;
Procedure  pCvdnn_KeypointsModelpredict(const wrapper: PCvdnn_KeypointsModel_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_KeypointsModelpredictV2(const wrapper: PCvdnn_KeypointsModel_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_KeypointsModelsetInputCrop(const wrapper: PCvdnn_KeypointsModel_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_KeypointsModelsetInputMean(const wrapper: PCvdnn_KeypointsModel_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_KeypointsModelsetInputParams(const wrapper: PCvdnn_KeypointsModel_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_KeypointsModelsetInputScale(const wrapper: PCvdnn_KeypointsModel_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_KeypointsModelsetInputSize(const wrapper: PCvdnn_KeypointsModel_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_KeypointsModelsetInputSizeV2(const wrapper: PCvdnn_KeypointsModel_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_KeypointsModelsetInputSwapRB(const wrapper: PCvdnn_KeypointsModel_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_KeypointsModelsetPreferableBackend(const wrapper: PCvdnn_KeypointsModel_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_KeypointsModelsetPreferableTarget(const wrapper: PCvdnn_KeypointsModel_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_Layerclear(const wrapper: PCvdnn_Layer_t); cdecl;
Function   pCvdnn_Layerempty(const wrapper: PCvdnn_Layer_t): Boolean; cdecl;
Function   pCvdnn_LayergetDefaultName(const wrapper: PCvdnn_Layer_t): PCvString_t; cdecl;
Function   pCvdnn_LayeroutputNameToIndex(const wrapper: PCvdnn_Layer_t; outputName: PCvString_t): Integer; cdecl;
Procedure  pCvdnn_Layerread(const wrapper: PCvdnn_Layer_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvdnn_Layersave(const wrapper: PCvdnn_Layer_t; filename: PCvString_t); cdecl;
Procedure  pCvdnn_Layerwrite(const wrapper: PCvdnn_Layer_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvdnn_LayerGet_blobs(const wrapper: PCvdnn_Layer_t): PCvvector_Mat; cdecl;
Procedure  pCvdnn_LayerSet_blobs(const wrapper: PCvdnn_Layer_t; propval: PCvvector_Mat); cdecl;
Function   pCvdnn_LayerGet_name(const wrapper: PCvdnn_Layer_t): PCvString_t; cdecl;
Function   pCvdnn_LayerGet_preferableTarget(const wrapper: PCvdnn_Layer_t): Integer; cdecl;
Function   pCvdnn_LayerGet_type(const wrapper: PCvdnn_Layer_t): PCvString_t; cdecl;
Procedure  pCvdnn_Modelpredict(const wrapper: PCvdnn_Model_t; frame: PCvMat_t; outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_ModelpredictV2(const wrapper: PCvdnn_Model_t; frame: PCvUMat_t; outs: PCvvector_UMat); cdecl;
Function   pCvdnn_ModelsetInputCrop(const wrapper: PCvdnn_Model_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelsetInputMean(const wrapper: PCvdnn_Model_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_ModelsetInputParams(const wrapper: PCvdnn_Model_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_ModelsetInputScale(const wrapper: PCvdnn_Model_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelsetInputSize(const wrapper: PCvdnn_Model_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelsetInputSizeV2(const wrapper: PCvdnn_Model_t; width: Integer; height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelsetInputSwapRB(const wrapper: PCvdnn_Model_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelsetPreferableBackend(const wrapper: PCvdnn_Model_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_ModelsetPreferableTarget(const wrapper: PCvdnn_Model_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_Netconnect(const wrapper: PCvdnn_Net_t; outPin: PCvString_t; inpPin: PCvString_t); cdecl;
Function   pCvdnn_Netdump(const wrapper: PCvdnn_Net_t): PCvString_t; cdecl;
Procedure  pCvdnn_NetdumpToFile(const wrapper: PCvdnn_Net_t; path: PCvString_t); cdecl;
Function   pCvdnn_Netempty(const wrapper: PCvdnn_Net_t): Boolean; cdecl;
Procedure  pCvdnn_NetenableFusion(const wrapper: PCvdnn_Net_t; fusion: Boolean); cdecl;
Function   pCvdnn_Netforward(const wrapper: PCvdnn_Net_t; outputName: PCvString_t { default: String() } = nil): PCvMat_t; cdecl;
Procedure  pCvdnn_NetforwardV2(const wrapper: PCvdnn_Net_t; outputBlobs: PCvvector_Mat; 
                 outputName: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvdnn_NetforwardV3(const wrapper: PCvdnn_Net_t; outputBlobs: PCvvector_UMat; 
                 outputName: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvdnn_NetforwardV4(const wrapper: PCvdnn_Net_t; outputBlobs: PCvvector_Mat; 
                 outBlobNames: PCvvector_String); cdecl;
Procedure  pCvdnn_NetforwardV5(const wrapper: PCvdnn_Net_t; outputBlobs: PCvvector_UMat; 
                 outBlobNames: PCvvector_String); cdecl;
Procedure  pCvdnn_NetforwardAndRetrieve(const wrapper: PCvdnn_Net_t; outputBlobs: PCvvector_vector_Mat; 
                 outBlobNames: PCvvector_String); cdecl;
Function   pCvdnn_NetforwardAsync(const wrapper: PCvdnn_Net_t; outputName: PCvString_t { default: String() } = nil): PCvAsyncArray_t; cdecl;
Function   pCvdnn_NetgetFLOPS(const wrapper: PCvdnn_Net_t; netInputShapes: PCvvector_MatShape): Int64; cdecl;
Function   pCvdnn_NetgetFLOPSV2(const wrapper: PCvdnn_Net_t; netInputShape: PCvMatShape): Int64; cdecl;
Function   pCvdnn_NetgetFLOPSV3(const wrapper: PCvdnn_Net_t; layerId: Integer; 
                 netInputShapes: PCvvector_MatShape): Int64; cdecl;
Function   pCvdnn_NetgetFLOPSV4(const wrapper: PCvdnn_Net_t; layerId: Integer; 
                 netInputShape: PCvMatShape): Int64; cdecl;
Procedure  pCvdnn_NetgetInputDetails(const wrapper: PCvdnn_Net_t; scales: PCvvector_float; 
                 zeropoints: PCvvector_int); cdecl;
Function   pCvdnn_NetgetLayer(const wrapper: PCvdnn_Net_t; layerId: Integer): PCvPtr_Layer; cdecl;
Function   pCvdnn_NetgetLayerV2(const wrapper: PCvdnn_Net_t; layerName: PCvString_t): PCvPtr_Layer; cdecl;
Function   pCvdnn_NetgetLayerV3(const wrapper: PCvdnn_Net_t; layerId: PCvLayerId_t): PCvPtr_Layer; cdecl;
Function   pCvdnn_NetgetLayerId(const wrapper: PCvdnn_Net_t; layer: PCvString_t): Integer; cdecl;
Function   pCvdnn_NetgetLayerNames(const wrapper: PCvdnn_Net_t): PCvvector_String; cdecl;
Procedure  pCvdnn_NetgetLayerTypes(const wrapper: PCvdnn_Net_t; layersTypes: PCvvector_String); cdecl;
Function   pCvdnn_NetgetLayersCount(const wrapper: PCvdnn_Net_t; layerType: PCvString_t): Integer; cdecl;
Procedure  pCvdnn_NetgetLayersShapes(const wrapper: PCvdnn_Net_t; netInputShapes: PCvvector_MatShape; 
                 layersIds: PCvvector_int; inLayersShapes: PCvvector_vector_MatShape; 
                 outLayersShapes: PCvvector_vector_MatShape); cdecl;
Procedure  pCvdnn_NetgetLayersShapesV2(const wrapper: PCvdnn_Net_t; netInputShape: PCvMatShape; 
                 layersIds: PCvvector_int; inLayersShapes: PCvvector_vector_MatShape; 
                 outLayersShapes: PCvvector_vector_MatShape); cdecl;
Procedure  pCvdnn_NetgetMemoryConsumption(const wrapper: PCvdnn_Net_t; netInputShape: PCvMatShape; 
                 weights: UInt64; blobs: UInt64); cdecl;
Procedure  pCvdnn_NetgetMemoryConsumptionV2(const wrapper: PCvdnn_Net_t; layerId: Integer; 
                 netInputShapes: PCvvector_MatShape; weights: UInt64; blobs: UInt64); cdecl;
Procedure  pCvdnn_NetgetMemoryConsumptionV3(const wrapper: PCvdnn_Net_t; layerId: Integer; 
                 netInputShape: PCvMatShape; weights: UInt64; blobs: UInt64); cdecl;
Procedure  pCvdnn_NetgetOutputDetails(const wrapper: PCvdnn_Net_t; scales: PCvvector_float; 
                 zeropoints: PCvvector_int); cdecl;
Function   pCvdnn_NetgetParam(const wrapper: PCvdnn_Net_t; layer: Integer; 
                 numParam: Integer { default: 0 } = 0): PCvMat_t; cdecl;
Function   pCvdnn_NetgetParamV2(const wrapper: PCvdnn_Net_t; layerName: PCvString_t; 
                 numParam: Integer { default: 0 } = 0): PCvMat_t; cdecl;
Function   pCvdnn_NetgetPerfProfile(const wrapper: PCvdnn_Net_t; timings: PCvvector_double): Int64; cdecl;
Function   pCvdnn_NetgetUnconnectedOutLayers(const wrapper: PCvdnn_Net_t): PCvvector_int; cdecl;
Function   pCvdnn_NetgetUnconnectedOutLayersNames(const wrapper: PCvdnn_Net_t): PCvvector_String; cdecl;
Function   pCvdnn_Netquantize(const wrapper: PCvdnn_Net_t; calibData: PCvvector_Mat; 
                 inputsDtype: Integer; outputsDtype: Integer): PCvdnn_Net_t; cdecl;
Function   pCvdnn_NetquantizeV2(const wrapper: PCvdnn_Net_t; calibData: PCvvector_UMat; 
                 inputsDtype: Integer; outputsDtype: Integer): PCvdnn_Net_t; cdecl;
Function   pCvdnn_NetreadFromModelOptimizer(xml: PCvString_t; bin: PCvString_t): PCvdnn_Net_t; cdecl;
Function   pCvdnn_NetreadFromModelOptimizerV2(bufferModelConfig: PCvvector_uchar; 
                 bufferWeights: PCvvector_uchar): PCvdnn_Net_t; cdecl;
Procedure  pCvdnn_NetsetHalideScheduler(const wrapper: PCvdnn_Net_t; scheduler: PCvString_t); cdecl;
Procedure  pCvdnn_NetsetInput(const wrapper: PCvdnn_Net_t; blob: PCvMat_t; 
                 name: PCvString_t { default: "" } = nil; scalefactor: Double { default: 1.0 } = 1.0; 
                 mean: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvdnn_NetsetInputV2(const wrapper: PCvdnn_Net_t; blob: PCvUMat_t; 
                 name: PCvString_t { default: "" } = nil; scalefactor: Double { default: 1.0 } = 1.0; 
                 mean: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvdnn_NetsetInputShape(const wrapper: PCvdnn_Net_t; inputName: PCvString_t; 
                 shape: PCvMatShape); cdecl;
Procedure  pCvdnn_NetsetInputsNames(const wrapper: PCvdnn_Net_t; inputBlobNames: PCvvector_String); cdecl;
Procedure  pCvdnn_NetsetParam(const wrapper: PCvdnn_Net_t; layer: Integer; numParam: Integer; 
                 blob: PCvMat_t); cdecl;
Procedure  pCvdnn_NetsetParamV2(const wrapper: PCvdnn_Net_t; layerName: PCvString_t; numParam: Integer; 
                 blob: PCvMat_t); cdecl;
Procedure  pCvdnn_NetsetPreferableBackend(const wrapper: PCvdnn_Net_t; backendId: Integer); cdecl;
Procedure  pCvdnn_NetsetPreferableTarget(const wrapper: PCvdnn_Net_t; targetId: Integer); cdecl;
Procedure  pCvdnn_SegmentationModelpredict(const wrapper: PCvdnn_SegmentationModel_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_SegmentationModelpredictV2(const wrapper: PCvdnn_SegmentationModel_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Procedure  pCvdnn_SegmentationModelsegment(const wrapper: PCvdnn_SegmentationModel_t; frame: PCvMat_t; 
                 mask: PCvMat_t); cdecl;
Procedure  pCvdnn_SegmentationModelsegmentV2(const wrapper: PCvdnn_SegmentationModel_t; frame: PCvUMat_t; 
                 mask: PCvUMat_t); cdecl;
Function   pCvdnn_SegmentationModelsetInputCrop(const wrapper: PCvdnn_SegmentationModel_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_SegmentationModelsetInputMean(const wrapper: PCvdnn_SegmentationModel_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_SegmentationModelsetInputParams(const wrapper: PCvdnn_SegmentationModel_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_SegmentationModelsetInputScale(const wrapper: PCvdnn_SegmentationModel_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_SegmentationModelsetInputSize(const wrapper: PCvdnn_SegmentationModel_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_SegmentationModelsetInputSizeV2(const wrapper: PCvdnn_SegmentationModel_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_SegmentationModelsetInputSwapRB(const wrapper: PCvdnn_SegmentationModel_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_SegmentationModelsetPreferableBackend(const wrapper: PCvdnn_SegmentationModel_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_SegmentationModelsetPreferableTarget(const wrapper: PCvdnn_SegmentationModel_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_TextDetectionModeldetect(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvMat_t; 
                 detections: PCvvector_vector_Point; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectV2(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvUMat_t; 
                 detections: PCvvector_vector_Point; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectV3(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvMat_t; 
                 detections: PCvvector_vector_Point); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectV4(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvUMat_t; 
                 detections: PCvvector_vector_Point); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectTextRectangles(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvMat_t; 
                 detections: PCvvector_RotatedRect; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectTextRectanglesV2(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvUMat_t; 
                 detections: PCvvector_RotatedRect; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectTextRectanglesV3(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvMat_t; 
                 detections: PCvvector_RotatedRect); cdecl;
Procedure  pCvdnn_TextDetectionModeldetectTextRectanglesV4(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvUMat_t; 
                 detections: PCvvector_RotatedRect); cdecl;
Procedure  pCvdnn_TextDetectionModelpredict(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_TextDetectionModelpredictV2(const wrapper: PCvdnn_TextDetectionModel_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_TextDetectionModelsetInputCrop(const wrapper: PCvdnn_TextDetectionModel_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModelsetInputMean(const wrapper: PCvdnn_TextDetectionModel_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_TextDetectionModelsetInputParams(const wrapper: PCvdnn_TextDetectionModel_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_TextDetectionModelsetInputScale(const wrapper: PCvdnn_TextDetectionModel_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModelsetInputSize(const wrapper: PCvdnn_TextDetectionModel_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModelsetInputSizeV2(const wrapper: PCvdnn_TextDetectionModel_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModelsetInputSwapRB(const wrapper: PCvdnn_TextDetectionModel_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModelsetPreferableBackend(const wrapper: PCvdnn_TextDetectionModel_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModelsetPreferableTarget(const wrapper: PCvdnn_TextDetectionModel_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetect(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvMat_t; 
                 detections: PCvvector_vector_Point; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectV2(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvUMat_t; 
                 detections: PCvvector_vector_Point; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectV3(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvMat_t; 
                 detections: PCvvector_vector_Point); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectV4(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvUMat_t; 
                 detections: PCvvector_vector_Point); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectTextRectangles(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvMat_t; 
                 detections: PCvvector_RotatedRect; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectTextRectanglesV2(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvUMat_t; 
                 detections: PCvvector_RotatedRect; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectTextRectanglesV3(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvMat_t; 
                 detections: PCvvector_RotatedRect); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBdetectTextRectanglesV4(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvUMat_t; 
                 detections: PCvvector_RotatedRect); cdecl;
Function   pCvdnn_TextDetectionModel_DBgetBinaryThreshold(const wrapper: PCvdnn_TextDetectionModel_DB_t): Single; cdecl;
Function   pCvdnn_TextDetectionModel_DBgetMaxCandidates(const wrapper: PCvdnn_TextDetectionModel_DB_t): Integer; cdecl;
Function   pCvdnn_TextDetectionModel_DBgetPolygonThreshold(const wrapper: PCvdnn_TextDetectionModel_DB_t): Single; cdecl;
Function   pCvdnn_TextDetectionModel_DBgetUnclipRatio(const wrapper: PCvdnn_TextDetectionModel_DB_t): Double; cdecl;
Procedure  pCvdnn_TextDetectionModel_DBpredict(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_TextDetectionModel_DBpredictV2(const wrapper: PCvdnn_TextDetectionModel_DB_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_TextDetectionModel_DBsetBinaryThreshold(const wrapper: PCvdnn_TextDetectionModel_DB_t; binaryThreshold: Single): PCvdnn_TextDetectionModel_DB_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetInputCrop(const wrapper: PCvdnn_TextDetectionModel_DB_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetInputMean(const wrapper: PCvdnn_TextDetectionModel_DB_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_TextDetectionModel_DBsetInputParams(const wrapper: PCvdnn_TextDetectionModel_DB_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_TextDetectionModel_DBsetInputScale(const wrapper: PCvdnn_TextDetectionModel_DB_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetInputSize(const wrapper: PCvdnn_TextDetectionModel_DB_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetInputSizeV2(const wrapper: PCvdnn_TextDetectionModel_DB_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetInputSwapRB(const wrapper: PCvdnn_TextDetectionModel_DB_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetMaxCandidates(const wrapper: PCvdnn_TextDetectionModel_DB_t; maxCandidates: Integer): PCvdnn_TextDetectionModel_DB_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetPolygonThreshold(const wrapper: PCvdnn_TextDetectionModel_DB_t; polygonThreshold: Single): PCvdnn_TextDetectionModel_DB_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetPreferableBackend(const wrapper: PCvdnn_TextDetectionModel_DB_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetPreferableTarget(const wrapper: PCvdnn_TextDetectionModel_DB_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_DBsetUnclipRatio(const wrapper: PCvdnn_TextDetectionModel_DB_t; unclipRatio: Double): PCvdnn_TextDetectionModel_DB_t; cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetect(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvMat_t; 
                 detections: PCvvector_vector_Point; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectV2(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvUMat_t; 
                 detections: PCvvector_vector_Point; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectV3(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvMat_t; 
                 detections: PCvvector_vector_Point); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectV4(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvUMat_t; 
                 detections: PCvvector_vector_Point); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectTextRectangles(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvMat_t; 
                 detections: PCvvector_RotatedRect; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectTextRectanglesV2(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvUMat_t; 
                 detections: PCvvector_RotatedRect; confidences: PCvvector_float); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectTextRectanglesV3(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvMat_t; 
                 detections: PCvvector_RotatedRect); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTdetectTextRectanglesV4(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvUMat_t; 
                 detections: PCvvector_RotatedRect); cdecl;
Function   pCvdnn_TextDetectionModel_EASTgetConfidenceThreshold(const wrapper: PCvdnn_TextDetectionModel_EAST_t): Single; cdecl;
Function   pCvdnn_TextDetectionModel_EASTgetNMSThreshold(const wrapper: PCvdnn_TextDetectionModel_EAST_t): Single; cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTpredict(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTpredictV2(const wrapper: PCvdnn_TextDetectionModel_EAST_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetConfidenceThreshold(const wrapper: PCvdnn_TextDetectionModel_EAST_t; confThreshold: Single): PCvdnn_TextDetectionModel_EAST_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetInputCrop(const wrapper: PCvdnn_TextDetectionModel_EAST_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetInputMean(const wrapper: PCvdnn_TextDetectionModel_EAST_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_TextDetectionModel_EASTsetInputParams(const wrapper: PCvdnn_TextDetectionModel_EAST_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetInputScale(const wrapper: PCvdnn_TextDetectionModel_EAST_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetInputSize(const wrapper: PCvdnn_TextDetectionModel_EAST_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetInputSizeV2(const wrapper: PCvdnn_TextDetectionModel_EAST_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetInputSwapRB(const wrapper: PCvdnn_TextDetectionModel_EAST_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetNMSThreshold(const wrapper: PCvdnn_TextDetectionModel_EAST_t; nmsThreshold: Single): PCvdnn_TextDetectionModel_EAST_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetPreferableBackend(const wrapper: PCvdnn_TextDetectionModel_EAST_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextDetectionModel_EASTsetPreferableTarget(const wrapper: PCvdnn_TextDetectionModel_EAST_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelgetDecodeType(const wrapper: PCvdnn_TextRecognitionModel_t): PCvString_t; cdecl;
Function   pCvdnn_TextRecognitionModelgetVocabulary(const wrapper: PCvdnn_TextRecognitionModel_t): PCvvector_string; cdecl;
Procedure  pCvdnn_TextRecognitionModelpredict(const wrapper: PCvdnn_TextRecognitionModel_t; frame: PCvMat_t; 
                 outs: PCvvector_Mat); cdecl;
Procedure  pCvdnn_TextRecognitionModelpredictV2(const wrapper: PCvdnn_TextRecognitionModel_t; frame: PCvUMat_t; 
                 outs: PCvvector_UMat); cdecl;
Function   pCvdnn_TextRecognitionModelrecognize(const wrapper: PCvdnn_TextRecognitionModel_t; frame: PCvMat_t): PCvString_t; cdecl;
Function   pCvdnn_TextRecognitionModelrecognizeV2(const wrapper: PCvdnn_TextRecognitionModel_t; frame: PCvUMat_t): PCvString_t; cdecl;
Procedure  pCvdnn_TextRecognitionModelrecognizeV3(const wrapper: PCvdnn_TextRecognitionModel_t; frame: PCvMat_t; 
                 roiRects: PCvvector_Mat; results: PCvvector_string); cdecl;
Procedure  pCvdnn_TextRecognitionModelrecognizeV4(const wrapper: PCvdnn_TextRecognitionModel_t; frame: PCvUMat_t; 
                 roiRects: PCvvector_UMat; results: PCvvector_string); cdecl;
Function   pCvdnn_TextRecognitionModelsetDecodeOptsCTCPrefixBeamSearch(const wrapper: PCvdnn_TextRecognitionModel_t; beamSize: Integer; 
                 vocPruneSize: Integer { default: 0 } = 0): PCvdnn_TextRecognitionModel_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetDecodeType(const wrapper: PCvdnn_TextRecognitionModel_t; decodeType: PCvString_t): PCvdnn_TextRecognitionModel_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetInputCrop(const wrapper: PCvdnn_TextRecognitionModel_t; crop: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetInputMean(const wrapper: PCvdnn_TextRecognitionModel_t; mean: PCvScalar_t): PCvdnn_Model_t; cdecl;
Procedure  pCvdnn_TextRecognitionModelsetInputParams(const wrapper: PCvdnn_TextRecognitionModel_t; scale: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false); cdecl;
Function   pCvdnn_TextRecognitionModelsetInputScale(const wrapper: PCvdnn_TextRecognitionModel_t; scale: Double): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetInputSize(const wrapper: PCvdnn_TextRecognitionModel_t; size: PCvSize_t): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetInputSizeV2(const wrapper: PCvdnn_TextRecognitionModel_t; width: Integer; 
                 height: Integer): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetInputSwapRB(const wrapper: PCvdnn_TextRecognitionModel_t; swapRB: Boolean): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetPreferableBackend(const wrapper: PCvdnn_TextRecognitionModel_t; backendId: TCvdnn_Backend): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetPreferableTarget(const wrapper: PCvdnn_TextRecognitionModel_t; targetId: TCvdnn_Target): PCvdnn_Model_t; cdecl;
Function   pCvdnn_TextRecognitionModelsetVocabulary(const wrapper: PCvdnn_TextRecognitionModel_t; vocabulary: PCvvector_string): PCvdnn_TextRecognitionModel_t; cdecl;
Procedure  pCvflann_Indexbuild(const wrapper: PCvflann_Index_t; features: PCvMat_t; 
                 params: PCvIndexParams_t; 
                 distType: TCvcvflann_flann_distance_t { default: cvflann::FLANN_DIST_L2 } = TCvcvflann_flann_distance_t.FLANN_DIST_L2); cdecl;
Procedure  pCvflann_IndexbuildV2(const wrapper: PCvflann_Index_t; features: PCvUMat_t; 
                 params: PCvIndexParams_t; 
                 distType: TCvcvflann_flann_distance_t { default: cvflann::FLANN_DIST_L2 } = TCvcvflann_flann_distance_t.FLANN_DIST_L2); cdecl;
Function   pCvflann_IndexgetAlgorithm(const wrapper: PCvflann_Index_t): TCvcvflann_flann_algorithm_t; cdecl;
Function   pCvflann_IndexgetDistance(const wrapper: PCvflann_Index_t): TCvcvflann_flann_distance_t; cdecl;
Procedure  pCvflann_IndexknnSearch(const wrapper: PCvflann_Index_t; query: PCvMat_t; indices: PCvMat_t; 
                 dists: PCvMat_t; knn: Integer; 
                 params: PCvSearchParams_t { default: flann::SearchParams() } = nil); cdecl;
Procedure  pCvflann_IndexknnSearchV2(const wrapper: PCvflann_Index_t; query: PCvUMat_t; 
                 indices: PCvUMat_t; dists: PCvUMat_t; knn: Integer; 
                 params: PCvSearchParams_t { default: flann::SearchParams() } = nil); cdecl;
Function   pCvflann_Indexload(const wrapper: PCvflann_Index_t; features: PCvMat_t; filename: PCvString_t): Boolean; cdecl;
Function   pCvflann_IndexloadV2(const wrapper: PCvflann_Index_t; features: PCvUMat_t; 
                 filename: PCvString_t): Boolean; cdecl;
Function   pCvflann_IndexradiusSearch(const wrapper: PCvflann_Index_t; query: PCvMat_t; 
                 indices: PCvMat_t; dists: PCvMat_t; radius: Double; maxResults: Integer; 
                 params: PCvSearchParams_t { default: flann::SearchParams() } = nil): Integer; cdecl;
Function   pCvflann_IndexradiusSearchV2(const wrapper: PCvflann_Index_t; query: PCvUMat_t; 
                 indices: PCvUMat_t; dists: PCvUMat_t; radius: Double; maxResults: Integer; 
                 params: PCvSearchParams_t { default: flann::SearchParams() } = nil): Integer; cdecl;
Procedure  pCvflann_Indexrelease(const wrapper: PCvflann_Index_t); cdecl;
Procedure  pCvflann_Indexsave(const wrapper: PCvflann_Index_t; filename: PCvString_t); cdecl;
Function   pCvml_ANN_MLPcalcError(const wrapper: PCvml_ANN_MLP_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_ANN_MLPcalcErrorV2(const wrapper: PCvml_ANN_MLP_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_ANN_MLPclear(const wrapper: PCvml_ANN_MLP_t); cdecl;
Function   pCvml_ANN_MLP_create(): PCvPtr_ANN_MLP; cdecl;
Function   pCvml_ANN_MLPempty(const wrapper: PCvml_ANN_MLP_t): Boolean; cdecl;
Function   pCvml_ANN_MLPgetAnnealCoolingRatio(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetAnnealFinalT(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetAnnealInitialT(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetAnnealItePerStep(const wrapper: PCvml_ANN_MLP_t): Integer; cdecl;
Function   pCvml_ANN_MLPgetBackpropMomentumScale(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetBackpropWeightScale(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetDefaultName(const wrapper: PCvml_ANN_MLP_t): PCvString_t; cdecl;
Function   pCvml_ANN_MLPgetLayerSizes(const wrapper: PCvml_ANN_MLP_t): PCvMat_t; cdecl;
Function   pCvml_ANN_MLPgetRpropDW0(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetRpropDWMax(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetRpropDWMin(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetRpropDWMinus(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetRpropDWPlus(const wrapper: PCvml_ANN_MLP_t): Double; cdecl;
Function   pCvml_ANN_MLPgetTermCriteria(const wrapper: PCvml_ANN_MLP_t): PCvTermCriteria_t; cdecl;
Function   pCvml_ANN_MLPgetTrainMethod(const wrapper: PCvml_ANN_MLP_t): Integer; cdecl;
Function   pCvml_ANN_MLPgetVarCount(const wrapper: PCvml_ANN_MLP_t): Integer; cdecl;
Function   pCvml_ANN_MLPgetWeights(const wrapper: PCvml_ANN_MLP_t; layerIdx: Integer): PCvMat_t; cdecl;
Function   pCvml_ANN_MLPisClassifier(const wrapper: PCvml_ANN_MLP_t): Boolean; cdecl;
Function   pCvml_ANN_MLPisTrained(const wrapper: PCvml_ANN_MLP_t): Boolean; cdecl;
Function   pCvml_ANN_MLPload(filepath: PCvString_t): PCvPtr_ANN_MLP; cdecl;
Function   pCvml_ANN_MLPpredict(const wrapper: PCvml_ANN_MLP_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_ANN_MLPpredictV2(const wrapper: PCvml_ANN_MLP_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_ANN_MLPread(const wrapper: PCvml_ANN_MLP_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_ANN_MLPsave(const wrapper: PCvml_ANN_MLP_t; filename: PCvString_t); cdecl;
Procedure  pCvml_ANN_MLPsetActivationFunction(const wrapper: PCvml_ANN_MLP_t; _type: Integer; 
                 param1: Double { default: 0 } = 0; param2: Double { default: 0 } = 0); cdecl;
Procedure  pCvml_ANN_MLPsetAnnealCoolingRatio(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetAnnealFinalT(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetAnnealInitialT(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetAnnealItePerStep(const wrapper: PCvml_ANN_MLP_t; _val: Integer); cdecl;
Procedure  pCvml_ANN_MLPsetBackpropMomentumScale(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetBackpropWeightScale(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetLayerSizes(const wrapper: PCvml_ANN_MLP_t; _layer_sizes: PCvMat_t); cdecl;
Procedure  pCvml_ANN_MLPsetLayerSizesV2(const wrapper: PCvml_ANN_MLP_t; _layer_sizes: PCvUMat_t); cdecl;
Procedure  pCvml_ANN_MLPsetRpropDW0(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetRpropDWMax(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetRpropDWMin(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetRpropDWMinus(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetRpropDWPlus(const wrapper: PCvml_ANN_MLP_t; _val: Double); cdecl;
Procedure  pCvml_ANN_MLPsetTermCriteria(const wrapper: PCvml_ANN_MLP_t; _val: PCvTermCriteria_t); cdecl;
Procedure  pCvml_ANN_MLPsetTrainMethod(const wrapper: PCvml_ANN_MLP_t; method: Integer; 
                 param1: Double { default: 0 } = 0; param2: Double { default: 0 } = 0); cdecl;
Function   pCvml_ANN_MLPtrain(const wrapper: PCvml_ANN_MLP_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_ANN_MLPtrainV2(const wrapper: PCvml_ANN_MLP_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_ANN_MLPtrainV3(const wrapper: PCvml_ANN_MLP_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_ANN_MLPwrite(const wrapper: PCvml_ANN_MLP_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_BoostcalcError(const wrapper: PCvml_Boost_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_BoostcalcErrorV2(const wrapper: PCvml_Boost_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_Boostclear(const wrapper: PCvml_Boost_t); cdecl;
Function   pCvml_Boost_create(): PCvPtr_Boost; cdecl;
Function   pCvml_Boostempty(const wrapper: PCvml_Boost_t): Boolean; cdecl;
Function   pCvml_BoostgetBoostType(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetCVFolds(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetDefaultName(const wrapper: PCvml_Boost_t): PCvString_t; cdecl;
Function   pCvml_BoostgetMaxCategories(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetMaxDepth(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetMinSampleCount(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetPriors(const wrapper: PCvml_Boost_t): PCvMat_t; cdecl;
Function   pCvml_BoostgetRegressionAccuracy(const wrapper: PCvml_Boost_t): Single; cdecl;
Function   pCvml_BoostgetTruncatePrunedTree(const wrapper: PCvml_Boost_t): Boolean; cdecl;
Function   pCvml_BoostgetUse1SERule(const wrapper: PCvml_Boost_t): Boolean; cdecl;
Function   pCvml_BoostgetUseSurrogates(const wrapper: PCvml_Boost_t): Boolean; cdecl;
Function   pCvml_BoostgetVarCount(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetWeakCount(const wrapper: PCvml_Boost_t): Integer; cdecl;
Function   pCvml_BoostgetWeightTrimRate(const wrapper: PCvml_Boost_t): Double; cdecl;
Function   pCvml_BoostisClassifier(const wrapper: PCvml_Boost_t): Boolean; cdecl;
Function   pCvml_BoostisTrained(const wrapper: PCvml_Boost_t): Boolean; cdecl;
Function   pCvml_Boostload(filepath: PCvString_t; nodeName: PCvString_t { default: String() } = nil): PCvPtr_Boost; cdecl;
Function   pCvml_Boostpredict(const wrapper: PCvml_Boost_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_BoostpredictV2(const wrapper: PCvml_Boost_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_Boostread(const wrapper: PCvml_Boost_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_Boostsave(const wrapper: PCvml_Boost_t; filename: PCvString_t); cdecl;
Procedure  pCvml_BoostsetBoostType(const wrapper: PCvml_Boost_t; _val: Integer); cdecl;
Procedure  pCvml_BoostsetCVFolds(const wrapper: PCvml_Boost_t; _val: Integer); cdecl;
Procedure  pCvml_BoostsetMaxCategories(const wrapper: PCvml_Boost_t; _val: Integer); cdecl;
Procedure  pCvml_BoostsetMaxDepth(const wrapper: PCvml_Boost_t; _val: Integer); cdecl;
Procedure  pCvml_BoostsetMinSampleCount(const wrapper: PCvml_Boost_t; _val: Integer); cdecl;
Procedure  pCvml_BoostsetPriors(const wrapper: PCvml_Boost_t; _val: PCvMat_t); cdecl;
Procedure  pCvml_BoostsetRegressionAccuracy(const wrapper: PCvml_Boost_t; _val: Single); cdecl;
Procedure  pCvml_BoostsetTruncatePrunedTree(const wrapper: PCvml_Boost_t; _val: Boolean); cdecl;
Procedure  pCvml_BoostsetUse1SERule(const wrapper: PCvml_Boost_t; _val: Boolean); cdecl;
Procedure  pCvml_BoostsetUseSurrogates(const wrapper: PCvml_Boost_t; _val: Boolean); cdecl;
Procedure  pCvml_BoostsetWeakCount(const wrapper: PCvml_Boost_t; _val: Integer); cdecl;
Procedure  pCvml_BoostsetWeightTrimRate(const wrapper: PCvml_Boost_t; _val: Double); cdecl;
Function   pCvml_Boosttrain(const wrapper: PCvml_Boost_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_BoosttrainV2(const wrapper: PCvml_Boost_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_BoosttrainV3(const wrapper: PCvml_Boost_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_Boostwrite(const wrapper: PCvml_Boost_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_DTreescalcError(const wrapper: PCvml_DTrees_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_DTreescalcErrorV2(const wrapper: PCvml_DTrees_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_DTreesclear(const wrapper: PCvml_DTrees_t); cdecl;
Function   pCvml_DTrees_create(): PCvPtr_DTrees; cdecl;
Function   pCvml_DTreesempty(const wrapper: PCvml_DTrees_t): Boolean; cdecl;
Function   pCvml_DTreesgetCVFolds(const wrapper: PCvml_DTrees_t): Integer; cdecl;
Function   pCvml_DTreesgetDefaultName(const wrapper: PCvml_DTrees_t): PCvString_t; cdecl;
Function   pCvml_DTreesgetMaxCategories(const wrapper: PCvml_DTrees_t): Integer; cdecl;
Function   pCvml_DTreesgetMaxDepth(const wrapper: PCvml_DTrees_t): Integer; cdecl;
Function   pCvml_DTreesgetMinSampleCount(const wrapper: PCvml_DTrees_t): Integer; cdecl;
Function   pCvml_DTreesgetPriors(const wrapper: PCvml_DTrees_t): PCvMat_t; cdecl;
Function   pCvml_DTreesgetRegressionAccuracy(const wrapper: PCvml_DTrees_t): Single; cdecl;
Function   pCvml_DTreesgetTruncatePrunedTree(const wrapper: PCvml_DTrees_t): Boolean; cdecl;
Function   pCvml_DTreesgetUse1SERule(const wrapper: PCvml_DTrees_t): Boolean; cdecl;
Function   pCvml_DTreesgetUseSurrogates(const wrapper: PCvml_DTrees_t): Boolean; cdecl;
Function   pCvml_DTreesgetVarCount(const wrapper: PCvml_DTrees_t): Integer; cdecl;
Function   pCvml_DTreesisClassifier(const wrapper: PCvml_DTrees_t): Boolean; cdecl;
Function   pCvml_DTreesisTrained(const wrapper: PCvml_DTrees_t): Boolean; cdecl;
Function   pCvml_DTreesload(filepath: PCvString_t; nodeName: PCvString_t { default: String() } = nil): PCvPtr_DTrees; cdecl;
Function   pCvml_DTreespredict(const wrapper: PCvml_DTrees_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_DTreespredictV2(const wrapper: PCvml_DTrees_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_DTreesread(const wrapper: PCvml_DTrees_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_DTreessave(const wrapper: PCvml_DTrees_t; filename: PCvString_t); cdecl;
Procedure  pCvml_DTreessetCVFolds(const wrapper: PCvml_DTrees_t; _val: Integer); cdecl;
Procedure  pCvml_DTreessetMaxCategories(const wrapper: PCvml_DTrees_t; _val: Integer); cdecl;
Procedure  pCvml_DTreessetMaxDepth(const wrapper: PCvml_DTrees_t; _val: Integer); cdecl;
Procedure  pCvml_DTreessetMinSampleCount(const wrapper: PCvml_DTrees_t; _val: Integer); cdecl;
Procedure  pCvml_DTreessetPriors(const wrapper: PCvml_DTrees_t; _val: PCvMat_t); cdecl;
Procedure  pCvml_DTreessetRegressionAccuracy(const wrapper: PCvml_DTrees_t; _val: Single); cdecl;
Procedure  pCvml_DTreessetTruncatePrunedTree(const wrapper: PCvml_DTrees_t; _val: Boolean); cdecl;
Procedure  pCvml_DTreessetUse1SERule(const wrapper: PCvml_DTrees_t; _val: Boolean); cdecl;
Procedure  pCvml_DTreessetUseSurrogates(const wrapper: PCvml_DTrees_t; _val: Boolean); cdecl;
Function   pCvml_DTreestrain(const wrapper: PCvml_DTrees_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_DTreestrainV2(const wrapper: PCvml_DTrees_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_DTreestrainV3(const wrapper: PCvml_DTrees_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_DTreeswrite(const wrapper: PCvml_DTrees_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_EMcalcError(const wrapper: PCvml_EM_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_EMcalcErrorV2(const wrapper: PCvml_EM_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_EMclear(const wrapper: PCvml_EM_t); cdecl;
Function   pCvml_EM_create(): PCvPtr_EM; cdecl;
Function   pCvml_EMempty(const wrapper: PCvml_EM_t): Boolean; cdecl;
Function   pCvml_EMgetClustersNumber(const wrapper: PCvml_EM_t): Integer; cdecl;
Function   pCvml_EMgetCovarianceMatrixType(const wrapper: PCvml_EM_t): Integer; cdecl;
Procedure  pCvml_EMgetCovs(const wrapper: PCvml_EM_t; covs: PCvvector_Mat); cdecl;
Function   pCvml_EMgetDefaultName(const wrapper: PCvml_EM_t): PCvString_t; cdecl;
Function   pCvml_EMgetMeans(const wrapper: PCvml_EM_t): PCvMat_t; cdecl;
Function   pCvml_EMgetTermCriteria(const wrapper: PCvml_EM_t): PCvTermCriteria_t; cdecl;
Function   pCvml_EMgetVarCount(const wrapper: PCvml_EM_t): Integer; cdecl;
Function   pCvml_EMgetWeights(const wrapper: PCvml_EM_t): PCvMat_t; cdecl;
Function   pCvml_EMisClassifier(const wrapper: PCvml_EM_t): Boolean; cdecl;
Function   pCvml_EMisTrained(const wrapper: PCvml_EM_t): Boolean; cdecl;
Function   pCvml_EMload(filepath: PCvString_t; nodeName: PCvString_t { default: String() } = nil): PCvPtr_EM; cdecl;
Function   pCvml_EMpredict(const wrapper: PCvml_EM_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_EMpredictV2(const wrapper: PCvml_EM_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_EMpredict2(const wrapper: PCvml_EM_t; sample: PCvMat_t; probs: PCvMat_t): PCvVec2d_t; cdecl;
Function   pCvml_EMpredict2V2(const wrapper: PCvml_EM_t; sample: PCvUMat_t; probs: PCvUMat_t): PCvVec2d_t; cdecl;
Procedure  pCvml_EMread(const wrapper: PCvml_EM_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_EMsave(const wrapper: PCvml_EM_t; filename: PCvString_t); cdecl;
Procedure  pCvml_EMsetClustersNumber(const wrapper: PCvml_EM_t; _val: Integer); cdecl;
Procedure  pCvml_EMsetCovarianceMatrixType(const wrapper: PCvml_EM_t; _val: Integer); cdecl;
Procedure  pCvml_EMsetTermCriteria(const wrapper: PCvml_EM_t; _val: PCvTermCriteria_t); cdecl;
Function   pCvml_EMtrain(const wrapper: PCvml_EM_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_EMtrainV2(const wrapper: PCvml_EM_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_EMtrainV3(const wrapper: PCvml_EM_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Function   pCvml_EMtrainE(const wrapper: PCvml_EM_t; samples: PCvMat_t; means0: PCvMat_t; 
                 covs0: PCvMat_t { default: Mat() } = nil; weights0: PCvMat_t { default: Mat() } = nil; 
                 logLikelihoods: PCvMat_t { default: Mat() } = nil; labels: PCvMat_t { default: Mat() } = nil; 
                 probs: PCvMat_t { default: Mat() } = nil): Boolean; cdecl;
Function   pCvml_EMtrainEV2(const wrapper: PCvml_EM_t; samples: PCvUMat_t; means0: PCvUMat_t; 
                 covs0: PCvUMat_t { default: UMat() } = nil; weights0: PCvUMat_t { default: UMat() } = nil; 
                 logLikelihoods: PCvUMat_t { default: UMat() } = nil; labels: PCvUMat_t { default: UMat() } = nil; 
                 probs: PCvUMat_t { default: UMat() } = nil): Boolean; cdecl;
Function   pCvml_EMtrainEM(const wrapper: PCvml_EM_t; samples: PCvMat_t; 
                 logLikelihoods: PCvMat_t { default: Mat() } = nil; labels: PCvMat_t { default: Mat() } = nil; 
                 probs: PCvMat_t { default: Mat() } = nil): Boolean; cdecl;
Function   pCvml_EMtrainEMV2(const wrapper: PCvml_EM_t; samples: PCvUMat_t; 
                 logLikelihoods: PCvUMat_t { default: UMat() } = nil; labels: PCvUMat_t { default: UMat() } = nil; 
                 probs: PCvUMat_t { default: UMat() } = nil): Boolean; cdecl;
Function   pCvml_EMtrainM(const wrapper: PCvml_EM_t; samples: PCvMat_t; probs0: PCvMat_t; 
                 logLikelihoods: PCvMat_t { default: Mat() } = nil; labels: PCvMat_t { default: Mat() } = nil; 
                 probs: PCvMat_t { default: Mat() } = nil): Boolean; cdecl;
Function   pCvml_EMtrainMV2(const wrapper: PCvml_EM_t; samples: PCvUMat_t; probs0: PCvUMat_t; 
                 logLikelihoods: PCvUMat_t { default: UMat() } = nil; labels: PCvUMat_t { default: UMat() } = nil; 
                 probs: PCvUMat_t { default: UMat() } = nil): Boolean; cdecl;
Procedure  pCvml_EMwrite(const wrapper: PCvml_EM_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Procedure  pCvml_KDTreebuild(const wrapper: PCvml_KDTree_t; points: PCvMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false); cdecl;
Procedure  pCvml_KDTreebuildV2(const wrapper: PCvml_KDTree_t; points: PCvUMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false); cdecl;
Procedure  pCvml_KDTreebuildV3(const wrapper: PCvml_KDTree_t; points: PCvMat_t; labels: PCvMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false); cdecl;
Procedure  pCvml_KDTreebuildV4(const wrapper: PCvml_KDTree_t; points: PCvUMat_t; labels: PCvUMat_t; 
                 copyAndReorderPoints: Boolean { default: false } = false); cdecl;
Function   pCvml_KDTreedims(const wrapper: PCvml_KDTree_t): Integer; cdecl;
Function   pCvml_KDTreefindNearest(const wrapper: PCvml_KDTree_t; vec: PCvMat_t; K: Integer; 
                 Emax: Integer; neighborsIdx: PCvMat_t; 
                 neighbors: PCvMat_t { default: Mat() } = nil; dist: PCvMat_t { default: Mat() } = nil; 
                 labels: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvml_KDTreefindNearestV2(const wrapper: PCvml_KDTree_t; vec: PCvUMat_t; K: Integer; 
                 Emax: Integer; neighborsIdx: PCvUMat_t; 
                 neighbors: PCvUMat_t { default: UMat() } = nil; dist: PCvUMat_t { default: UMat() } = nil; 
                 labels: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Procedure  pCvml_KDTreefindOrthoRange(const wrapper: PCvml_KDTree_t; minBounds: PCvMat_t; 
                 maxBounds: PCvMat_t; neighborsIdx: PCvMat_t; 
                 neighbors: PCvMat_t { default: Mat() } = nil; labels: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvml_KDTreefindOrthoRangeV2(const wrapper: PCvml_KDTree_t; minBounds: PCvUMat_t; 
                 maxBounds: PCvUMat_t; neighborsIdx: PCvUMat_t; 
                 neighbors: PCvUMat_t { default: UMat() } = nil; labels: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvml_KDTreegetPoints(const wrapper: PCvml_KDTree_t; idx: PCvMat_t; pts: PCvMat_t; 
                 labels: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvml_KDTreegetPointsV2(const wrapper: PCvml_KDTree_t; idx: PCvUMat_t; pts: PCvUMat_t; 
                 labels: PCvUMat_t { default: UMat() } = nil); cdecl;
Function   pCvml_KDTreeGet_labels(const wrapper: PCvml_KDTree_t): PCvvector_int; cdecl;
Function   pCvml_KDTreeGet_maxDepth(const wrapper: PCvml_KDTree_t): Integer; cdecl;
Function   pCvml_KDTreeGet_normType(const wrapper: PCvml_KDTree_t): Integer; cdecl;
Procedure  pCvml_KDTreeSet_normType(const wrapper: PCvml_KDTree_t; propval: Integer); cdecl;
Function   pCvml_KDTreeGet_points(const wrapper: PCvml_KDTree_t): PCvMat_t; cdecl;
Function   pCvml_KNearestcalcError(const wrapper: PCvml_KNearest_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvMat_t): Single; cdecl;
Function   pCvml_KNearestcalcErrorV2(const wrapper: PCvml_KNearest_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_KNearestclear(const wrapper: PCvml_KNearest_t); cdecl;
Function   pCvml_KNearest_create(): PCvPtr_KNearest; cdecl;
Function   pCvml_KNearestempty(const wrapper: PCvml_KNearest_t): Boolean; cdecl;
Function   pCvml_KNearestfindNearest(const wrapper: PCvml_KNearest_t; samples: PCvMat_t; k: Integer; 
                 results: PCvMat_t; neighborResponses: PCvMat_t { default: Mat() } = nil; 
                 dist: PCvMat_t { default: Mat() } = nil): Single; cdecl;
Function   pCvml_KNearestfindNearestV2(const wrapper: PCvml_KNearest_t; samples: PCvUMat_t; k: Integer; 
                 results: PCvUMat_t; neighborResponses: PCvUMat_t { default: UMat() } = nil; 
                 dist: PCvUMat_t { default: UMat() } = nil): Single; cdecl;
Function   pCvml_KNearestgetAlgorithmType(const wrapper: PCvml_KNearest_t): Integer; cdecl;
Function   pCvml_KNearestgetDefaultK(const wrapper: PCvml_KNearest_t): Integer; cdecl;
Function   pCvml_KNearestgetDefaultName(const wrapper: PCvml_KNearest_t): PCvString_t; cdecl;
Function   pCvml_KNearestgetEmax(const wrapper: PCvml_KNearest_t): Integer; cdecl;
Function   pCvml_KNearestgetIsClassifier(const wrapper: PCvml_KNearest_t): Boolean; cdecl;
Function   pCvml_KNearestgetVarCount(const wrapper: PCvml_KNearest_t): Integer; cdecl;
Function   pCvml_KNearestisClassifier(const wrapper: PCvml_KNearest_t): Boolean; cdecl;
Function   pCvml_KNearestisTrained(const wrapper: PCvml_KNearest_t): Boolean; cdecl;
Function   pCvml_KNearestload(filepath: PCvString_t): PCvPtr_KNearest; cdecl;
Function   pCvml_KNearestpredict(const wrapper: PCvml_KNearest_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_KNearestpredictV2(const wrapper: PCvml_KNearest_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_KNearestread(const wrapper: PCvml_KNearest_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_KNearestsave(const wrapper: PCvml_KNearest_t; filename: PCvString_t); cdecl;
Procedure  pCvml_KNearestsetAlgorithmType(const wrapper: PCvml_KNearest_t; _val: Integer); cdecl;
Procedure  pCvml_KNearestsetDefaultK(const wrapper: PCvml_KNearest_t; _val: Integer); cdecl;
Procedure  pCvml_KNearestsetEmax(const wrapper: PCvml_KNearest_t; _val: Integer); cdecl;
Procedure  pCvml_KNearestsetIsClassifier(const wrapper: PCvml_KNearest_t; _val: Boolean); cdecl;
Function   pCvml_KNearesttrain(const wrapper: PCvml_KNearest_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_KNearesttrainV2(const wrapper: PCvml_KNearest_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_KNearesttrainV3(const wrapper: PCvml_KNearest_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_KNearestwrite(const wrapper: PCvml_KNearest_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_LogisticRegressioncalcError(const wrapper: PCvml_LogisticRegression_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvMat_t): Single; cdecl;
Function   pCvml_LogisticRegressioncalcErrorV2(const wrapper: PCvml_LogisticRegression_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_LogisticRegressionclear(const wrapper: PCvml_LogisticRegression_t); cdecl;
Function   pCvml_LogisticRegression_create(): PCvPtr_LogisticRegression; cdecl;
Function   pCvml_LogisticRegressionempty(const wrapper: PCvml_LogisticRegression_t): Boolean; cdecl;
Function   pCvml_LogisticRegressiongetDefaultName(const wrapper: PCvml_LogisticRegression_t): PCvString_t; cdecl;
Function   pCvml_LogisticRegressiongetIterations(const wrapper: PCvml_LogisticRegression_t): Integer; cdecl;
Function   pCvml_LogisticRegressiongetLearningRate(const wrapper: PCvml_LogisticRegression_t): Double; cdecl;
Function   pCvml_LogisticRegressiongetMiniBatchSize(const wrapper: PCvml_LogisticRegression_t): Integer; cdecl;
Function   pCvml_LogisticRegressiongetRegularization(const wrapper: PCvml_LogisticRegression_t): Integer; cdecl;
Function   pCvml_LogisticRegressiongetTermCriteria(const wrapper: PCvml_LogisticRegression_t): PCvTermCriteria_t; cdecl;
Function   pCvml_LogisticRegressiongetTrainMethod(const wrapper: PCvml_LogisticRegression_t): Integer; cdecl;
Function   pCvml_LogisticRegressiongetVarCount(const wrapper: PCvml_LogisticRegression_t): Integer; cdecl;
Function   pCvml_LogisticRegressionget_learnt_thetas(const wrapper: PCvml_LogisticRegression_t): PCvMat_t; cdecl;
Function   pCvml_LogisticRegressionisClassifier(const wrapper: PCvml_LogisticRegression_t): Boolean; cdecl;
Function   pCvml_LogisticRegressionisTrained(const wrapper: PCvml_LogisticRegression_t): Boolean; cdecl;
Function   pCvml_LogisticRegressionload(filepath: PCvString_t; 
                 nodeName: PCvString_t { default: String() } = nil): PCvPtr_LogisticRegression; cdecl;
Function   pCvml_LogisticRegressionpredict(const wrapper: PCvml_LogisticRegression_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_LogisticRegressionpredictV2(const wrapper: PCvml_LogisticRegression_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_LogisticRegressionread(const wrapper: PCvml_LogisticRegression_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_LogisticRegressionsave(const wrapper: PCvml_LogisticRegression_t; filename: PCvString_t); cdecl;
Procedure  pCvml_LogisticRegressionsetIterations(const wrapper: PCvml_LogisticRegression_t; _val: Integer); cdecl;
Procedure  pCvml_LogisticRegressionsetLearningRate(const wrapper: PCvml_LogisticRegression_t; _val: Double); cdecl;
Procedure  pCvml_LogisticRegressionsetMiniBatchSize(const wrapper: PCvml_LogisticRegression_t; _val: Integer); cdecl;
Procedure  pCvml_LogisticRegressionsetRegularization(const wrapper: PCvml_LogisticRegression_t; _val: Integer); cdecl;
Procedure  pCvml_LogisticRegressionsetTermCriteria(const wrapper: PCvml_LogisticRegression_t; _val: PCvTermCriteria_t); cdecl;
Procedure  pCvml_LogisticRegressionsetTrainMethod(const wrapper: PCvml_LogisticRegression_t; _val: Integer); cdecl;
Function   pCvml_LogisticRegressiontrain(const wrapper: PCvml_LogisticRegression_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_LogisticRegressiontrainV2(const wrapper: PCvml_LogisticRegression_t; samples: PCvMat_t; 
                 layout: Integer; responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_LogisticRegressiontrainV3(const wrapper: PCvml_LogisticRegression_t; samples: PCvUMat_t; 
                 layout: Integer; responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_LogisticRegressionwrite(const wrapper: PCvml_LogisticRegression_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_NormalBayesClassifiercalcError(const wrapper: PCvml_NormalBayesClassifier_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvMat_t): Single; cdecl;
Function   pCvml_NormalBayesClassifiercalcErrorV2(const wrapper: PCvml_NormalBayesClassifier_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_NormalBayesClassifierclear(const wrapper: PCvml_NormalBayesClassifier_t); cdecl;
Function   pCvml_NormalBayesClassifier_create(): PCvPtr_NormalBayesClassifier; cdecl;
Function   pCvml_NormalBayesClassifierempty(const wrapper: PCvml_NormalBayesClassifier_t): Boolean; cdecl;
Function   pCvml_NormalBayesClassifiergetDefaultName(const wrapper: PCvml_NormalBayesClassifier_t): PCvString_t; cdecl;
Function   pCvml_NormalBayesClassifiergetVarCount(const wrapper: PCvml_NormalBayesClassifier_t): Integer; cdecl;
Function   pCvml_NormalBayesClassifierisClassifier(const wrapper: PCvml_NormalBayesClassifier_t): Boolean; cdecl;
Function   pCvml_NormalBayesClassifierisTrained(const wrapper: PCvml_NormalBayesClassifier_t): Boolean; cdecl;
Function   pCvml_NormalBayesClassifierload(filepath: PCvString_t; 
                 nodeName: PCvString_t { default: String() } = nil): PCvPtr_NormalBayesClassifier; cdecl;
Function   pCvml_NormalBayesClassifierpredict(const wrapper: PCvml_NormalBayesClassifier_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_NormalBayesClassifierpredictV2(const wrapper: PCvml_NormalBayesClassifier_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_NormalBayesClassifierpredictProb(const wrapper: PCvml_NormalBayesClassifier_t; inputs: PCvMat_t; 
                 outputs: PCvMat_t; outputProbs: PCvMat_t; 
                 flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_NormalBayesClassifierpredictProbV2(const wrapper: PCvml_NormalBayesClassifier_t; inputs: PCvUMat_t; 
                 outputs: PCvUMat_t; outputProbs: PCvUMat_t; 
                 flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_NormalBayesClassifierread(const wrapper: PCvml_NormalBayesClassifier_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_NormalBayesClassifiersave(const wrapper: PCvml_NormalBayesClassifier_t; filename: PCvString_t); cdecl;
Function   pCvml_NormalBayesClassifiertrain(const wrapper: PCvml_NormalBayesClassifier_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_NormalBayesClassifiertrainV2(const wrapper: PCvml_NormalBayesClassifier_t; samples: PCvMat_t; 
                 layout: Integer; responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_NormalBayesClassifiertrainV3(const wrapper: PCvml_NormalBayesClassifier_t; samples: PCvUMat_t; 
                 layout: Integer; responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_NormalBayesClassifierwrite(const wrapper: PCvml_NormalBayesClassifier_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_ParamGrid_create(minVal: Double { default: 0. } = 0.0; 
                 maxVal: Double { default: 0. } = 0.0; logstep: Double { default: 1. } = 1.0): PCvPtr_ParamGrid; cdecl;
Function   pCvml_ParamGridGet_logStep(const wrapper: PCvml_ParamGrid_t): Double; cdecl;
Procedure  pCvml_ParamGridSet_logStep(const wrapper: PCvml_ParamGrid_t; propval: Double); cdecl;
Function   pCvml_ParamGridGet_maxVal(const wrapper: PCvml_ParamGrid_t): Double; cdecl;
Procedure  pCvml_ParamGridSet_maxVal(const wrapper: PCvml_ParamGrid_t; propval: Double); cdecl;
Function   pCvml_ParamGridGet_minVal(const wrapper: PCvml_ParamGrid_t): Double; cdecl;
Procedure  pCvml_ParamGridSet_minVal(const wrapper: PCvml_ParamGrid_t; propval: Double); cdecl;
Function   pCvml_RTreescalcError(const wrapper: PCvml_RTrees_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_RTreescalcErrorV2(const wrapper: PCvml_RTrees_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_RTreesclear(const wrapper: PCvml_RTrees_t); cdecl;
Function   pCvml_RTrees_create(): PCvPtr_RTrees; cdecl;
Function   pCvml_RTreesempty(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesgetActiveVarCount(const wrapper: PCvml_RTrees_t): Integer; cdecl;
Function   pCvml_RTreesgetCVFolds(const wrapper: PCvml_RTrees_t): Integer; cdecl;
Function   pCvml_RTreesgetCalculateVarImportance(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesgetDefaultName(const wrapper: PCvml_RTrees_t): PCvString_t; cdecl;
Function   pCvml_RTreesgetMaxCategories(const wrapper: PCvml_RTrees_t): Integer; cdecl;
Function   pCvml_RTreesgetMaxDepth(const wrapper: PCvml_RTrees_t): Integer; cdecl;
Function   pCvml_RTreesgetMinSampleCount(const wrapper: PCvml_RTrees_t): Integer; cdecl;
Function   pCvml_RTreesgetOOBError(const wrapper: PCvml_RTrees_t): Double; cdecl;
Function   pCvml_RTreesgetPriors(const wrapper: PCvml_RTrees_t): PCvMat_t; cdecl;
Function   pCvml_RTreesgetRegressionAccuracy(const wrapper: PCvml_RTrees_t): Single; cdecl;
Function   pCvml_RTreesgetTermCriteria(const wrapper: PCvml_RTrees_t): PCvTermCriteria_t; cdecl;
Function   pCvml_RTreesgetTruncatePrunedTree(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesgetUse1SERule(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesgetUseSurrogates(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesgetVarCount(const wrapper: PCvml_RTrees_t): Integer; cdecl;
Function   pCvml_RTreesgetVarImportance(const wrapper: PCvml_RTrees_t): PCvMat_t; cdecl;
Procedure  pCvml_RTreesgetVotes(const wrapper: PCvml_RTrees_t; samples: PCvMat_t; results: PCvMat_t; 
                 flags: Integer); cdecl;
Procedure  pCvml_RTreesgetVotesV2(const wrapper: PCvml_RTrees_t; samples: PCvUMat_t; results: PCvUMat_t; 
                 flags: Integer); cdecl;
Function   pCvml_RTreesisClassifier(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesisTrained(const wrapper: PCvml_RTrees_t): Boolean; cdecl;
Function   pCvml_RTreesload(filepath: PCvString_t; nodeName: PCvString_t { default: String() } = nil): PCvPtr_RTrees; cdecl;
Function   pCvml_RTreespredict(const wrapper: PCvml_RTrees_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_RTreespredictV2(const wrapper: PCvml_RTrees_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_RTreesread(const wrapper: PCvml_RTrees_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_RTreessave(const wrapper: PCvml_RTrees_t; filename: PCvString_t); cdecl;
Procedure  pCvml_RTreessetActiveVarCount(const wrapper: PCvml_RTrees_t; _val: Integer); cdecl;
Procedure  pCvml_RTreessetCVFolds(const wrapper: PCvml_RTrees_t; _val: Integer); cdecl;
Procedure  pCvml_RTreessetCalculateVarImportance(const wrapper: PCvml_RTrees_t; _val: Boolean); cdecl;
Procedure  pCvml_RTreessetMaxCategories(const wrapper: PCvml_RTrees_t; _val: Integer); cdecl;
Procedure  pCvml_RTreessetMaxDepth(const wrapper: PCvml_RTrees_t; _val: Integer); cdecl;
Procedure  pCvml_RTreessetMinSampleCount(const wrapper: PCvml_RTrees_t; _val: Integer); cdecl;
Procedure  pCvml_RTreessetPriors(const wrapper: PCvml_RTrees_t; _val: PCvMat_t); cdecl;
Procedure  pCvml_RTreessetRegressionAccuracy(const wrapper: PCvml_RTrees_t; _val: Single); cdecl;
Procedure  pCvml_RTreessetTermCriteria(const wrapper: PCvml_RTrees_t; _val: PCvTermCriteria_t); cdecl;
Procedure  pCvml_RTreessetTruncatePrunedTree(const wrapper: PCvml_RTrees_t; _val: Boolean); cdecl;
Procedure  pCvml_RTreessetUse1SERule(const wrapper: PCvml_RTrees_t; _val: Boolean); cdecl;
Procedure  pCvml_RTreessetUseSurrogates(const wrapper: PCvml_RTrees_t; _val: Boolean); cdecl;
Function   pCvml_RTreestrain(const wrapper: PCvml_RTrees_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_RTreestrainV2(const wrapper: PCvml_RTrees_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_RTreestrainV3(const wrapper: PCvml_RTrees_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_RTreeswrite(const wrapper: PCvml_RTrees_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_SVMcalcError(const wrapper: PCvml_SVM_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_SVMcalcErrorV2(const wrapper: PCvml_SVM_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_SVMclear(const wrapper: PCvml_SVM_t); cdecl;
Function   pCvml_SVM_create(): PCvPtr_SVM; cdecl;
Function   pCvml_SVMempty(const wrapper: PCvml_SVM_t): Boolean; cdecl;
Function   pCvml_SVMgetC(const wrapper: PCvml_SVM_t): Double; cdecl;
Function   pCvml_SVMgetClassWeights(const wrapper: PCvml_SVM_t): PCvMat_t; cdecl;
Function   pCvml_SVMgetCoef0(const wrapper: PCvml_SVM_t): Double; cdecl;
Function   pCvml_SVMgetDecisionFunction(const wrapper: PCvml_SVM_t; i: Integer; alpha: PCvMat_t; 
                 svidx: PCvMat_t): Double; cdecl;
Function   pCvml_SVMgetDecisionFunctionV2(const wrapper: PCvml_SVM_t; i: Integer; alpha: PCvUMat_t; 
                 svidx: PCvUMat_t): Double; cdecl;
Function   pCvml_SVMgetDefaultGridPtr(param_id: Integer): PCvPtr_ParamGrid; cdecl;
Function   pCvml_SVMgetDefaultName(const wrapper: PCvml_SVM_t): PCvString_t; cdecl;
Function   pCvml_SVMgetDegree(const wrapper: PCvml_SVM_t): Double; cdecl;
Function   pCvml_SVMgetGamma(const wrapper: PCvml_SVM_t): Double; cdecl;
Function   pCvml_SVMgetKernelType(const wrapper: PCvml_SVM_t): Integer; cdecl;
Function   pCvml_SVMgetNu(const wrapper: PCvml_SVM_t): Double; cdecl;
Function   pCvml_SVMgetP(const wrapper: PCvml_SVM_t): Double; cdecl;
Function   pCvml_SVMgetSupportVectors(const wrapper: PCvml_SVM_t): PCvMat_t; cdecl;
Function   pCvml_SVMgetTermCriteria(const wrapper: PCvml_SVM_t): PCvTermCriteria_t; cdecl;
Function   pCvml_SVMgetType(const wrapper: PCvml_SVM_t): Integer; cdecl;
Function   pCvml_SVMgetUncompressedSupportVectors(const wrapper: PCvml_SVM_t): PCvMat_t; cdecl;
Function   pCvml_SVMgetVarCount(const wrapper: PCvml_SVM_t): Integer; cdecl;
Function   pCvml_SVMisClassifier(const wrapper: PCvml_SVM_t): Boolean; cdecl;
Function   pCvml_SVMisTrained(const wrapper: PCvml_SVM_t): Boolean; cdecl;
Function   pCvml_SVMload(filepath: PCvString_t): PCvPtr_SVM; cdecl;
Function   pCvml_SVMpredict(const wrapper: PCvml_SVM_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_SVMpredictV2(const wrapper: PCvml_SVM_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_SVMread(const wrapper: PCvml_SVM_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_SVMsave(const wrapper: PCvml_SVM_t; filename: PCvString_t); cdecl;
Procedure  pCvml_SVMsetC(const wrapper: PCvml_SVM_t; _val: Double); cdecl;
Procedure  pCvml_SVMsetClassWeights(const wrapper: PCvml_SVM_t; _val: PCvMat_t); cdecl;
Procedure  pCvml_SVMsetCoef0(const wrapper: PCvml_SVM_t; _val: Double); cdecl;
Procedure  pCvml_SVMsetDegree(const wrapper: PCvml_SVM_t; _val: Double); cdecl;
Procedure  pCvml_SVMsetGamma(const wrapper: PCvml_SVM_t; _val: Double); cdecl;
Procedure  pCvml_SVMsetKernel(const wrapper: PCvml_SVM_t; kernelType: Integer); cdecl;
Procedure  pCvml_SVMsetNu(const wrapper: PCvml_SVM_t; _val: Double); cdecl;
Procedure  pCvml_SVMsetP(const wrapper: PCvml_SVM_t; _val: Double); cdecl;
Procedure  pCvml_SVMsetTermCriteria(const wrapper: PCvml_SVM_t; _val: PCvTermCriteria_t); cdecl;
Procedure  pCvml_SVMsetType(const wrapper: PCvml_SVM_t; _val: Integer); cdecl;
Function   pCvml_SVMtrain(const wrapper: PCvml_SVM_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_SVMtrainV2(const wrapper: PCvml_SVM_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_SVMtrainV3(const wrapper: PCvml_SVM_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Function   pCvml_SVMtrainAuto(const wrapper: PCvml_SVM_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t; kFold: Integer { default: 10 } = 10; 
                 Cgrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::C) } = nil; 
                 gammaGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::GAMMA) } = nil; 
                 pGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::P) } = nil; 
                 nuGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::NU) } = nil; 
                 coeffGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::COEF) } = nil; 
                 degreeGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::DEGREE) } = nil; balanced: Boolean { default: false } = false): Boolean; cdecl;
Function   pCvml_SVMtrainAutoV2(const wrapper: PCvml_SVM_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t; kFold: Integer { default: 10 } = 10; 
                 Cgrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::C) } = nil; 
                 gammaGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::GAMMA) } = nil; 
                 pGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::P) } = nil; 
                 nuGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::NU) } = nil; 
                 coeffGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::COEF) } = nil; 
                 degreeGrid: PCvPtr_ParamGrid { default: ml::SVM::getDefaultGridPtr(ml::SVM::DEGREE) } = nil; balanced: Boolean { default: false } = false): Boolean; cdecl;
Procedure  pCvml_SVMwrite(const wrapper: PCvml_SVM_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_SVMSGDcalcError(const wrapper: PCvml_SVMSGD_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvMat_t): Single; cdecl;
Function   pCvml_SVMSGDcalcErrorV2(const wrapper: PCvml_SVMSGD_t; data: PCvPtr_TrainData; test: Boolean; 
                 resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_SVMSGDclear(const wrapper: PCvml_SVMSGD_t); cdecl;
Function   pCvml_SVMSGD_create(): PCvPtr_SVMSGD; cdecl;
Function   pCvml_SVMSGDempty(const wrapper: PCvml_SVMSGD_t): Boolean; cdecl;
Function   pCvml_SVMSGDgetDefaultName(const wrapper: PCvml_SVMSGD_t): PCvString_t; cdecl;
Function   pCvml_SVMSGDgetInitialStepSize(const wrapper: PCvml_SVMSGD_t): Single; cdecl;
Function   pCvml_SVMSGDgetMarginRegularization(const wrapper: PCvml_SVMSGD_t): Single; cdecl;
Function   pCvml_SVMSGDgetMarginType(const wrapper: PCvml_SVMSGD_t): Integer; cdecl;
Function   pCvml_SVMSGDgetShift(const wrapper: PCvml_SVMSGD_t): Single; cdecl;
Function   pCvml_SVMSGDgetStepDecreasingPower(const wrapper: PCvml_SVMSGD_t): Single; cdecl;
Function   pCvml_SVMSGDgetSvmsgdType(const wrapper: PCvml_SVMSGD_t): Integer; cdecl;
Function   pCvml_SVMSGDgetTermCriteria(const wrapper: PCvml_SVMSGD_t): PCvTermCriteria_t; cdecl;
Function   pCvml_SVMSGDgetVarCount(const wrapper: PCvml_SVMSGD_t): Integer; cdecl;
Function   pCvml_SVMSGDgetWeights(const wrapper: PCvml_SVMSGD_t): PCvMat_t; cdecl;
Function   pCvml_SVMSGDisClassifier(const wrapper: PCvml_SVMSGD_t): Boolean; cdecl;
Function   pCvml_SVMSGDisTrained(const wrapper: PCvml_SVMSGD_t): Boolean; cdecl;
Function   pCvml_SVMSGDload(filepath: PCvString_t; nodeName: PCvString_t { default: String() } = nil): PCvPtr_SVMSGD; cdecl;
Function   pCvml_SVMSGDpredict(const wrapper: PCvml_SVMSGD_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_SVMSGDpredictV2(const wrapper: PCvml_SVMSGD_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_SVMSGDread(const wrapper: PCvml_SVMSGD_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_SVMSGDsave(const wrapper: PCvml_SVMSGD_t; filename: PCvString_t); cdecl;
Procedure  pCvml_SVMSGDsetInitialStepSize(const wrapper: PCvml_SVMSGD_t; InitialStepSize: Single); cdecl;
Procedure  pCvml_SVMSGDsetMarginRegularization(const wrapper: PCvml_SVMSGD_t; marginRegularization: Single); cdecl;
Procedure  pCvml_SVMSGDsetMarginType(const wrapper: PCvml_SVMSGD_t; marginType: Integer); cdecl;
Procedure  pCvml_SVMSGDsetOptimalParameters(const wrapper: PCvml_SVMSGD_t; 
                 svmsgdType: Integer { default: SVMSGD::ASGD } = ord(SVMSGD_ASGD); 
                 marginType: Integer { default: SVMSGD::SOFT_MARGIN } = ord(SVMSGD_SOFT_MARGIN)); cdecl;
Procedure  pCvml_SVMSGDsetStepDecreasingPower(const wrapper: PCvml_SVMSGD_t; stepDecreasingPower: Single); cdecl;
Procedure  pCvml_SVMSGDsetSvmsgdType(const wrapper: PCvml_SVMSGD_t; svmsgdType: Integer); cdecl;
Procedure  pCvml_SVMSGDsetTermCriteria(const wrapper: PCvml_SVMSGD_t; _val: PCvTermCriteria_t); cdecl;
Function   pCvml_SVMSGDtrain(const wrapper: PCvml_SVMSGD_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_SVMSGDtrainV2(const wrapper: PCvml_SVMSGD_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_SVMSGDtrainV3(const wrapper: PCvml_SVMSGD_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_SVMSGDwrite(const wrapper: PCvml_SVMSGD_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_StatModelcalcError(const wrapper: PCvml_StatModel_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvMat_t): Single; cdecl;
Function   pCvml_StatModelcalcErrorV2(const wrapper: PCvml_StatModel_t; data: PCvPtr_TrainData; 
                 test: Boolean; resp: PCvUMat_t): Single; cdecl;
Procedure  pCvml_StatModelclear(const wrapper: PCvml_StatModel_t); cdecl;
Function   pCvml_StatModelempty(const wrapper: PCvml_StatModel_t): Boolean; cdecl;
Function   pCvml_StatModelgetDefaultName(const wrapper: PCvml_StatModel_t): PCvString_t; cdecl;
Function   pCvml_StatModelgetVarCount(const wrapper: PCvml_StatModel_t): Integer; cdecl;
Function   pCvml_StatModelisClassifier(const wrapper: PCvml_StatModel_t): Boolean; cdecl;
Function   pCvml_StatModelisTrained(const wrapper: PCvml_StatModel_t): Boolean; cdecl;
Function   pCvml_StatModelpredict(const wrapper: PCvml_StatModel_t; samples: PCvMat_t; 
                 results: PCvMat_t { default: Mat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Function   pCvml_StatModelpredictV2(const wrapper: PCvml_StatModel_t; samples: PCvUMat_t; 
                 results: PCvUMat_t { default: UMat() } = nil; flags: Integer { default: 0 } = 0): Single; cdecl;
Procedure  pCvml_StatModelread(const wrapper: PCvml_StatModel_t; fn: PCvFileNode_t); cdecl;
Procedure  pCvml_StatModelsave(const wrapper: PCvml_StatModel_t; filename: PCvString_t); cdecl;
Function   pCvml_StatModeltrain(const wrapper: PCvml_StatModel_t; trainData: PCvPtr_TrainData; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvml_StatModeltrainV2(const wrapper: PCvml_StatModel_t; samples: PCvMat_t; layout: Integer; 
                 responses: PCvMat_t): Boolean; cdecl;
Function   pCvml_StatModeltrainV3(const wrapper: PCvml_StatModel_t; samples: PCvUMat_t; layout: Integer; 
                 responses: PCvUMat_t): Boolean; cdecl;
Procedure  pCvml_StatModelwrite(const wrapper: PCvml_StatModel_t; fs: PCvPtr_FileStorage; 
                 name: PCvString_t { default: String() } = nil); cdecl;
Function   pCvml_TrainData_create(samples: PCvMat_t; layout: Integer; responses: PCvMat_t; 
                 varIdx: PCvMat_t { default: Mat() } = nil; sampleIdx: PCvMat_t { default: Mat() } = nil; 
                 sampleWeights: PCvMat_t { default: Mat() } = nil; varType: PCvMat_t { default: Mat() } = nil): PCvPtr_TrainData; cdecl;
Function   pCvml_TrainData_createV2(samples: PCvUMat_t; layout: Integer; responses: PCvUMat_t; 
                 varIdx: PCvUMat_t { default: UMat() } = nil; sampleIdx: PCvUMat_t { default: UMat() } = nil; 
                 sampleWeights: PCvUMat_t { default: UMat() } = nil; varType: PCvUMat_t { default: UMat() } = nil): PCvPtr_TrainData; cdecl;
Function   pCvml_TrainDatagetCatCount(const wrapper: PCvml_TrainData_t; vi: Integer): Integer; cdecl;
Function   pCvml_TrainDatagetCatMap(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetCatOfs(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetClassLabels(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetDefaultSubstValues(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetLayout(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Function   pCvml_TrainDatagetMissing(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetNAllVars(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Function   pCvml_TrainDatagetNSamples(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Function   pCvml_TrainDatagetNTestSamples(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Function   pCvml_TrainDatagetNTrainSamples(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Function   pCvml_TrainDatagetNVars(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Procedure  pCvml_TrainDatagetNames(const wrapper: PCvml_TrainData_t; names: PCvvector_String); cdecl;
Function   pCvml_TrainDatagetNormCatResponses(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetResponseType(const wrapper: PCvml_TrainData_t): Integer; cdecl;
Function   pCvml_TrainDatagetResponses(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Procedure  pCvml_TrainDatagetSample(const wrapper: PCvml_TrainData_t; varIdx: PCvMat_t; sidx: Integer; 
                 buf: Single); cdecl;
Procedure  pCvml_TrainDatagetSampleV2(const wrapper: PCvml_TrainData_t; varIdx: PCvUMat_t; sidx: Integer; 
                 buf: Single); cdecl;
Function   pCvml_TrainDatagetSampleWeights(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetSamples(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetSubMatrix(matrix: PCvMat_t; idx: PCvMat_t; layout: Integer): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetSubVector(vec: PCvMat_t; idx: PCvMat_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTestNormCatResponses(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTestResponses(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTestSampleIdx(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTestSampleWeights(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTestSamples(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTrainNormCatResponses(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTrainResponses(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTrainSampleIdx(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTrainSampleWeights(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetTrainSamples(const wrapper: PCvml_TrainData_t; layout: Integer { default: ROW_SAMPLE } = ord(ROW_SAMPLE); 
                 compressSamples: Boolean { default: true } = true; compressVars: Boolean { default: true } = true): PCvMat_t; cdecl;
Procedure  pCvml_TrainDatagetValues(const wrapper: PCvml_TrainData_t; vi: Integer; sidx: PCvMat_t; 
                 values: Single); cdecl;
Procedure  pCvml_TrainDatagetValuesV2(const wrapper: PCvml_TrainData_t; vi: Integer; sidx: PCvUMat_t; 
                 values: Single); cdecl;
Function   pCvml_TrainDatagetVarIdx(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetVarSymbolFlags(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Function   pCvml_TrainDatagetVarType(const wrapper: PCvml_TrainData_t): PCvMat_t; cdecl;
Procedure  pCvml_TrainDatasetTrainTestSplit(const wrapper: PCvml_TrainData_t; count: Integer; 
                 shuffle: Boolean { default: true } = true); cdecl;
Procedure  pCvml_TrainDatasetTrainTestSplitRatio(const wrapper: PCvml_TrainData_t; ratio: Double; 
                 shuffle: Boolean { default: true } = true); cdecl;
Procedure  pCvml_TrainDatashuffleTrainTest(const wrapper: PCvml_TrainData_t); cdecl;
Function   pCvocl_DeviceOpenCLVersion(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvocl_DeviceOpenCL_C_Version(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvocl_DeviceaddressBits(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_Deviceavailable(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DevicecompilerAvailable(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DevicedeviceVersionMajor(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicedeviceVersionMinor(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicedoubleFPConfig(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicedriverVersion(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvocl_DeviceendianLittle(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceerrorCorrectionSupport(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceexecutionCapabilities(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_Deviceextensions(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvocl_DevicegetDefault(): PCvocl_Device_t; cdecl;
Function   pCvocl_DeviceglobalMemCacheLineSize(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DeviceglobalMemCacheSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DeviceglobalMemCacheType(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DeviceglobalMemSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicehalfFPConfig(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicehostUnifiedMemory(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_Deviceimage2DMaxHeight(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_Deviceimage2DMaxWidth(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_Deviceimage3DMaxDepth(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_Deviceimage3DMaxHeight(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_Deviceimage3DMaxWidth(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DeviceimageFromBufferSupport(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceimageMaxArraySize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DeviceimageMaxBufferSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DeviceimageSupport(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceintelSubgroupsSupport(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceisAMD(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceisExtensionSupported(const wrapper: PCvocl_Device_t; extensionName: PCvString_t): Boolean; cdecl;
Function   pCvocl_DeviceisIntel(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DeviceisNVidia(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DevicelinkerAvailable(const wrapper: PCvocl_Device_t): Boolean; cdecl;
Function   pCvocl_DevicelocalMemSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicelocalMemType(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxClockFrequency(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxComputeUnits(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxConstantArgs(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxConstantBufferSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicemaxMemAllocSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicemaxParameterSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicemaxReadImageArgs(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxSamplers(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxWorkGroupSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicemaxWorkItemDims(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicemaxWriteImageArgs(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicememBaseAddrAlign(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_Devicename(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvocl_DevicenativeVectorWidthChar(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicenativeVectorWidthDouble(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicenativeVectorWidthFloat(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicenativeVectorWidthHalf(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicenativeVectorWidthInt(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicenativeVectorWidthLong(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicenativeVectorWidthShort(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthChar(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthDouble(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthFloat(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthHalf(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthInt(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthLong(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicepreferredVectorWidthShort(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DeviceprintfBufferSize(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DeviceprofilingTimerResolution(const wrapper: PCvocl_Device_t): UInt64; cdecl;
Function   pCvocl_DevicesingleFPConfig(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_Devicetype(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicevendorID(const wrapper: PCvocl_Device_t): Integer; cdecl;
Function   pCvocl_DevicevendorName(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvocl_Deviceversion(const wrapper: PCvocl_Device_t): PCvString_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBapplyImage(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; image: PCvMat_t): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBapplyImageV2(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; image: PCvUMat_t): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBapplyImageFeatures(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; non_edge: PCvMat_t; 
                 gradient_direction: PCvMat_t; gradient_magnitude: PCvMat_t; 
                 image: PCvMat_t { default: Mat() } = nil): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBapplyImageFeaturesV2(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; non_edge: PCvUMat_t; 
                 gradient_direction: PCvUMat_t; gradient_magnitude: PCvUMat_t; 
                 image: PCvUMat_t { default: UMat() } = nil): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Procedure  pCvsegmentation_IntelligentScissorsMBbuildMap(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; sourcePt: PCvPoint_t); cdecl;
Procedure  pCvsegmentation_IntelligentScissorsMBgetContour(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; targetPt: PCvPoint_t; 
                 contour: PCvMat_t; 
                 backward: Boolean { default: false } = false); cdecl;
Procedure  pCvsegmentation_IntelligentScissorsMBgetContourV2(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; targetPt: PCvPoint_t; 
                 contour: PCvUMat_t; 
                 backward: Boolean { default: false } = false); cdecl;
Function   pCvsegmentation_IntelligentScissorsMBsetEdgeFeatureCannyParameters(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; threshold1: Double; 
                 threshold2: Double; 
                 apertureSize: Integer { default: 3 } = 3; 
                 L2gradient: Boolean { default: false } = false): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBsetEdgeFeatureZeroCrossingParameters(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; 
                 gradient_magnitude_min_value: Single { default: 0.0f } = 0.0): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBsetGradientMagnitudeMaxLimit(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; 
                 gradient_magnitude_threshold_max: Single { default: 0.0f } = 0.0): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvsegmentation_IntelligentScissorsMBsetWeights(const wrapper: PCvsegmentation_IntelligentScissorsMB_t; weight_non_edge: Single; 
                 weight_gradient_direction: Single; weight_gradient_magnitude: Single): PCvsegmentation_IntelligentScissorsMB_t; cdecl;
Function   pCvutils_nested_OriginalClassName_create(
                 params: PCvutils_nested_OriginalClassName_Params_t { default: utils::nested::OriginalClassName::Params() } = nil): PCvPtr_OriginalClassName; cdecl;
Function   pCvutils_nested_OriginalClassNamegetFloatParam(const wrapper: PCvutils_nested_OriginalClassName_t): Single; cdecl;
Function   pCvutils_nested_OriginalClassNamegetIntParam(const wrapper: PCvutils_nested_OriginalClassName_t): Integer; cdecl;
Function   pCvutils_nested_OriginalClassNameoriginalName(): PCvString_t; cdecl;
Function   pCvutils_nested_OriginalClassName_ParamsGet_float_value(const wrapper: PCvutils_nested_OriginalClassName_Params_t): Single; cdecl;
Procedure  pCvutils_nested_OriginalClassName_ParamsSet_float_value(const wrapper: PCvutils_nested_OriginalClassName_Params_t; propval: Single); cdecl;
Function   pCvutils_nested_OriginalClassName_ParamsGet_int_value(const wrapper: PCvutils_nested_OriginalClassName_Params_t): Integer; cdecl;
Procedure  pCvutils_nested_OriginalClassName_ParamsSet_int_value(const wrapper: PCvutils_nested_OriginalClassName_Params_t; propval: Integer); cdecl;
Function   pCvCamShift(probImage: PCvMat_t; window: PCvRect_t; criteria: PCvTermCriteria_t): PCvRotatedRect_t; cdecl;
Function   pCvCamShiftV2(probImage: PCvUMat_t; window: PCvRect_t; criteria: PCvTermCriteria_t): PCvRotatedRect_t; cdecl;
Procedure  pCvCanny(image: PCvMat_t; edges: PCvMat_t; threshold1: Double; threshold2: Double; 
                 apertureSize: Integer { default: 3 } = 3; L2gradient: Boolean { default: false } = false); cdecl;
Procedure  pCvCannyV2(image: PCvUMat_t; edges: PCvUMat_t; threshold1: Double; threshold2: Double; 
                 apertureSize: Integer { default: 3 } = 3; L2gradient: Boolean { default: false } = false); cdecl;
Procedure  pCvCannyV3(dx: PCvMat_t; dy: PCvMat_t; edges: PCvMat_t; threshold1: Double; 
                 threshold2: Double; L2gradient: Boolean { default: false } = false); cdecl;
Procedure  pCvCannyV4(dx: PCvUMat_t; dy: PCvUMat_t; edges: PCvUMat_t; threshold1: Double; 
                 threshold2: Double; L2gradient: Boolean { default: false } = false); cdecl;
Function   pCvEMD(signature1: PCvMat_t; signature2: PCvMat_t; distType: Integer; 
                 cost: PCvMat_t { default: Mat() } = nil; lowerBound: PCvPtr_float { default: Ptr<float>() } = nil; 
                 flow: PCvMat_t { default: Mat() } = nil): Single; cdecl;
Function   pCvEMDV2(signature1: PCvUMat_t; signature2: PCvUMat_t; distType: Integer; 
                 cost: PCvUMat_t { default: UMat() } = nil; lowerBound: PCvPtr_float { default: Ptr<float>() } = nil; 
                 flow: PCvUMat_t { default: UMat() } = nil): Single; cdecl;
Procedure  pCvGaussianBlur(src: PCvMat_t; dst: PCvMat_t; ksize: PCvSize_t; sigmaX: Double; 
                 sigmaY: Double { default: 0 } = 0; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvGaussianBlurV2(src: PCvUMat_t; dst: PCvUMat_t; ksize: PCvSize_t; sigmaX: Double; 
                 sigmaY: Double { default: 0 } = 0; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvHoughCircles(image: PCvMat_t; circles: PCvMat_t; method: Integer; dp: Double; 
                 minDist: Double; param1: Double { default: 100 } = 100; 
                 param2: Double { default: 100 } = 100; minRadius: Integer { default: 0 } = 0; 
                 maxRadius: Integer { default: 0 } = 0); cdecl;
Procedure  pCvHoughCirclesV2(image: PCvUMat_t; circles: PCvUMat_t; method: Integer; dp: Double; 
                 minDist: Double; param1: Double { default: 100 } = 100; 
                 param2: Double { default: 100 } = 100; minRadius: Integer { default: 0 } = 0; 
                 maxRadius: Integer { default: 0 } = 0); cdecl;
Procedure  pCvHoughLines(image: PCvMat_t; lines: PCvMat_t; rho: Double; theta: Double; 
                 threshold: Integer; srn: Double { default: 0 } = 0; stn: Double { default: 0 } = 0; 
                 min_theta: Double { default: 0 } = 0; max_theta: Double { default: CV_PI } = Pi); cdecl;
Procedure  pCvHoughLinesV2(image: PCvUMat_t; lines: PCvUMat_t; rho: Double; theta: Double; 
                 threshold: Integer; srn: Double { default: 0 } = 0; stn: Double { default: 0 } = 0; 
                 min_theta: Double { default: 0 } = 0; max_theta: Double { default: CV_PI } = Pi); cdecl;
Procedure  pCvHoughLinesP(image: PCvMat_t; lines: PCvMat_t; rho: Double; theta: Double; 
                 threshold: Integer; minLineLength: Double { default: 0 } = 0; 
                 maxLineGap: Double { default: 0 } = 0); cdecl;
Procedure  pCvHoughLinesPV2(image: PCvUMat_t; lines: PCvUMat_t; rho: Double; theta: Double; 
                 threshold: Integer; minLineLength: Double { default: 0 } = 0; 
                 maxLineGap: Double { default: 0 } = 0); cdecl;
Procedure  pCvHoughLinesPointSet(point: PCvMat_t; lines: PCvMat_t; lines_max: Integer; 
                 threshold: Integer; min_rho: Double; max_rho: Double; rho_step: Double; min_theta: Double; 
                 max_theta: Double; theta_step: Double); cdecl;
Procedure  pCvHoughLinesPointSetV2(point: PCvUMat_t; lines: PCvUMat_t; lines_max: Integer; 
                 threshold: Integer; min_rho: Double; max_rho: Double; rho_step: Double; 
                 min_theta: Double; max_theta: Double; theta_step: Double); cdecl;
Procedure  pCvHoughLinesWithAccumulator(image: PCvMat_t; lines: PCvMat_t; rho: Double; theta: Double; 
                 threshold: Integer; srn: Double { default: 0 } = 0; stn: Double { default: 0 } = 0; 
                 min_theta: Double { default: 0 } = 0; max_theta: Double { default: CV_PI } = Pi); cdecl;
Procedure  pCvHoughLinesWithAccumulatorV2(image: PCvUMat_t; lines: PCvUMat_t; rho: Double; theta: Double; 
                 threshold: Integer; srn: Double { default: 0 } = 0; 
                 stn: Double { default: 0 } = 0; min_theta: Double { default: 0 } = 0; 
                 max_theta: Double { default: CV_PI } = Pi); cdecl;
Procedure  pCvHuMoments(m: PCvMoments_t; hu: PCvMat_t); cdecl;
Procedure  pCvHuMomentsV2(m: PCvMoments_t; hu: PCvUMat_t); cdecl;
Procedure  pCvLUT(src: PCvMat_t; lut: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvLUTV2(src: PCvUMat_t; lut: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvLaplacian(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; ksize: Integer { default: 1 } = 1; 
                 scale: Double { default: 1 } = 1; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvLaplacianV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; 
                 ksize: Integer { default: 1 } = 1; scale: Double { default: 1 } = 1; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Function   pCvMahalanobis(v1: PCvMat_t; v2: PCvMat_t; icovar: PCvMat_t): Double; cdecl;
Function   pCvMahalanobisV2(v1: PCvUMat_t; v2: PCvUMat_t; icovar: PCvUMat_t): Double; cdecl;
Procedure  pCvPCABackProject(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; _result: PCvMat_t); cdecl;
Procedure  pCvPCABackProjectV2(data: PCvUMat_t; mean: PCvUMat_t; eigenvectors: PCvUMat_t; 
                 _result: PCvUMat_t); cdecl;
Procedure  pCvPCACompute(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; 
                 maxComponents: Integer { default: 0 } = 0); cdecl;
Procedure  pCvPCAComputeV2(data: PCvUMat_t; mean: PCvUMat_t; eigenvectors: PCvUMat_t; 
                 maxComponents: Integer { default: 0 } = 0); cdecl;
Procedure  pCvPCAComputeV3(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; 
                 retainedVariance: Double); cdecl;
Procedure  pCvPCAComputeV4(data: PCvUMat_t; mean: PCvUMat_t; eigenvectors: PCvUMat_t; 
                 retainedVariance: Double); cdecl;
Procedure  pCvPCACompute2(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; eigenvalues: PCvMat_t; 
                 maxComponents: Integer { default: 0 } = 0); cdecl;
Procedure  pCvPCACompute2V2(data: PCvUMat_t; mean: PCvUMat_t; eigenvectors: PCvUMat_t; 
                 eigenvalues: PCvUMat_t; maxComponents: Integer { default: 0 } = 0); cdecl;
Procedure  pCvPCACompute2V3(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; 
                 eigenvalues: PCvMat_t; retainedVariance: Double); cdecl;
Procedure  pCvPCACompute2V4(data: PCvUMat_t; mean: PCvUMat_t; eigenvectors: PCvUMat_t; 
                 eigenvalues: PCvUMat_t; retainedVariance: Double); cdecl;
Procedure  pCvPCAProject(data: PCvMat_t; mean: PCvMat_t; eigenvectors: PCvMat_t; _result: PCvMat_t); cdecl;
Procedure  pCvPCAProjectV2(data: PCvUMat_t; mean: PCvUMat_t; eigenvectors: PCvUMat_t; _result: PCvUMat_t); cdecl;
Function   pCvPSNR(src1: PCvMat_t; src2: PCvMat_t; R: Double { default: 255. } = 255.0): Double; cdecl;
Function   pCvPSNRV2(src1: PCvUMat_t; src2: PCvUMat_t; R: Double { default: 255. } = 255.0): Double; cdecl;
Function   pCvRQDecomp3x3(src: PCvMat_t; mtxR: PCvMat_t; mtxQ: PCvMat_t; 
                 Qx: PCvMat_t { default: Mat() } = nil; Qy: PCvMat_t { default: Mat() } = nil; Qz: PCvMat_t { default: Mat() } = nil): PCvVec3d_t; cdecl;
Function   pCvRQDecomp3x3V2(src: PCvUMat_t; mtxR: PCvUMat_t; mtxQ: PCvUMat_t; 
                 Qx: PCvUMat_t { default: UMat() } = nil; Qy: PCvUMat_t { default: UMat() } = nil; 
                 Qz: PCvUMat_t { default: UMat() } = nil): PCvVec3d_t; cdecl;
Procedure  pCvRodrigues(src: PCvMat_t; dst: PCvMat_t; jacobian: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvRodriguesV2(src: PCvUMat_t; dst: PCvUMat_t; jacobian: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvSVBackSubst(w: PCvMat_t; u: PCvMat_t; vt: PCvMat_t; rhs: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvSVBackSubstV2(w: PCvUMat_t; u: PCvUMat_t; vt: PCvUMat_t; rhs: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvSVDecomp(src: PCvMat_t; w: PCvMat_t; u: PCvMat_t; vt: PCvMat_t; 
                 flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvSVDecompV2(src: PCvUMat_t; w: PCvUMat_t; u: PCvUMat_t; vt: PCvUMat_t; 
                 flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvScharr(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; dx: Integer; dy: Integer; 
                 scale: Double { default: 1 } = 1; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvScharrV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; dx: Integer; dy: Integer; 
                 scale: Double { default: 1 } = 1; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvSobel(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; dx: Integer; dy: Integer; 
                 ksize: Integer { default: 3 } = 3; scale: Double { default: 1 } = 1; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvSobelV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; dx: Integer; dy: Integer; 
                 ksize: Integer { default: 3 } = 3; scale: Double { default: 1 } = 1; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvabsdiff(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvabsdiffV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvaccumulate(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvaccumulateV2(src: PCvUMat_t; dst: PCvUMat_t; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvaccumulateProduct(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvaccumulateProductV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvaccumulateSquare(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvaccumulateSquareV2(src: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvaccumulateWeighted(src: PCvMat_t; dst: PCvMat_t; alpha: Double; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvaccumulateWeightedV2(src: PCvUMat_t; dst: PCvUMat_t; alpha: Double; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvadaptiveThreshold(src: PCvMat_t; dst: PCvMat_t; maxValue: Double; adaptiveMethod: Integer; 
                 thresholdType: Integer; blockSize: Integer; C: Double); cdecl;
Procedure  pCvadaptiveThresholdV2(src: PCvUMat_t; dst: PCvUMat_t; maxValue: Double; 
                 adaptiveMethod: Integer; thresholdType: Integer; blockSize: Integer; C: Double); cdecl;
Procedure  pCvadd(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() } = nil; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvaddV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvaddText(img: PCvMat_t; text: PCvString_t; org: PCvPoint_t; nameFont: PCvString_t; 
                 pointSize: Integer { default: -1 } = ord(-1); color: PCvScalar_t { default: Scalar::all(0) } = nil; 
                 weight: Integer { default: QT_FONT_NORMAL } = ord(QT_FONT_NORMAL); style: Integer { default: QT_STYLE_NORMAL } = ord(QT_STYLE_NORMAL); 
                 spacing: Integer { default: 0 } = 0); cdecl;
Procedure  pCvaddWeighted(src1: PCvMat_t; alpha: Double; src2: PCvMat_t; beta: Double; gamma: Double; 
                 dst: PCvMat_t; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvaddWeightedV2(src1: PCvUMat_t; alpha: Double; src2: PCvUMat_t; beta: Double; gamma: Double; 
                 dst: PCvUMat_t; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvapplyColorMap(src: PCvMat_t; dst: PCvMat_t; colormap: Integer); cdecl;
Procedure  pCvapplyColorMapV2(src: PCvUMat_t; dst: PCvUMat_t; colormap: Integer); cdecl;
Procedure  pCvapplyColorMapV3(src: PCvMat_t; dst: PCvMat_t; userColor: PCvMat_t); cdecl;
Procedure  pCvapplyColorMapV4(src: PCvUMat_t; dst: PCvUMat_t; userColor: PCvUMat_t); cdecl;
Procedure  pCvapproxPolyDP(curve: PCvMat_t; approxCurve: PCvMat_t; epsilon: Double; closed: Boolean); cdecl;
Procedure  pCvapproxPolyDPV2(curve: PCvUMat_t; approxCurve: PCvUMat_t; epsilon: Double; closed: Boolean); cdecl;
Function   pCvarcLength(curve: PCvMat_t; closed: Boolean): Double; cdecl;
Function   pCvarcLengthV2(curve: PCvUMat_t; closed: Boolean): Double; cdecl;
Procedure  pCvarrowedLine(img: PCvMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; line_type: Integer { default: 8 } = 8; shift: Integer { default: 0 } = 0; 
                 tipLength: Double { default: 0.1 } = 0.1); cdecl;
Procedure  pCvarrowedLineV2(img: PCvUMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; line_type: Integer { default: 8 } = 8; shift: Integer { default: 0 } = 0; 
                 tipLength: Double { default: 0.1 } = 0.1); cdecl;
Procedure  pCvbatchDistance(src1: PCvMat_t; src2: PCvMat_t; dist: PCvMat_t; dtype: Integer; 
                 nidx: PCvMat_t; normType: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 K: Integer { default: 0 } = 0; mask: PCvMat_t { default: Mat() } = nil; 
                 update: Integer { default: 0 } = 0; crosscheck: Boolean { default: false } = false); cdecl;
Procedure  pCvbatchDistanceV2(src1: PCvUMat_t; src2: PCvUMat_t; dist: PCvUMat_t; dtype: Integer; 
                 nidx: PCvUMat_t; normType: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 K: Integer { default: 0 } = 0; mask: PCvUMat_t { default: UMat() } = nil; 
                 update: Integer { default: 0 } = 0; crosscheck: Boolean { default: false } = false); cdecl;
Procedure  pCvbilateralFilter(src: PCvMat_t; dst: PCvMat_t; d: Integer; sigmaColor: Double; 
                 sigmaSpace: Double; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvbilateralFilterV2(src: PCvUMat_t; dst: PCvUMat_t; d: Integer; sigmaColor: Double; 
                 sigmaSpace: Double; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvbitwise_and(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvbitwise_andV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvbitwise_not(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvbitwise_notV2(src: PCvUMat_t; dst: PCvUMat_t; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvbitwise_or(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvbitwise_orV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvbitwise_xor(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvbitwise_xorV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvblendLinear(src1: PCvMat_t; src2: PCvMat_t; weights1: PCvMat_t; weights2: PCvMat_t; 
                 dst: PCvMat_t); cdecl;
Procedure  pCvblendLinearV2(src1: PCvUMat_t; src2: PCvUMat_t; weights1: PCvUMat_t; weights2: PCvUMat_t; 
                 dst: PCvUMat_t); cdecl;
Procedure  pCvblur(src: PCvMat_t; dst: PCvMat_t; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvblurV2(src: PCvUMat_t; dst: PCvUMat_t; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Function   pCvborderInterpolate(p: Integer; len: Integer; borderType: Integer): Integer; cdecl;
Function   pCvboundingRect(_array: PCvMat_t): PCvRect_t; cdecl;
Function   pCvboundingRectV2(_array: PCvUMat_t): PCvRect_t; cdecl;
Procedure  pCvboxFilter(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; normalize: Boolean { default: true } = true; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvboxFilterV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; normalize: Boolean { default: true } = true; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvboxPoints(box: PCvRotatedRect_t; points: PCvMat_t); cdecl;
Procedure  pCvboxPointsV2(box: PCvRotatedRect_t; points: PCvUMat_t); cdecl;
Function   pCvbuildOpticalFlowPyramid(img: PCvMat_t; pyramid: PCvvector_Mat; winSize: PCvSize_t; 
                 maxLevel: Integer; withDerivatives: Boolean { default: true } = true; 
                 pyrBorder: Integer { default: BORDER_REFLECT_101 } = ord(BORDER_REFLECT_101); 
                 derivBorder: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); tryReuseInputImage: Boolean { default: true } = true): Integer; cdecl;
Function   pCvbuildOpticalFlowPyramidV2(img: PCvUMat_t; pyramid: PCvvector_UMat; winSize: PCvSize_t; 
                 maxLevel: Integer; withDerivatives: Boolean { default: true } = true; 
                 pyrBorder: Integer { default: BORDER_REFLECT_101 } = ord(BORDER_REFLECT_101); 
                 derivBorder: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); tryReuseInputImage: Boolean { default: true } = true): Integer; cdecl;
Procedure  pCvcalcBackProject(images: PCvvector_Mat; channels: PCvvector_int; hist: PCvMat_t; 
                 dst: PCvMat_t; ranges: PCvvector_float; scale: Double); cdecl;
Procedure  pCvcalcBackProjectV2(images: PCvvector_UMat; channels: PCvvector_int; hist: PCvUMat_t; 
                 dst: PCvUMat_t; ranges: PCvvector_float; scale: Double); cdecl;
Procedure  pCvcalcCovarMatrix(samples: PCvMat_t; covar: PCvMat_t; mean: PCvMat_t; flags: Integer; 
                 ctype: Integer { default: CV_64F } = ord(CV_64F)); cdecl;
Procedure  pCvcalcCovarMatrixV2(samples: PCvUMat_t; covar: PCvUMat_t; mean: PCvUMat_t; flags: Integer; 
                 ctype: Integer { default: CV_64F } = ord(CV_64F)); cdecl;
Procedure  pCvcalcHist(images: PCvvector_Mat; channels: PCvvector_int; mask: PCvMat_t; hist: PCvMat_t; 
                 histSize: PCvvector_int; ranges: PCvvector_float; accumulate: Boolean { default: false } = false); cdecl;
Procedure  pCvcalcHistV2(images: PCvvector_UMat; channels: PCvvector_int; mask: PCvUMat_t; 
                 hist: PCvUMat_t; histSize: PCvvector_int; ranges: PCvvector_float; 
                 accumulate: Boolean { default: false } = false); cdecl;
Procedure  pCvcalcOpticalFlowFarneback(prev: PCvMat_t; next: PCvMat_t; flow: PCvMat_t; pyr_scale: Double; 
                 levels: Integer; winsize: Integer; iterations: Integer; poly_n: Integer; 
                 poly_sigma: Double; flags: Integer); cdecl;
Procedure  pCvcalcOpticalFlowFarnebackV2(prev: PCvUMat_t; next: PCvUMat_t; flow: PCvUMat_t; 
                 pyr_scale: Double; levels: Integer; winsize: Integer; iterations: Integer; 
                 poly_n: Integer; poly_sigma: Double; flags: Integer); cdecl;
Procedure  pCvcalcOpticalFlowPyrLK(prevImg: PCvMat_t; nextImg: PCvMat_t; prevPts: PCvMat_t; 
                 nextPts: PCvMat_t; status: PCvMat_t; err: PCvMat_t; 
                 winSize: PCvSize_t { default: Size(21,21) } = nil; maxLevel: Integer { default: 3 } = 3; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01) } = nil; flags: Integer { default: 0 } = 0; 
                 minEigThreshold: Double { default: 1e-4 } = 1e-4); cdecl;
Procedure  pCvcalcOpticalFlowPyrLKV2(prevImg: PCvUMat_t; nextImg: PCvUMat_t; prevPts: PCvUMat_t; 
                 nextPts: PCvUMat_t; status: PCvUMat_t; err: PCvUMat_t; 
                 winSize: PCvSize_t { default: Size(21,21) } = nil; maxLevel: Integer { default: 3 } = 3; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01) } = nil; flags: Integer { default: 0 } = 0; 
                 minEigThreshold: Double { default: 1e-4 } = 1e-4); cdecl;
Function   pCvcalibrateCamera(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; 
                 imageSize: PCvSize_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; rvecs: PCvvector_Mat; 
                 tvecs: PCvvector_Mat; flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraV2(objectPoints: PCvvector_UMat; imagePoints: PCvvector_UMat; 
                 imageSize: PCvSize_t; cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; rvecs: PCvvector_UMat; 
                 tvecs: PCvvector_UMat; flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraExtended(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; 
                 imageSize: PCvSize_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; 
                 rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; stdDeviationsIntrinsics: PCvMat_t; 
                 stdDeviationsExtrinsics: PCvMat_t; perViewErrors: PCvMat_t; flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraExtendedV2(objectPoints: PCvvector_UMat; imagePoints: PCvvector_UMat; 
                 imageSize: PCvSize_t; cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; 
                 rvecs: PCvvector_UMat; tvecs: PCvvector_UMat; stdDeviationsIntrinsics: PCvUMat_t; 
                 stdDeviationsExtrinsics: PCvUMat_t; perViewErrors: PCvUMat_t; flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraRO(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; 
                 imageSize: PCvSize_t; iFixedPoint: Integer; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; 
                 rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; newObjPoints: PCvMat_t; 
                 flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraROV2(objectPoints: PCvvector_UMat; imagePoints: PCvvector_UMat; 
                 imageSize: PCvSize_t; iFixedPoint: Integer; cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; 
                 rvecs: PCvvector_UMat; tvecs: PCvvector_UMat; newObjPoints: PCvUMat_t; 
                 flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraROExtended(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; 
                 imageSize: PCvSize_t; iFixedPoint: Integer; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; 
                 newObjPoints: PCvMat_t; stdDeviationsIntrinsics: PCvMat_t; 
                 stdDeviationsExtrinsics: PCvMat_t; stdDeviationsObjPoints: PCvMat_t; perViewErrors: PCvMat_t; 
                 flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvcalibrateCameraROExtendedV2(objectPoints: PCvvector_UMat; imagePoints: PCvvector_UMat; 
                 imageSize: PCvSize_t; iFixedPoint: Integer; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; rvecs: PCvvector_UMat; tvecs: PCvvector_UMat; 
                 newObjPoints: PCvUMat_t; stdDeviationsIntrinsics: PCvUMat_t; 
                 stdDeviationsExtrinsics: PCvUMat_t; stdDeviationsObjPoints: PCvUMat_t; perViewErrors: PCvUMat_t; 
                 flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) } = nil): Double; cdecl;
Procedure  pCvcalibrateHandEye(R_gripper2base: PCvvector_Mat; t_gripper2base: PCvvector_Mat; 
                 R_target2cam: PCvvector_Mat; t_target2cam: PCvvector_Mat; R_cam2gripper: PCvMat_t; 
                 t_cam2gripper: PCvMat_t; 
                 method: TCvHandEyeCalibrationMethod { default: CALIB_HAND_EYE_TSAI } = TCvHandEyeCalibrationMethod.CALIB_HAND_EYE_TSAI); cdecl;
Procedure  pCvcalibrateHandEyeV2(R_gripper2base: PCvvector_UMat; t_gripper2base: PCvvector_UMat; 
                 R_target2cam: PCvvector_UMat; t_target2cam: PCvvector_UMat; R_cam2gripper: PCvUMat_t; 
                 t_cam2gripper: PCvUMat_t; 
                 method: TCvHandEyeCalibrationMethod { default: CALIB_HAND_EYE_TSAI } = TCvHandEyeCalibrationMethod.CALIB_HAND_EYE_TSAI); cdecl;
Procedure  pCvcalibrateRobotWorldHandEye(R_world2cam: PCvvector_Mat; t_world2cam: PCvvector_Mat; 
                 R_base2gripper: PCvvector_Mat; t_base2gripper: PCvvector_Mat; R_base2world: PCvMat_t; 
                 t_base2world: PCvMat_t; R_gripper2cam: PCvMat_t; t_gripper2cam: PCvMat_t; 
                 method: TCvRobotWorldHandEyeCalibrationMethod { default: CALIB_ROBOT_WORLD_HAND_EYE_SHAH } = TCvRobotWorldHandEyeCalibrationMethod.CALIB_ROBOT_WORLD_HAND_EYE_SHAH); cdecl;
Procedure  pCvcalibrateRobotWorldHandEyeV2(R_world2cam: PCvvector_UMat; t_world2cam: PCvvector_UMat; 
                 R_base2gripper: PCvvector_UMat; t_base2gripper: PCvvector_UMat; R_base2world: PCvUMat_t; 
                 t_base2world: PCvUMat_t; R_gripper2cam: PCvUMat_t; t_gripper2cam: PCvUMat_t; 
                 method: TCvRobotWorldHandEyeCalibrationMethod { default: CALIB_ROBOT_WORLD_HAND_EYE_SHAH } = TCvRobotWorldHandEyeCalibrationMethod.CALIB_ROBOT_WORLD_HAND_EYE_SHAH); cdecl;
Procedure  pCvcalibrationMatrixValues(cameraMatrix: PCvMat_t; imageSize: PCvSize_t; 
                 apertureWidth: Double; apertureHeight: Double; fovx: Double; fovy: Double; 
                 focalLength: Double; principalPoint: PCvPoint2d_t; aspectRatio: Double); cdecl;
Procedure  pCvcalibrationMatrixValuesV2(cameraMatrix: PCvUMat_t; imageSize: PCvSize_t; 
                 apertureWidth: Double; apertureHeight: Double; fovx: Double; fovy: Double; 
                 focalLength: Double; principalPoint: PCvPoint2d_t; aspectRatio: Double); cdecl;
Procedure  pCvcartToPolar(x: PCvMat_t; y: PCvMat_t; magnitude: PCvMat_t; angle: PCvMat_t; 
                 angleInDegrees: Boolean { default: false } = false); cdecl;
Procedure  pCvcartToPolarV2(x: PCvUMat_t; y: PCvUMat_t; magnitude: PCvUMat_t; angle: PCvUMat_t; 
                 angleInDegrees: Boolean { default: false } = false); cdecl;
Function   pCvcheckChessboard(img: PCvMat_t; size: PCvSize_t): Boolean; cdecl;
Function   pCvcheckChessboardV2(img: PCvUMat_t; size: PCvSize_t): Boolean; cdecl;
Function   pCvcheckHardwareSupport(feature: Integer): Boolean; cdecl;
Function   pCvcheckRange(a: PCvMat_t; quiet: Boolean { default: true } = true; 
                 _pos: PCvPoint_t { default: 0 } = 0; minVal: Double { default: -DBL_MAX } = -MAXDOUBLE; 
                 maxVal: Double { default: DBL_MAX } = MAXDOUBLE): Boolean; cdecl;
Function   pCvcheckRangeV2(a: PCvUMat_t; quiet: Boolean { default: true } = true; 
                 _pos: PCvPoint_t { default: 0 } = 0; minVal: Double { default: -DBL_MAX } = -MAXDOUBLE; 
                 maxVal: Double { default: DBL_MAX } = MAXDOUBLE): Boolean; cdecl;
Procedure  pCvcircle(img: PCvMat_t; center: PCvPoint_t; radius: Integer; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvcircleV2(img: PCvUMat_t; center: PCvPoint_t; radius: Integer; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Function   pCvclipLine(imgRect: PCvRect_t; pt1: PCvPoint_t; pt2: PCvPoint_t): Boolean; cdecl;
Procedure  pCvcolorChange(src: PCvMat_t; mask: PCvMat_t; dst: PCvMat_t; 
                 red_mul: Single { default: 1.0f } = 1.0; green_mul: Single { default: 1.0f } = 1.0; 
                 blue_mul: Single { default: 1.0f } = 1.0); cdecl;
Procedure  pCvcolorChangeV2(src: PCvUMat_t; mask: PCvUMat_t; dst: PCvUMat_t; 
                 red_mul: Single { default: 1.0f } = 1.0; green_mul: Single { default: 1.0f } = 1.0; 
                 blue_mul: Single { default: 1.0f } = 1.0); cdecl;
Procedure  pCvcompare(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; cmpop: Integer); cdecl;
Procedure  pCvcompareV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; cmpop: Integer); cdecl;
Function   pCvcompareHist(H1: PCvMat_t; H2: PCvMat_t; method: Integer): Double; cdecl;
Function   pCvcompareHistV2(H1: PCvUMat_t; H2: PCvUMat_t; method: Integer): Double; cdecl;
Procedure  pCvcompleteSymm(m: PCvMat_t; lowerToUpper: Boolean { default: false } = false); cdecl;
Procedure  pCvcompleteSymmV2(m: PCvUMat_t; lowerToUpper: Boolean { default: false } = false); cdecl;
Procedure  pCvcomposeRT(rvec1: PCvMat_t; tvec1: PCvMat_t; rvec2: PCvMat_t; tvec2: PCvMat_t; 
                 rvec3: PCvMat_t; tvec3: PCvMat_t; dr3dr1: PCvMat_t { default: Mat() } = nil; 
                 dr3dt1: PCvMat_t { default: Mat() } = nil; dr3dr2: PCvMat_t { default: Mat() } = nil; 
                 dr3dt2: PCvMat_t { default: Mat() } = nil; dt3dr1: PCvMat_t { default: Mat() } = nil; 
                 dt3dt1: PCvMat_t { default: Mat() } = nil; dt3dr2: PCvMat_t { default: Mat() } = nil; 
                 dt3dt2: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvcomposeRTV2(rvec1: PCvUMat_t; tvec1: PCvUMat_t; rvec2: PCvUMat_t; tvec2: PCvUMat_t; 
                 rvec3: PCvUMat_t; tvec3: PCvUMat_t; dr3dr1: PCvUMat_t { default: UMat() } = nil; 
                 dr3dt1: PCvUMat_t { default: UMat() } = nil; dr3dr2: PCvUMat_t { default: UMat() } = nil; 
                 dr3dt2: PCvUMat_t { default: UMat() } = nil; dt3dr1: PCvUMat_t { default: UMat() } = nil; 
                 dt3dt1: PCvUMat_t { default: UMat() } = nil; dt3dr2: PCvUMat_t { default: UMat() } = nil; 
                 dt3dt2: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvcomputeCorrespondEpilines(points: PCvMat_t; whichImage: Integer; F: PCvMat_t; 
                 lines: PCvMat_t); cdecl;
Procedure  pCvcomputeCorrespondEpilinesV2(points: PCvUMat_t; whichImage: Integer; F: PCvUMat_t; 
                 lines: PCvUMat_t); cdecl;
Function   pCvcomputeECC(templateImage: PCvMat_t; inputImage: PCvMat_t; 
                 inputMask: PCvMat_t { default: Mat() } = nil): Double; cdecl;
Function   pCvcomputeECCV2(templateImage: PCvUMat_t; inputImage: PCvUMat_t; 
                 inputMask: PCvUMat_t { default: UMat() } = nil): Double; cdecl;
Function   pCvconnectedComponents(image: PCvMat_t; labels: PCvMat_t; 
                 connectivity: Integer { default: 8 } = 8; ltype: Integer { default: CV_32S } = ord(CV_32S)): Integer; cdecl;
Function   pCvconnectedComponentsV2(image: PCvUMat_t; labels: PCvUMat_t; 
                 connectivity: Integer { default: 8 } = 8; ltype: Integer { default: CV_32S } = ord(CV_32S)): Integer; cdecl;
Function   pCvconnectedComponentsWithAlgorithm(image: PCvMat_t; labels: PCvMat_t; connectivity: Integer; 
                 ltype: Integer; ccltype: Integer): Integer; cdecl;
Function   pCvconnectedComponentsWithAlgorithmV2(image: PCvUMat_t; labels: PCvUMat_t; 
                 connectivity: Integer; ltype: Integer; ccltype: Integer): Integer; cdecl;
Function   pCvconnectedComponentsWithStats(image: PCvMat_t; labels: PCvMat_t; stats: PCvMat_t; 
                 centroids: PCvMat_t; connectivity: Integer { default: 8 } = 8; 
                 ltype: Integer { default: CV_32S } = ord(CV_32S)): Integer; cdecl;
Function   pCvconnectedComponentsWithStatsV2(image: PCvUMat_t; labels: PCvUMat_t; stats: PCvUMat_t; 
                 centroids: PCvUMat_t; connectivity: Integer { default: 8 } = 8; 
                 ltype: Integer { default: CV_32S } = ord(CV_32S)): Integer; cdecl;
Function   pCvconnectedComponentsWithStatsWithAlgorithm(image: PCvMat_t; labels: PCvMat_t; 
                 stats: PCvMat_t; centroids: PCvMat_t; connectivity: Integer; 
                 ltype: Integer; ccltype: Integer): Integer; cdecl;
Function   pCvconnectedComponentsWithStatsWithAlgorithmV2(image: PCvUMat_t; labels: PCvUMat_t; 
                 stats: PCvUMat_t; centroids: PCvUMat_t; connectivity: Integer; 
                 ltype: Integer; ccltype: Integer): Integer; cdecl;
Function   pCvcontourArea(contour: PCvMat_t; oriented: Boolean { default: false } = false): Double; cdecl;
Function   pCvcontourAreaV2(contour: PCvUMat_t; oriented: Boolean { default: false } = false): Double; cdecl;
Procedure  pCvconvertFp16(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvconvertFp16V2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvconvertMaps(map1: PCvMat_t; map2: PCvMat_t; dstmap1: PCvMat_t; dstmap2: PCvMat_t; 
                 dstmap1type: Integer; nninterpolation: Boolean { default: false } = false); cdecl;
Procedure  pCvconvertMapsV2(map1: PCvUMat_t; map2: PCvUMat_t; dstmap1: PCvUMat_t; dstmap2: PCvUMat_t; 
                 dstmap1type: Integer; nninterpolation: Boolean { default: false } = false); cdecl;
Procedure  pCvconvertPointsFromHomogeneous(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvconvertPointsFromHomogeneousV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvconvertPointsToHomogeneous(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvconvertPointsToHomogeneousV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvconvertScaleAbs(src: PCvMat_t; dst: PCvMat_t; alpha: Double { default: 1 } = 1; 
                 beta: Double { default: 0 } = 0); cdecl;
Procedure  pCvconvertScaleAbsV2(src: PCvUMat_t; dst: PCvUMat_t; alpha: Double { default: 1 } = 1; 
                 beta: Double { default: 0 } = 0); cdecl;
Procedure  pCvconvexHull(points: PCvMat_t; hull: PCvMat_t; clockwise: Boolean { default: false } = false; 
                 returnPoints: Boolean { default: true } = true); cdecl;
Procedure  pCvconvexHullV2(points: PCvUMat_t; hull: PCvUMat_t; 
                 clockwise: Boolean { default: false } = false; returnPoints: Boolean { default: true } = true); cdecl;
Procedure  pCvconvexityDefects(contour: PCvMat_t; convexhull: PCvMat_t; convexityDefects: PCvMat_t); cdecl;
Procedure  pCvconvexityDefectsV2(contour: PCvUMat_t; convexhull: PCvUMat_t; convexityDefects: PCvUMat_t); cdecl;
Procedure  pCvcopyMakeBorder(src: PCvMat_t; dst: PCvMat_t; top: Integer; bottom: Integer; left: Integer; 
                 right: Integer; borderType: Integer; value: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvcopyMakeBorderV2(src: PCvUMat_t; dst: PCvUMat_t; top: Integer; bottom: Integer; 
                 left: Integer; right: Integer; borderType: Integer; 
                 value: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvcopyTo(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t); cdecl;
Procedure  pCvcopyToV2(src: PCvUMat_t; dst: PCvUMat_t; mask: PCvUMat_t); cdecl;
Procedure  pCvcornerEigenValsAndVecs(src: PCvMat_t; dst: PCvMat_t; blockSize: Integer; ksize: Integer; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvcornerEigenValsAndVecsV2(src: PCvUMat_t; dst: PCvUMat_t; blockSize: Integer; 
                 ksize: Integer; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvcornerHarris(src: PCvMat_t; dst: PCvMat_t; blockSize: Integer; ksize: Integer; k: Double; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvcornerHarrisV2(src: PCvUMat_t; dst: PCvUMat_t; blockSize: Integer; ksize: Integer; 
                 k: Double; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvcornerMinEigenVal(src: PCvMat_t; dst: PCvMat_t; blockSize: Integer; 
                 ksize: Integer { default: 3 } = 3; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvcornerMinEigenValV2(src: PCvUMat_t; dst: PCvUMat_t; blockSize: Integer; 
                 ksize: Integer { default: 3 } = 3; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvcornerSubPix(image: PCvMat_t; corners: PCvMat_t; winSize: PCvSize_t; zeroZone: PCvSize_t; 
                 criteria: PCvTermCriteria_t); cdecl;
Procedure  pCvcornerSubPixV2(image: PCvUMat_t; corners: PCvUMat_t; winSize: PCvSize_t; 
                 zeroZone: PCvSize_t; criteria: PCvTermCriteria_t); cdecl;
Procedure  pCvcorrectMatches(F: PCvMat_t; points1: PCvMat_t; points2: PCvMat_t; newPoints1: PCvMat_t; 
                 newPoints2: PCvMat_t); cdecl;
Procedure  pCvcorrectMatchesV2(F: PCvUMat_t; points1: PCvUMat_t; points2: PCvUMat_t; 
                 newPoints1: PCvUMat_t; newPoints2: PCvUMat_t); cdecl;
Function   pCvcountNonZero(src: PCvMat_t): Integer; cdecl;
Function   pCvcountNonZeroV2(src: PCvUMat_t): Integer; cdecl;
Function   pCvcreateAlignMTB(max_bits: Integer { default: 6 } = 6; 
                 exclude_range: Integer { default: 4 } = 4; cut: Boolean { default: true } = true): PCvPtr_AlignMTB; cdecl;
Function   pCvcreateBackgroundSubtractorKNN(history: Integer { default: 500 } = 500; 
                 dist2Threshold: Double { default: 400.0 } = 400.0; detectShadows: Boolean { default: true } = true): PCvPtr_BackgroundSubtractorKNN; cdecl;
Function   pCvcreateBackgroundSubtractorMOG2(history: Integer { default: 500 } = 500; 
                 varThreshold: Double { default: 16 } = 16; detectShadows: Boolean { default: true } = true): PCvPtr_BackgroundSubtractorMOG2; cdecl;
Function   pCvcreateCLAHE(clipLimit: Double { default: 40.0 } = 40.0; 
                 tileGridSize: PCvSize_t { default: Size(8, 8) } = nil): PCvPtr_CLAHE; cdecl;
Function   pCvcreateCalibrateDebevec(samples: Integer { default: 70 } = 70; 
                 lambda: Single { default: 10.0f } = 10.0; _random: Boolean { default: false } = false): PCvPtr_CalibrateDebevec; cdecl;
Function   pCvcreateCalibrateRobertson(max_iter: Integer { default: 30 } = 30; 
                 threshold: Single { default: 0.01f } = 0.01): PCvPtr_CalibrateRobertson; cdecl;
Function   pCvcreateGeneralizedHoughBallard(): PCvPtr_GeneralizedHoughBallard; cdecl;
Function   pCvcreateGeneralizedHoughGuil(): PCvPtr_GeneralizedHoughGuil; cdecl;
Procedure  pCvcreateHanningWindow(dst: PCvMat_t; winSize: PCvSize_t; _type: Integer); cdecl;
Procedure  pCvcreateHanningWindowV2(dst: PCvUMat_t; winSize: PCvSize_t; _type: Integer); cdecl;
Function   pCvcreateLineSegmentDetector(
                 refine: Integer { default: LSD_REFINE_STD } = ord(LSD_REFINE_STD); scale: Double { default: 0.8 } = 0.8; 
                 sigma_scale: Double { default: 0.6 } = 0.6; quant: Double { default: 2.0 } = 2.0; 
                 ang_th: Double { default: 22.5 } = 22.5; log_eps: Double { default: 0 } = 0; 
                 density_th: Double { default: 0.7 } = 0.7; n_bins: Integer { default: 1024 } = 1024): PCvPtr_LineSegmentDetector; cdecl;
Function   pCvcreateMergeDebevec(): PCvPtr_MergeDebevec; cdecl;
Function   pCvcreateMergeMertens(contrast_weight: Single { default: 1.0f } = 1.0; 
                 saturation_weight: Single { default: 1.0f } = 1.0; exposure_weight: Single { default: 0.0f } = 0.0): PCvPtr_MergeMertens; cdecl;
Function   pCvcreateMergeRobertson(): PCvPtr_MergeRobertson; cdecl;
Function   pCvcreateTonemap(gamma: Single { default: 1.0f } = 1.0): PCvPtr_Tonemap; cdecl;
Function   pCvcreateTonemapDrago(gamma: Single { default: 1.0f } = 1.0; 
                 saturation: Single { default: 1.0f } = 1.0; bias: Single { default: 0.85f } = 0.85): PCvPtr_TonemapDrago; cdecl;
Function   pCvcreateTonemapMantiuk(gamma: Single { default: 1.0f } = 1.0; 
                 scale: Single { default: 0.7f } = 0.7; saturation: Single { default: 1.0f } = 1.0): PCvPtr_TonemapMantiuk; cdecl;
Function   pCvcreateTonemapReinhard(gamma: Single { default: 1.0f } = 1.0; 
                 intensity: Single { default: 0.0f } = 0.0; light_adapt: Single { default: 1.0f } = 1.0; 
                 color_adapt: Single { default: 0.0f } = 0.0): PCvPtr_TonemapReinhard; cdecl;
Function   pCvcubeRoot(_val: Single): Single; cdecl;
Procedure  pCvcvtColor(src: PCvMat_t; dst: PCvMat_t; code: Integer; dstCn: Integer { default: 0 } = 0); cdecl;
Procedure  pCvcvtColorV2(src: PCvUMat_t; dst: PCvUMat_t; code: Integer; 
                 dstCn: Integer { default: 0 } = 0); cdecl;
Procedure  pCvcvtColorTwoPlane(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; code: Integer); cdecl;
Procedure  pCvcvtColorTwoPlaneV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; code: Integer); cdecl;
Procedure  pCvdct(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdctV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdecolor(src: PCvMat_t; grayscale: PCvMat_t; color_boost: PCvMat_t); cdecl;
Procedure  pCvdecolorV2(src: PCvUMat_t; grayscale: PCvUMat_t; color_boost: PCvUMat_t); cdecl;
Procedure  pCvdecomposeEssentialMat(E: PCvMat_t; R1: PCvMat_t; R2: PCvMat_t; t: PCvMat_t); cdecl;
Procedure  pCvdecomposeEssentialMatV2(E: PCvUMat_t; R1: PCvUMat_t; R2: PCvUMat_t; t: PCvUMat_t); cdecl;
Function   pCvdecomposeHomographyMat(H: PCvMat_t; K: PCvMat_t; rotations: PCvvector_Mat; 
                 translations: PCvvector_Mat; normals: PCvvector_Mat): Integer; cdecl;
Function   pCvdecomposeHomographyMatV2(H: PCvUMat_t; K: PCvUMat_t; rotations: PCvvector_UMat; 
                 translations: PCvvector_UMat; normals: PCvvector_UMat): Integer; cdecl;
Procedure  pCvdecomposeProjectionMatrix(projMatrix: PCvMat_t; cameraMatrix: PCvMat_t; 
                 rotMatrix: PCvMat_t; transVect: PCvMat_t; 
                 rotMatrixX: PCvMat_t { default: Mat() } = nil; rotMatrixY: PCvMat_t { default: Mat() } = nil; 
                 rotMatrixZ: PCvMat_t { default: Mat() } = nil; eulerAngles: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvdecomposeProjectionMatrixV2(projMatrix: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 rotMatrix: PCvUMat_t; transVect: PCvUMat_t; 
                 rotMatrixX: PCvUMat_t { default: UMat() } = nil; rotMatrixY: PCvUMat_t { default: UMat() } = nil; 
                 rotMatrixZ: PCvUMat_t { default: UMat() } = nil; eulerAngles: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvdemosaicing(src: PCvMat_t; dst: PCvMat_t; code: Integer; dstCn: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdemosaicingV2(src: PCvUMat_t; dst: PCvUMat_t; code: Integer; 
                 dstCn: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdenoise_TVL1(observations: PCvvector_Mat; _result: PCvMat_t; 
                 lambda: Double { default: 1.0 } = 1.0; niters: Integer { default: 30 } = 30); cdecl;
Procedure  pCvdestroyAllWindows(); cdecl;
Procedure  pCvdestroyWindow(winname: PCvString_t); cdecl;
Procedure  pCvdetailEnhance(src: PCvMat_t; dst: PCvMat_t; sigma_s: Single { default: 10 } = 10; 
                 sigma_r: Single { default: 0.15f } = 0.15); cdecl;
Procedure  pCvdetailEnhanceV2(src: PCvUMat_t; dst: PCvUMat_t; sigma_s: Single { default: 10 } = 10; 
                 sigma_r: Single { default: 0.15f } = 0.15); cdecl;
Procedure  pCvdetail_computeImageFeatures(featuresFinder: PCvPtr_Feature2D; images: PCvvector_Mat; 
                 features: PCvvector_ImageFeatures; masks: PCvvector_Mat { default: vector_Mat() } = nil); cdecl;
Procedure  pCvdetail_computeImageFeaturesV2(featuresFinder: PCvPtr_Feature2D; images: PCvvector_UMat; 
                 features: PCvvector_ImageFeatures; masks: PCvvector_UMat { default: vector_UMat() } = nil); cdecl;
Procedure  pCvdetail_computeImageFeatures2(featuresFinder: PCvPtr_Feature2D; image: PCvMat_t; 
                 features: PCvdetail_ImageFeatures_t; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvdetail_computeImageFeatures2V2(featuresFinder: PCvPtr_Feature2D; image: PCvUMat_t; 
                 features: PCvdetail_ImageFeatures_t; mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvdetail_createLaplacePyr(img: PCvMat_t; num_levels: Integer; pyr: PCvvector_UMat); cdecl;
Procedure  pCvdetail_createLaplacePyrV2(img: PCvUMat_t; num_levels: Integer; pyr: PCvvector_UMat); cdecl;
Procedure  pCvdetail_createLaplacePyrGpu(img: PCvMat_t; num_levels: Integer; pyr: PCvvector_UMat); cdecl;
Procedure  pCvdetail_createLaplacePyrGpuV2(img: PCvUMat_t; num_levels: Integer; pyr: PCvvector_UMat); cdecl;
Procedure  pCvdetail_createWeightMap(mask: PCvMat_t; sharpness: Single; weight: PCvMat_t); cdecl;
Procedure  pCvdetail_createWeightMapV2(mask: PCvUMat_t; sharpness: Single; weight: PCvUMat_t); cdecl;
Function   pCvdetail_leaveBiggestComponent(features: PCvvector_ImageFeatures; 
                 pairwise_matches: PCvvector_MatchesInfo; conf_threshold: Single): PCvvector_int; cdecl;
Function   pCvdetail_matchesGraphAsString(pathes: PCvvector_String; 
                 pairwise_matches: PCvvector_MatchesInfo; conf_threshold: Single): PCvString_t; cdecl;
Procedure  pCvdetail_normalizeUsingWeightMap(weight: PCvMat_t; src: PCvMat_t); cdecl;
Procedure  pCvdetail_normalizeUsingWeightMapV2(weight: PCvUMat_t; src: PCvUMat_t); cdecl;
Procedure  pCvdetail_restoreImageFromLaplacePyr(pyr: PCvvector_UMat); cdecl;
Procedure  pCvdetail_restoreImageFromLaplacePyrGpu(pyr: PCvvector_UMat); cdecl;
Procedure  pCvdetail_waveCorrect(rmats: PCvvector_Mat; kind: TCvdetail_WaveCorrectKind); cdecl;
Function   pCvdeterminant(mtx: PCvMat_t): Double; cdecl;
Function   pCvdeterminantV2(mtx: PCvUMat_t): Double; cdecl;
Procedure  pCvdft(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 } = 0; 
                 nonzeroRows: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdftV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer { default: 0 } = 0; 
                 nonzeroRows: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdilate(src: PCvMat_t; dst: PCvMat_t; kernel: PCvMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; iterations: Integer { default: 1 } = 1; 
                 borderType: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() } = nil); cdecl;
Procedure  pCvdilateV2(src: PCvUMat_t; dst: PCvUMat_t; kernel: PCvUMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; iterations: Integer { default: 1 } = 1; 
                 borderType: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() } = nil); cdecl;
Procedure  pCvdisplayOverlay(winname: PCvString_t; text: PCvString_t; 
                 delayms: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdisplayStatusBar(winname: PCvString_t; text: PCvString_t; 
                 delayms: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdistanceTransform(src: PCvMat_t; dst: PCvMat_t; distanceType: Integer; maskSize: Integer; 
                 dstType: Integer { default: CV_32F } = ord(CV_32F)); cdecl;
Procedure  pCvdistanceTransformV2(src: PCvUMat_t; dst: PCvUMat_t; distanceType: Integer; 
                 maskSize: Integer; dstType: Integer { default: CV_32F } = ord(CV_32F)); cdecl;
Procedure  pCvdistanceTransformWithLabels(src: PCvMat_t; dst: PCvMat_t; labels: PCvMat_t; 
                 distanceType: Integer; maskSize: Integer; 
                 labelType: Integer { default: DIST_LABEL_CCOMP } = ord(DIST_LABEL_CCOMP)); cdecl;
Procedure  pCvdistanceTransformWithLabelsV2(src: PCvUMat_t; dst: PCvUMat_t; labels: PCvUMat_t; 
                 distanceType: Integer; maskSize: Integer; 
                 labelType: Integer { default: DIST_LABEL_CCOMP } = ord(DIST_LABEL_CCOMP)); cdecl;
Procedure  pCvdivSpectrums(a: PCvMat_t; b: PCvMat_t; c: PCvMat_t; flags: Integer; 
                 conjB: Boolean { default: false } = false); cdecl;
Procedure  pCvdivSpectrumsV2(a: PCvUMat_t; b: PCvUMat_t; c: PCvUMat_t; flags: Integer; 
                 conjB: Boolean { default: false } = false); cdecl;
Procedure  pCvdivide(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; scale: Double { default: 1 } = 1; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvdivideV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 scale: Double { default: 1 } = 1; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvdivideV3(scale: Double; src2: PCvMat_t; dst: PCvMat_t; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvdivideV4(scale: Double; src2: PCvUMat_t; dst: PCvUMat_t; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvdnn_NMSBoxes(bboxes: PCvvector_Rect2d; scores: PCvvector_float; score_threshold: Single; 
                 nms_threshold: Single; indices: PCvvector_int; eta: Single { default: 1.f } = 1.0; 
                 top_k: Integer { default: 0 } = 0); cdecl;
Procedure  pCvdnn_NMSBoxesRotated(bboxes: PCvvector_RotatedRect; scores: PCvvector_float; 
                 score_threshold: Single; nms_threshold: Single; indices: PCvvector_int; 
                 eta: Single { default: 1.f } = 1.0; top_k: Integer { default: 0 } = 0); cdecl;
Function   pCvdnn_blobFromImage(image: PCvMat_t; scalefactor: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false; 
                 ddepth: Integer { default: CV_32F } = ord(CV_32F)): PCvMat_t; cdecl;
Function   pCvdnn_blobFromImageV2(image: PCvUMat_t; scalefactor: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false; 
                 ddepth: Integer { default: CV_32F } = ord(CV_32F)): PCvMat_t; cdecl;
Function   pCvdnn_blobFromImages(images: PCvvector_Mat; scalefactor: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false; 
                 ddepth: Integer { default: CV_32F } = ord(CV_32F)): PCvMat_t; cdecl;
Function   pCvdnn_blobFromImagesV2(images: PCvvector_UMat; scalefactor: Double { default: 1.0 } = 1.0; 
                 size: PCvSize_t { default: Size() } = nil; mean: PCvScalar_t { default: Scalar() } = nil; 
                 swapRB: Boolean { default: false } = false; crop: Boolean { default: false } = false; 
                 ddepth: Integer { default: CV_32F } = ord(CV_32F)): PCvMat_t; cdecl;
Function   pCvdnn_getAvailableTargets(be: TCvdnn_Backend): PCvvector_Target; cdecl;
Procedure  pCvdnn_imagesFromBlob(blob_: PCvMat_t; images_: PCvvector_Mat); cdecl;
Procedure  pCvdnn_imagesFromBlobV2(blob_: PCvMat_t; images_: PCvvector_UMat); cdecl;
Function   pCvdnn_readNet(model: PCvString_t; config: PCvString_t { default: "" } = nil; 
                 framework: PCvString_t { default: "" } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetV2(framework: PCvString_t; bufferModel: PCvvector_uchar; 
                 bufferConfig: PCvvector_uchar { default: std::vector<uchar>() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromCaffe(prototxt: PCvString_t; 
                 caffeModel: PCvString_t { default: String() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromCaffeV2(bufferProto: PCvvector_uchar; 
                 bufferModel: PCvvector_uchar { default: std::vector<uchar>() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromDarknet(cfgFile: PCvString_t; 
                 darknetModel: PCvString_t { default: String() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromDarknetV2(bufferCfg: PCvvector_uchar; 
                 bufferModel: PCvvector_uchar { default: std::vector<uchar>() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromModelOptimizer(xml: PCvString_t; bin: PCvString_t): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromModelOptimizerV2(bufferModelConfig: PCvvector_uchar; 
                 bufferWeights: PCvvector_uchar): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromONNX(onnxFile: PCvString_t): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromONNXV2(buffer: PCvvector_uchar): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromTensorflow(model: PCvString_t; 
                 config: PCvString_t { default: String() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromTensorflowV2(bufferModel: PCvvector_uchar; 
                 bufferConfig: PCvvector_uchar { default: std::vector<uchar>() } = nil): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readNetFromTorch(model: PCvString_t; isBinary: Boolean { default: true } = true; 
                 evaluate: Boolean { default: true } = true): PCvdnn_Net_t; cdecl;
Function   pCvdnn_readTensorFromONNX(path: PCvString_t): PCvMat_t; cdecl;
Function   pCvdnn_readTorchBlob(filename: PCvString_t; isBinary: Boolean { default: true } = true): PCvMat_t; cdecl;
Procedure  pCvdnn_shrinkCaffeModel(src: PCvString_t; dst: PCvString_t; 
                 layersTypes: PCvvector_String { default: std::vector<String>() } = nil); cdecl;
Procedure  pCvdnn_softNMSBoxes(bboxes: PCvvector_Rect; scores: PCvvector_float; 
                 updated_scores: PCvvector_float; score_threshold: Single; nms_threshold: Single; indices: PCvvector_int; 
                 top_k: UInt64 { default: 0 } = 0; sigma: Single { default: 0.5 } = 0.5; 
                 method: TCvdnn_SoftNMSMethod { default: SoftNMSMethod::SOFTNMS_GAUSSIAN } = TCvdnn_SoftNMSMethod._SOFTNMS_GAUSSIAN); cdecl;
Procedure  pCvdnn_writeTextGraph(model: PCvString_t; output: PCvString_t); cdecl;
Procedure  pCvdrawChessboardCorners(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; 
                 patternWasFound: Boolean); cdecl;
Procedure  pCvdrawChessboardCornersV2(image: PCvUMat_t; patternSize: PCvSize_t; corners: PCvUMat_t; 
                 patternWasFound: Boolean); cdecl;
Procedure  pCvdrawContours(image: PCvMat_t; contours: PCvvector_Mat; contourIdx: Integer; 
                 color: PCvScalar_t; thickness: Integer { default: 1 } = 1; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); hierarchy: PCvMat_t { default: Mat() } = nil; 
                 maxLevel: Integer { default: INT_MAX } = MAXINT; offset: PCvPoint_t { default: Point() } = nil); cdecl;
Procedure  pCvdrawContoursV2(image: PCvUMat_t; contours: PCvvector_UMat; contourIdx: Integer; 
                 color: PCvScalar_t; thickness: Integer { default: 1 } = 1; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); hierarchy: PCvUMat_t { default: UMat() } = nil; 
                 maxLevel: Integer { default: INT_MAX } = MAXINT; offset: PCvPoint_t { default: Point() } = nil); cdecl;
Procedure  pCvdrawFrameAxes(image: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; 
                 rvec: PCvMat_t; tvec: PCvMat_t; length: Single; thickness: Integer { default: 3 } = 3); cdecl;
Procedure  pCvdrawFrameAxesV2(image: PCvUMat_t; cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; 
                 rvec: PCvUMat_t; tvec: PCvUMat_t; length: Single; thickness: Integer { default: 3 } = 3); cdecl;
Procedure  pCvdrawKeypoints(image: PCvMat_t; keypoints: PCvvector_KeyPoint; outImage: PCvMat_t; 
                 color: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawKeypointsV2(image: PCvUMat_t; keypoints: PCvvector_KeyPoint; outImage: PCvUMat_t; 
                 color: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawMarker(img: PCvMat_t; position: PCvPoint_t; color: PCvScalar_t; 
                 markerType: Integer { default: MARKER_CROSS } = ord(MARKER_CROSS); markerSize: Integer { default: 20 } = 20; 
                 thickness: Integer { default: 1 } = 1; line_type: Integer { default: 8 } = 8); cdecl;
Procedure  pCvdrawMarkerV2(img: PCvUMat_t; position: PCvPoint_t; color: PCvScalar_t; 
                 markerType: Integer { default: MARKER_CROSS } = ord(MARKER_CROSS); markerSize: Integer { default: 20 } = 20; 
                 thickness: Integer { default: 1 } = 1; line_type: Integer { default: 8 } = 8); cdecl;
Procedure  pCvdrawMatches(img1: PCvMat_t; keypoints1: PCvvector_KeyPoint; img2: PCvMat_t; 
                 keypoints2: PCvvector_KeyPoint; matches1to2: PCvvector_DMatch; outImg: PCvMat_t; 
                 matchColor: PCvScalar_t { default: Scalar::all(-1) } = nil; singlePointColor: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 matchesMask: PCvvector_char { default: std::vector<char>() } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawMatchesV2(img1: PCvUMat_t; keypoints1: PCvvector_KeyPoint; img2: PCvUMat_t; 
                 keypoints2: PCvvector_KeyPoint; matches1to2: PCvvector_DMatch; outImg: PCvUMat_t; 
                 matchColor: PCvScalar_t { default: Scalar::all(-1) } = nil; singlePointColor: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 matchesMask: PCvvector_char { default: std::vector<char>() } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawMatchesV3(img1: PCvMat_t; keypoints1: PCvvector_KeyPoint; img2: PCvMat_t; 
                 keypoints2: PCvvector_KeyPoint; matches1to2: PCvvector_DMatch; outImg: PCvMat_t; matchesThickness: Integer; 
                 matchColor: PCvScalar_t { default: Scalar::all(-1) } = nil; singlePointColor: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 matchesMask: PCvvector_char { default: std::vector<char>() } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawMatchesV4(img1: PCvUMat_t; keypoints1: PCvvector_KeyPoint; img2: PCvUMat_t; 
                 keypoints2: PCvvector_KeyPoint; matches1to2: PCvvector_DMatch; outImg: PCvUMat_t; 
                 matchesThickness: Integer; matchColor: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 singlePointColor: PCvScalar_t { default: Scalar::all(-1) } = nil; matchesMask: PCvvector_char { default: std::vector<char>() } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawMatchesKnn(img1: PCvMat_t; keypoints1: PCvvector_KeyPoint; img2: PCvMat_t; 
                 keypoints2: PCvvector_KeyPoint; matches1to2: PCvvector_vector_DMatch; outImg: PCvMat_t; 
                 matchColor: PCvScalar_t { default: Scalar::all(-1) } = nil; singlePointColor: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 matchesMask: PCvvector_vector_char { default: std::vector<std::vector<char> >() } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvdrawMatchesKnnV2(img1: PCvUMat_t; keypoints1: PCvvector_KeyPoint; img2: PCvUMat_t; 
                 keypoints2: PCvvector_KeyPoint; matches1to2: PCvvector_vector_DMatch; outImg: PCvUMat_t; 
                 matchColor: PCvScalar_t { default: Scalar::all(-1) } = nil; singlePointColor: PCvScalar_t { default: Scalar::all(-1) } = nil; 
                 matchesMask: PCvvector_vector_char { default: std::vector<std::vector<char> >() } = nil; 
                 flags: TCvDrawMatchesFlags { default: DrawMatchesFlags::DEFAULT } = TCvDrawMatchesFlags._DEFAULT); cdecl;
Procedure  pCvedgePreservingFilter(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 1 } = 1; 
                 sigma_s: Single { default: 60 } = 60; sigma_r: Single { default: 0.4f } = 0.4); cdecl;
Procedure  pCvedgePreservingFilterV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer { default: 1 } = 1; 
                 sigma_s: Single { default: 60 } = 60; sigma_r: Single { default: 0.4f } = 0.4); cdecl;
Function   pCveigen(src: PCvMat_t; eigenvalues: PCvMat_t; 
                 eigenvectors: PCvMat_t { default: Mat() } = nil): Boolean; cdecl;
Function   pCveigenV2(src: PCvUMat_t; eigenvalues: PCvUMat_t; 
                 eigenvectors: PCvUMat_t { default: UMat() } = nil): Boolean; cdecl;
Procedure  pCveigenNonSymmetric(src: PCvMat_t; eigenvalues: PCvMat_t; eigenvectors: PCvMat_t); cdecl;
Procedure  pCveigenNonSymmetricV2(src: PCvUMat_t; eigenvalues: PCvUMat_t; eigenvectors: PCvUMat_t); cdecl;
Procedure  pCvellipse(img: PCvMat_t; center: PCvPoint_t; axes: PCvSize_t; angle: Double; 
                 startAngle: Double; endAngle: Double; color: PCvScalar_t; thickness: Integer { default: 1 } = 1; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvellipseV2(img: PCvUMat_t; center: PCvPoint_t; axes: PCvSize_t; angle: Double; 
                 startAngle: Double; endAngle: Double; color: PCvScalar_t; thickness: Integer { default: 1 } = 1; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvellipseV3(img: PCvMat_t; box: PCvRotatedRect_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8)); cdecl;
Procedure  pCvellipseV4(img: PCvUMat_t; box: PCvRotatedRect_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8)); cdecl;
Procedure  pCvellipse2Poly(center: PCvPoint_t; axes: PCvSize_t; angle: Integer; arcStart: Integer; 
                 arcEnd: Integer; delta: Integer; pts: PCvvector_Point); cdecl;
Procedure  pCvequalizeHist(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvequalizeHistV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCverode(src: PCvMat_t; dst: PCvMat_t; kernel: PCvMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; iterations: Integer { default: 1 } = 1; 
                 borderType: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() } = nil); cdecl;
Procedure  pCverodeV2(src: PCvUMat_t; dst: PCvUMat_t; kernel: PCvUMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; iterations: Integer { default: 1 } = 1; 
                 borderType: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() } = nil); cdecl;
Function   pCvestimateAffine2D(from: PCvMat_t; _to: PCvMat_t; inliers: PCvMat_t { default: Mat() } = nil; 
                 method: Integer { default: RANSAC } = ord(RANSAC); ransacReprojThreshold: Double { default: 3 } = 3; 
                 maxIters: UInt64 { default: 2000 } = 2000; confidence: Double { default: 0.99 } = 0.99; 
                 refineIters: UInt64 { default: 10 } = 10): PCvMat_t; cdecl;
Function   pCvestimateAffine2DV2(from: PCvUMat_t; _to: PCvUMat_t; 
                 inliers: PCvUMat_t { default: UMat() } = nil; method: Integer { default: RANSAC } = ord(RANSAC); 
                 ransacReprojThreshold: Double { default: 3 } = 3; maxIters: UInt64 { default: 2000 } = 2000; 
                 confidence: Double { default: 0.99 } = 0.99; refineIters: UInt64 { default: 10 } = 10): PCvMat_t; cdecl;
Function   pCvestimateAffine2DV3(pts1: PCvMat_t; pts2: PCvMat_t; inliers: PCvMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvestimateAffine2DV4(pts1: PCvUMat_t; pts2: PCvUMat_t; inliers: PCvUMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvestimateAffine3D(src: PCvMat_t; dst: PCvMat_t; _out: PCvMat_t; inliers: PCvMat_t; 
                 ransacThreshold: Double { default: 3 } = 3; confidence: Double { default: 0.99 } = 0.99): Integer; cdecl;
Function   pCvestimateAffine3DV2(src: PCvUMat_t; dst: PCvUMat_t; _out: PCvUMat_t; inliers: PCvUMat_t; 
                 ransacThreshold: Double { default: 3 } = 3; confidence: Double { default: 0.99 } = 0.99): Integer; cdecl;
Function   pCvestimateAffine3DV3(src: PCvMat_t; dst: PCvMat_t; scale: PDouble { default: nullptr } = nil; 
                 force_rotation: Boolean { default: true } = true): PCvMat_t; cdecl;
Function   pCvestimateAffine3DV4(src: PCvUMat_t; dst: PCvUMat_t; 
                 scale: PDouble { default: nullptr } = nil; force_rotation: Boolean { default: true } = true): PCvMat_t; cdecl;
Function   pCvestimateAffinePartial2D(from: PCvMat_t; _to: PCvMat_t; 
                 inliers: PCvMat_t { default: Mat() } = nil; method: Integer { default: RANSAC } = ord(RANSAC); 
                 ransacReprojThreshold: Double { default: 3 } = 3; maxIters: UInt64 { default: 2000 } = 2000; 
                 confidence: Double { default: 0.99 } = 0.99; refineIters: UInt64 { default: 10 } = 10): PCvMat_t; cdecl;
Function   pCvestimateAffinePartial2DV2(from: PCvUMat_t; _to: PCvUMat_t; 
                 inliers: PCvUMat_t { default: UMat() } = nil; method: Integer { default: RANSAC } = ord(RANSAC); 
                 ransacReprojThreshold: Double { default: 3 } = 3; maxIters: UInt64 { default: 2000 } = 2000; 
                 confidence: Double { default: 0.99 } = 0.99; refineIters: UInt64 { default: 10 } = 10): PCvMat_t; cdecl;
Function   pCvestimateChessboardSharpness(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; 
                 rise_distance: Single { default: 0.8F } = 0.8; vertical: Boolean { default: false } = false; 
                 sharpness: PCvMat_t { default: Mat() } = nil): PCvScalar_t; cdecl;
Function   pCvestimateChessboardSharpnessV2(image: PCvUMat_t; patternSize: PCvSize_t; corners: PCvUMat_t; 
                 rise_distance: Single { default: 0.8F } = 0.8; vertical: Boolean { default: false } = false; 
                 sharpness: PCvUMat_t { default: UMat() } = nil): PCvScalar_t; cdecl;
Function   pCvestimateTranslation3D(src: PCvMat_t; dst: PCvMat_t; _out: PCvMat_t; inliers: PCvMat_t; 
                 ransacThreshold: Double { default: 3 } = 3; confidence: Double { default: 0.99 } = 0.99): Integer; cdecl;
Function   pCvestimateTranslation3DV2(src: PCvUMat_t; dst: PCvUMat_t; _out: PCvUMat_t; 
                 inliers: PCvUMat_t; ransacThreshold: Double { default: 3 } = 3; 
                 confidence: Double { default: 0.99 } = 0.99): Integer; cdecl;
Procedure  pCvexp(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvexpV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvextractChannel(src: PCvMat_t; dst: PCvMat_t; coi: Integer); cdecl;
Procedure  pCvextractChannelV2(src: PCvUMat_t; dst: PCvUMat_t; coi: Integer); cdecl;
Function   pCvfastAtan2(y: Single; x: Single): Single; cdecl;
Procedure  pCvfastNlMeansDenoising(src: PCvMat_t; dst: PCvMat_t; h: Single { default: 3 } = 3; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingV2(src: PCvUMat_t; dst: PCvUMat_t; h: Single { default: 3 } = 3; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingV3(src: PCvMat_t; dst: PCvMat_t; h: PCvvector_float; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21; 
                 normType: Integer { default: NORM_L2 } = ord(NORM_L2)); cdecl;
Procedure  pCvfastNlMeansDenoisingV4(src: PCvUMat_t; dst: PCvUMat_t; h: PCvvector_float; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21; 
                 normType: Integer { default: NORM_L2 } = ord(NORM_L2)); cdecl;
Procedure  pCvfastNlMeansDenoisingColored(src: PCvMat_t; dst: PCvMat_t; h: Single { default: 3 } = 3; 
                 hColor: Single { default: 3 } = 3; templateWindowSize: Integer { default: 7 } = 7; 
                 searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingColoredV2(src: PCvUMat_t; dst: PCvUMat_t; h: Single { default: 3 } = 3; 
                 hColor: Single { default: 3 } = 3; templateWindowSize: Integer { default: 7 } = 7; 
                 searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingColoredMulti(srcImgs: PCvvector_Mat; dst: PCvMat_t; 
                 imgToDenoiseIndex: Integer; temporalWindowSize: Integer; 
                 h: Single { default: 3 } = 3; hColor: Single { default: 3 } = 3; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingColoredMultiV2(srcImgs: PCvvector_UMat; dst: PCvUMat_t; 
                 imgToDenoiseIndex: Integer; temporalWindowSize: Integer; 
                 h: Single { default: 3 } = 3; hColor: Single { default: 3 } = 3; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingMulti(srcImgs: PCvvector_Mat; dst: PCvMat_t; 
                 imgToDenoiseIndex: Integer; temporalWindowSize: Integer; h: Single { default: 3 } = 3; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingMultiV2(srcImgs: PCvvector_UMat; dst: PCvUMat_t; 
                 imgToDenoiseIndex: Integer; temporalWindowSize: Integer; h: Single { default: 3 } = 3; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21); cdecl;
Procedure  pCvfastNlMeansDenoisingMultiV3(srcImgs: PCvvector_Mat; dst: PCvMat_t; 
                 imgToDenoiseIndex: Integer; temporalWindowSize: Integer; h: PCvvector_float; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21; 
                 normType: Integer { default: NORM_L2 } = ord(NORM_L2)); cdecl;
Procedure  pCvfastNlMeansDenoisingMultiV4(srcImgs: PCvvector_UMat; dst: PCvUMat_t; 
                 imgToDenoiseIndex: Integer; temporalWindowSize: Integer; h: PCvvector_float; 
                 templateWindowSize: Integer { default: 7 } = 7; searchWindowSize: Integer { default: 21 } = 21; 
                 normType: Integer { default: NORM_L2 } = ord(NORM_L2)); cdecl;
Procedure  pCvfillConvexPoly(img: PCvMat_t; points: PCvMat_t; color: PCvScalar_t; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvfillConvexPolyV2(img: PCvUMat_t; points: PCvUMat_t; color: PCvScalar_t; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvfillPoly(img: PCvMat_t; pts: PCvvector_Mat; color: PCvScalar_t; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); shift: Integer { default: 0 } = 0; 
                 offset: PCvPoint_t { default: Point() } = nil); cdecl;
Procedure  pCvfillPolyV2(img: PCvUMat_t; pts: PCvvector_UMat; color: PCvScalar_t; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); shift: Integer { default: 0 } = 0; 
                 offset: PCvPoint_t { default: Point() } = nil); cdecl;
Procedure  pCvfilter2D(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; kernel: PCvMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvfilter2DV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; kernel: PCvUMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; delta: Double { default: 0 } = 0; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvfilterHomographyDecompByVisibleRefpoints(rotations: PCvvector_Mat; normals: PCvvector_Mat; 
                 beforePoints: PCvMat_t; afterPoints: PCvMat_t; 
                 possibleSolutions: PCvMat_t; pointsMask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvfilterHomographyDecompByVisibleRefpointsV2(rotations: PCvvector_UMat; 
                 normals: PCvvector_UMat; beforePoints: PCvUMat_t; 
                 afterPoints: PCvUMat_t; possibleSolutions: PCvUMat_t; 
                 pointsMask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvfilterSpeckles(img: PCvMat_t; newVal: Double; maxSpeckleSize: Integer; maxDiff: Double; 
                 buf: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvfilterSpecklesV2(img: PCvUMat_t; newVal: Double; maxSpeckleSize: Integer; maxDiff: Double; 
                 buf: PCvUMat_t { default: UMat() } = nil); cdecl;
Function   pCvfind4QuadCornerSubpix(img: PCvMat_t; corners: PCvMat_t; region_size: PCvSize_t): Boolean; cdecl;
Function   pCvfind4QuadCornerSubpixV2(img: PCvUMat_t; corners: PCvUMat_t; region_size: PCvSize_t): Boolean; cdecl;
Function   pCvfindChessboardCorners(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; 
                 flags: Integer { default: CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE } = ord(CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE)): Boolean; cdecl;
Function   pCvfindChessboardCornersV2(image: PCvUMat_t; patternSize: PCvSize_t; corners: PCvUMat_t; 
                 flags: Integer { default: CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE } = ord(CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE)): Boolean; cdecl;
Function   pCvfindChessboardCornersSB(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvfindChessboardCornersSBV2(image: PCvUMat_t; patternSize: PCvSize_t; corners: PCvUMat_t; 
                 flags: Integer { default: 0 } = 0): Boolean; cdecl;
Function   pCvfindChessboardCornersSBWithMeta(image: PCvMat_t; patternSize: PCvSize_t; corners: PCvMat_t; 
                 flags: Integer; meta: PCvMat_t): Boolean; cdecl;
Function   pCvfindChessboardCornersSBWithMetaV2(image: PCvUMat_t; patternSize: PCvSize_t; 
                 corners: PCvUMat_t; flags: Integer; meta: PCvUMat_t): Boolean; cdecl;
Function   pCvfindCirclesGrid(image: PCvMat_t; patternSize: PCvSize_t; centers: PCvMat_t; flags: Integer; 
                 blobDetector: PCvPtr_FeatureDetector; parameters: PCvCirclesGridFinderParameters_t): Boolean; cdecl;
Function   pCvfindCirclesGridV2(image: PCvUMat_t; patternSize: PCvSize_t; centers: PCvUMat_t; 
                 flags: Integer; blobDetector: PCvPtr_FeatureDetector; 
                 parameters: PCvCirclesGridFinderParameters_t): Boolean; cdecl;
Function   pCvfindCirclesGridV3(image: PCvMat_t; patternSize: PCvSize_t; centers: PCvMat_t; 
                 flags: Integer { default: CALIB_CB_SYMMETRIC_GRID } = ord(CALIB_CB_SYMMETRIC_GRID); 
                 blobDetector: PCvPtr_FeatureDetector { default: SimpleBlobDetector::create() } = nil): Boolean; cdecl;
Function   pCvfindCirclesGridV4(image: PCvUMat_t; patternSize: PCvSize_t; centers: PCvUMat_t; 
                 flags: Integer { default: CALIB_CB_SYMMETRIC_GRID } = ord(CALIB_CB_SYMMETRIC_GRID); 
                 blobDetector: PCvPtr_FeatureDetector { default: SimpleBlobDetector::create() } = nil): Boolean; cdecl;
Procedure  pCvfindContours(image: PCvMat_t; contours: PCvvector_Mat; hierarchy: PCvMat_t; mode: Integer; 
                 method: Integer; offset: PCvPoint_t { default: Point() } = nil); cdecl;
Procedure  pCvfindContoursV2(image: PCvUMat_t; contours: PCvvector_UMat; hierarchy: PCvUMat_t; 
                 mode: Integer; method: Integer; offset: PCvPoint_t { default: Point() } = nil); cdecl;
Function   pCvfindEssentialMat(points1: PCvMat_t; points2: PCvMat_t; cameraMatrix: PCvMat_t; 
                 method: Integer { default: RANSAC } = ord(RANSAC); prob: Double { default: 0.999 } = 0.999; 
                 threshold: Double { default: 1.0 } = 1.0; maxIters: Integer { default: 1000 } = 1000; 
                 mask: PCvMat_t { default: Mat() } = nil): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV2(points1: PCvUMat_t; points2: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 method: Integer { default: RANSAC } = ord(RANSAC); prob: Double { default: 0.999 } = 0.999; 
                 threshold: Double { default: 1.0 } = 1.0; maxIters: Integer { default: 1000 } = 1000; 
                 mask: PCvUMat_t { default: UMat() } = nil): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV3(points1: PCvMat_t; points2: PCvMat_t; 
                 focal: Double { default: 1.0 } = 1.0; pp: PCvPoint2d_t { default: Point2d(0, 0) } = nil; 
                 method: Integer { default: RANSAC } = ord(RANSAC); prob: Double { default: 0.999 } = 0.999; 
                 threshold: Double { default: 1.0 } = 1.0; maxIters: Integer { default: 1000 } = 1000; 
                 mask: PCvMat_t { default: Mat() } = nil): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV4(points1: PCvUMat_t; points2: PCvUMat_t; 
                 focal: Double { default: 1.0 } = 1.0; pp: PCvPoint2d_t { default: Point2d(0, 0) } = nil; 
                 method: Integer { default: RANSAC } = ord(RANSAC); prob: Double { default: 0.999 } = 0.999; 
                 threshold: Double { default: 1.0 } = 1.0; maxIters: Integer { default: 1000 } = 1000; 
                 mask: PCvUMat_t { default: UMat() } = nil): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV5(points1: PCvMat_t; points2: PCvMat_t; cameraMatrix1: PCvMat_t; 
                 distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; distCoeffs2: PCvMat_t; 
                 method: Integer { default: RANSAC } = ord(RANSAC); prob: Double { default: 0.999 } = 0.999; 
                 threshold: Double { default: 1.0 } = 1.0; mask: PCvMat_t { default: Mat() } = nil): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV6(points1: PCvUMat_t; points2: PCvUMat_t; cameraMatrix1: PCvUMat_t; 
                 distCoeffs1: PCvUMat_t; cameraMatrix2: PCvUMat_t; distCoeffs2: PCvUMat_t; 
                 method: Integer { default: RANSAC } = ord(RANSAC); prob: Double { default: 0.999 } = 0.999; 
                 threshold: Double { default: 1.0 } = 1.0; mask: PCvUMat_t { default: UMat() } = nil): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV7(points1: PCvMat_t; points2: PCvMat_t; cameraMatrix1: PCvMat_t; 
                 cameraMatrix2: PCvMat_t; dist_coeff1: PCvMat_t; dist_coeff2: PCvMat_t; mask: PCvMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvfindEssentialMatV8(points1: PCvUMat_t; points2: PCvUMat_t; cameraMatrix1: PCvUMat_t; 
                 cameraMatrix2: PCvUMat_t; dist_coeff1: PCvUMat_t; dist_coeff2: PCvUMat_t; mask: PCvUMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvfindFundamentalMat(points1: PCvMat_t; points2: PCvMat_t; method: Integer; 
                 ransacReprojThreshold: Double; confidence: Double; maxIters: Integer; 
                 mask: PCvMat_t { default: Mat() } = nil): PCvMat_t; cdecl;
Function   pCvfindFundamentalMatV2(points1: PCvUMat_t; points2: PCvUMat_t; method: Integer; 
                 ransacReprojThreshold: Double; confidence: Double; maxIters: Integer; 
                 mask: PCvUMat_t { default: UMat() } = nil): PCvMat_t; cdecl;
Function   pCvfindFundamentalMatV3(points1: PCvMat_t; points2: PCvMat_t; 
                 method: Integer { default: FM_RANSAC } = ord(FM_RANSAC); ransacReprojThreshold: Double { default: 3. } = 3.0; 
                 confidence: Double { default: 0.99 } = 0.99; mask: PCvMat_t { default: Mat() } = nil): PCvMat_t; cdecl;
Function   pCvfindFundamentalMatV4(points1: PCvUMat_t; points2: PCvUMat_t; 
                 method: Integer { default: FM_RANSAC } = ord(FM_RANSAC); ransacReprojThreshold: Double { default: 3. } = 3.0; 
                 confidence: Double { default: 0.99 } = 0.99; mask: PCvUMat_t { default: UMat() } = nil): PCvMat_t; cdecl;
Function   pCvfindFundamentalMatV5(points1: PCvMat_t; points2: PCvMat_t; mask: PCvMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvfindFundamentalMatV6(points1: PCvUMat_t; points2: PCvUMat_t; mask: PCvUMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvfindHomography(srcPoints: PCvMat_t; dstPoints: PCvMat_t; 
                 method: Integer { default: 0 } = 0; ransacReprojThreshold: Double { default: 3 } = 3; 
                 mask: PCvMat_t { default: Mat() } = nil; maxIters: Integer { default: 2000 } = 2000; 
                 confidence: Double { default: 0.995 } = 0.995): PCvMat_t; cdecl;
Function   pCvfindHomographyV2(srcPoints: PCvUMat_t; dstPoints: PCvUMat_t; 
                 method: Integer { default: 0 } = 0; ransacReprojThreshold: Double { default: 3 } = 3; 
                 mask: PCvUMat_t { default: UMat() } = nil; maxIters: Integer { default: 2000 } = 2000; 
                 confidence: Double { default: 0.995 } = 0.995): PCvMat_t; cdecl;
Function   pCvfindHomographyV3(srcPoints: PCvMat_t; dstPoints: PCvMat_t; mask: PCvMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Function   pCvfindHomographyV4(srcPoints: PCvUMat_t; dstPoints: PCvUMat_t; mask: PCvUMat_t; 
                 params: PCvUsacParams_t): PCvMat_t; cdecl;
Procedure  pCvfindNonZero(src: PCvMat_t; idx: PCvMat_t); cdecl;
Procedure  pCvfindNonZeroV2(src: PCvUMat_t; idx: PCvUMat_t); cdecl;
Function   pCvfindTransformECC(templateImage: PCvMat_t; inputImage: PCvMat_t; warpMatrix: PCvMat_t; 
                 motionType: Integer; criteria: PCvTermCriteria_t; inputMask: PCvMat_t; 
                 gaussFiltSize: Integer): Double; cdecl;
Function   pCvfindTransformECCV2(templateImage: PCvUMat_t; inputImage: PCvUMat_t; warpMatrix: PCvUMat_t; 
                 motionType: Integer; criteria: PCvTermCriteria_t; inputMask: PCvUMat_t; 
                 gaussFiltSize: Integer): Double; cdecl;
Function   pCvfindTransformECCV3(templateImage: PCvMat_t; inputImage: PCvMat_t; warpMatrix: PCvMat_t; 
                 motionType: Integer { default: MOTION_AFFINE } = ord(MOTION_AFFINE); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001) } = nil; inputMask: PCvMat_t { default: Mat() } = nil): Double; cdecl;
Function   pCvfindTransformECCV4(templateImage: PCvUMat_t; inputImage: PCvUMat_t; warpMatrix: PCvUMat_t; 
                 motionType: Integer { default: MOTION_AFFINE } = ord(MOTION_AFFINE); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001) } = nil; inputMask: PCvUMat_t { default: UMat() } = nil): Double; cdecl;
Function   pCvfisheye_calibrate(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; 
                 image_size: PCvSize_t; K: PCvMat_t; D: PCvMat_t; rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; 
                 flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvfisheye_calibrateV2(objectPoints: PCvvector_UMat; imagePoints: PCvvector_UMat; 
                 image_size: PCvSize_t; K: PCvUMat_t; D: PCvUMat_t; rvecs: PCvvector_UMat; 
                 tvecs: PCvvector_UMat; flags: Integer { default: 0 } = 0; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) } = nil): Double; cdecl;
Procedure  pCvfisheye_distortPoints(undistorted: PCvMat_t; distorted: PCvMat_t; K: PCvMat_t; D: PCvMat_t; 
                 alpha: Double { default: 0 } = 0); cdecl;
Procedure  pCvfisheye_distortPointsV2(undistorted: PCvUMat_t; distorted: PCvUMat_t; K: PCvUMat_t; 
                 D: PCvUMat_t; alpha: Double { default: 0 } = 0); cdecl;
Procedure  pCvfisheye_estimateNewCameraMatrixForUndistortRectify(K: PCvMat_t; D: PCvMat_t; 
                 image_size: PCvSize_t; R: PCvMat_t; P: PCvMat_t; 
                 balance: Double { default: 0.0 } = 0.0; 
                 new_size: PCvSize_t { default: Size() } = nil; 
                 fov_scale: Double { default: 1.0 } = 1.0); cdecl;
Procedure  pCvfisheye_estimateNewCameraMatrixForUndistortRectifyV2(K: PCvUMat_t; D: PCvUMat_t; 
                 image_size: PCvSize_t; R: PCvUMat_t; P: PCvUMat_t; 
                 balance: Double { default: 0.0 } = 0.0; 
                 new_size: PCvSize_t { default: Size() } = nil; 
                 fov_scale: Double { default: 1.0 } = 1.0); cdecl;
Procedure  pCvfisheye_initUndistortRectifyMap(K: PCvMat_t; D: PCvMat_t; R: PCvMat_t; P: PCvMat_t; 
                 size: PCvSize_t; m1type: Integer; map1: PCvMat_t; map2: PCvMat_t); cdecl;
Procedure  pCvfisheye_initUndistortRectifyMapV2(K: PCvUMat_t; D: PCvUMat_t; R: PCvUMat_t; P: PCvUMat_t; 
                 size: PCvSize_t; m1type: Integer; map1: PCvUMat_t; map2: PCvUMat_t); cdecl;
Procedure  pCvfisheye_projectPoints(objectPoints: PCvMat_t; imagePoints: PCvMat_t; rvec: PCvMat_t; 
                 tvec: PCvMat_t; K: PCvMat_t; D: PCvMat_t; alpha: Double { default: 0 } = 0; 
                 jacobian: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvfisheye_projectPointsV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; rvec: PCvUMat_t; 
                 tvec: PCvUMat_t; K: PCvUMat_t; D: PCvUMat_t; alpha: Double { default: 0 } = 0; 
                 jacobian: PCvUMat_t { default: UMat() } = nil); cdecl;
Function   pCvfisheye_stereoCalibrate(objectPoints: PCvvector_Mat; imagePoints1: PCvvector_Mat; 
                 imagePoints2: PCvvector_Mat; K1: PCvMat_t; D1: PCvMat_t; K2: PCvMat_t; D2: PCvMat_t; 
                 imageSize: PCvSize_t; R: PCvMat_t; T: PCvMat_t; 
                 flags: Integer { default: fisheye::CALIB_FIX_INTRINSIC } = ord(fisheye_CALIB_FIX_INTRINSIC); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) } = nil): Double; cdecl;
Function   pCvfisheye_stereoCalibrateV2(objectPoints: PCvvector_UMat; imagePoints1: PCvvector_UMat; 
                 imagePoints2: PCvvector_UMat; K1: PCvUMat_t; D1: PCvUMat_t; K2: PCvUMat_t; D2: PCvUMat_t; 
                 imageSize: PCvSize_t; R: PCvUMat_t; T: PCvUMat_t; 
                 flags: Integer { default: fisheye::CALIB_FIX_INTRINSIC } = ord(fisheye_CALIB_FIX_INTRINSIC); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) } = nil): Double; cdecl;
Procedure  pCvfisheye_stereoRectify(K1: PCvMat_t; D1: PCvMat_t; K2: PCvMat_t; D2: PCvMat_t; 
                 imageSize: PCvSize_t; R: PCvMat_t; tvec: PCvMat_t; R1: PCvMat_t; R2: PCvMat_t; 
                 P1: PCvMat_t; P2: PCvMat_t; Q: PCvMat_t; flags: Integer; 
                 newImageSize: PCvSize_t { default: Size() } = nil; balance: Double { default: 0.0 } = 0.0; 
                 fov_scale: Double { default: 1.0 } = 1.0); cdecl;
Procedure  pCvfisheye_stereoRectifyV2(K1: PCvUMat_t; D1: PCvUMat_t; K2: PCvUMat_t; D2: PCvUMat_t; 
                 imageSize: PCvSize_t; R: PCvUMat_t; tvec: PCvUMat_t; R1: PCvUMat_t; R2: PCvUMat_t; 
                 P1: PCvUMat_t; P2: PCvUMat_t; Q: PCvUMat_t; flags: Integer; 
                 newImageSize: PCvSize_t { default: Size() } = nil; balance: Double { default: 0.0 } = 0.0; 
                 fov_scale: Double { default: 1.0 } = 1.0); cdecl;
Procedure  pCvfisheye_undistortImage(distorted: PCvMat_t; undistorted: PCvMat_t; K: PCvMat_t; 
                 D: PCvMat_t; Knew: PCvMat_t { default: cv::Mat() } = nil; 
                 new_size: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvfisheye_undistortImageV2(distorted: PCvUMat_t; undistorted: PCvUMat_t; K: PCvUMat_t; 
                 D: PCvUMat_t; Knew: PCvUMat_t { default: cv::UMat() } = nil; 
                 new_size: PCvSize_t { default: Size() } = nil); cdecl;
Procedure  pCvfisheye_undistortPoints(distorted: PCvMat_t; undistorted: PCvMat_t; K: PCvMat_t; 
                 D: PCvMat_t; R: PCvMat_t { default: Mat() } = nil; 
                 P: PCvMat_t { default: Mat() } = nil; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8) } = nil); cdecl;
Procedure  pCvfisheye_undistortPointsV2(distorted: PCvUMat_t; undistorted: PCvUMat_t; K: PCvUMat_t; 
                 D: PCvUMat_t; R: PCvUMat_t { default: UMat() } = nil; 
                 P: PCvUMat_t { default: UMat() } = nil; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8) } = nil); cdecl;
Function   pCvfitEllipse(points: PCvMat_t): PCvRotatedRect_t; cdecl;
Function   pCvfitEllipseV2(points: PCvUMat_t): PCvRotatedRect_t; cdecl;
Function   pCvfitEllipseAMS(points: PCvMat_t): PCvRotatedRect_t; cdecl;
Function   pCvfitEllipseAMSV2(points: PCvUMat_t): PCvRotatedRect_t; cdecl;
Function   pCvfitEllipseDirect(points: PCvMat_t): PCvRotatedRect_t; cdecl;
Function   pCvfitEllipseDirectV2(points: PCvUMat_t): PCvRotatedRect_t; cdecl;
Procedure  pCvfitLine(points: PCvMat_t; line: PCvMat_t; distType: Integer; param: Double; reps: Double; 
                 aeps: Double); cdecl;
Procedure  pCvfitLineV2(points: PCvUMat_t; line: PCvUMat_t; distType: Integer; param: Double; 
                 reps: Double; aeps: Double); cdecl;
Procedure  pCvflip(src: PCvMat_t; dst: PCvMat_t; flipCode: Integer); cdecl;
Procedure  pCvflipV2(src: PCvUMat_t; dst: PCvUMat_t; flipCode: Integer); cdecl;
Function   pCvfloodFill(image: PCvMat_t; mask: PCvMat_t; seedPoint: PCvPoint_t; newVal: PCvScalar_t; 
                 rect: PCvRect_t { default: 0 } = 0; loDiff: PCvScalar_t { default: Scalar() } = nil; 
                 upDiff: PCvScalar_t { default: Scalar() } = nil; flags: Integer { default: 4 } = 4): Integer; cdecl;
Function   pCvfloodFillV2(image: PCvUMat_t; mask: PCvUMat_t; seedPoint: PCvPoint_t; newVal: PCvScalar_t; 
                 rect: PCvRect_t { default: 0 } = 0; loDiff: PCvScalar_t { default: Scalar() } = nil; 
                 upDiff: PCvScalar_t { default: Scalar() } = nil; flags: Integer { default: 4 } = 4): Integer; cdecl;
Procedure  pCvgemm(src1: PCvMat_t; src2: PCvMat_t; alpha: Double; src3: PCvMat_t; beta: Double; 
                 dst: PCvMat_t; flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvgemmV2(src1: PCvUMat_t; src2: PCvUMat_t; alpha: Double; src3: PCvUMat_t; beta: Double; 
                 dst: PCvUMat_t; flags: Integer { default: 0 } = 0); cdecl;
Function   pCvgetAffineTransform(src: PCvMat_t; dst: PCvMat_t): PCvMat_t; cdecl;
Function   pCvgetAffineTransformV2(src: PCvUMat_t; dst: PCvUMat_t): PCvMat_t; cdecl;
Function   pCvgetBuildInformation(): PCvString_t; cdecl;
Function   pCvgetCPUFeaturesLine(): PCvString_t; cdecl;
Function   pCvgetCPUTickCount(): Int64; cdecl;
Function   pCvgetDefaultNewCameraMatrix(cameraMatrix: PCvMat_t; 
                 imgsize: PCvSize_t { default: Size() } = nil; centerPrincipalPoint: Boolean { default: false } = false): PCvMat_t; cdecl;
Function   pCvgetDefaultNewCameraMatrixV2(cameraMatrix: PCvUMat_t; 
                 imgsize: PCvSize_t { default: Size() } = nil; centerPrincipalPoint: Boolean { default: false } = false): PCvMat_t; cdecl;
Procedure  pCvgetDerivKernels(kx: PCvMat_t; ky: PCvMat_t; dx: Integer; dy: Integer; ksize: Integer; 
                 normalize: Boolean { default: false } = false; ktype: Integer { default: CV_32F } = ord(CV_32F)); cdecl;
Procedure  pCvgetDerivKernelsV2(kx: PCvUMat_t; ky: PCvUMat_t; dx: Integer; dy: Integer; ksize: Integer; 
                 normalize: Boolean { default: false } = false; ktype: Integer { default: CV_32F } = ord(CV_32F)); cdecl;
Function   pCvgetFontScaleFromHeight(fontFace: Integer; pixelHeight: Integer; 
                 thickness: Integer { default: 1 } = 1): Double; cdecl;
Function   pCvgetGaborKernel(ksize: PCvSize_t; sigma: Double; theta: Double; lambd: Double; 
                 gamma: Double; psi: Double { default: CV_PI*0.5 } = Pi; 
                 ktype: Integer { default: CV_64F } = ord(CV_64F)): PCvMat_t; cdecl;
Function   pCvgetGaussianKernel(ksize: Integer; sigma: Double; 
                 ktype: Integer { default: CV_64F } = ord(CV_64F)): PCvMat_t; cdecl;
Function   pCvgetHardwareFeatureName(feature: Integer): PCvString_t; cdecl;
Function   pCvgetLogLevel(): Integer; cdecl;
Function   pCvgetNumThreads(): Integer; cdecl;
Function   pCvgetNumberOfCPUs(): Integer; cdecl;
Function   pCvgetOptimalDFTSize(vecsize: Integer): Integer; cdecl;
Function   pCvgetOptimalNewCameraMatrix(cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; 
                 imageSize: PCvSize_t; alpha: Double; newImgSize: PCvSize_t { default: Size() } = nil; 
                 validPixROI: PCvRect_t { default: 0 } = 0; centerPrincipalPoint: Boolean { default: false } = false): PCvMat_t; cdecl;
Function   pCvgetOptimalNewCameraMatrixV2(cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; 
                 imageSize: PCvSize_t; alpha: Double; 
                 newImgSize: PCvSize_t { default: Size() } = nil; validPixROI: PCvRect_t { default: 0 } = 0; 
                 centerPrincipalPoint: Boolean { default: false } = false): PCvMat_t; cdecl;
Function   pCvgetPerspectiveTransform(src: PCvMat_t; dst: PCvMat_t; 
                 solveMethod: Integer { default: DECOMP_LU } = ord(DECOMP_LU)): PCvMat_t; cdecl;
Function   pCvgetPerspectiveTransformV2(src: PCvUMat_t; dst: PCvUMat_t; 
                 solveMethod: Integer { default: DECOMP_LU } = ord(DECOMP_LU)): PCvMat_t; cdecl;
Procedure  pCvgetRectSubPix(image: PCvMat_t; patchSize: PCvSize_t; center: PCvPoint2f_t; patch: PCvMat_t; 
                 patchType: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvgetRectSubPixV2(image: PCvUMat_t; patchSize: PCvSize_t; center: PCvPoint2f_t; 
                 patch: PCvUMat_t; patchType: Integer { default: -1 } = ord(-1)); cdecl;
Function   pCvgetRotationMatrix2D(center: PCvPoint2f_t; angle: Double; scale: Double): PCvMat_t; cdecl;
Function   pCvgetStructuringElement(shape: Integer; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil): PCvMat_t; cdecl;
Function   pCvgetTextSize(text: PCvString_t; fontFace: Integer; fontScale: Double; thickness: Integer; 
                 baseLine: PInteger): PCvSize_t; cdecl;
Function   pCvgetThreadNum(): Integer; cdecl;
Function   pCvgetTickCount(): Int64; cdecl;
Function   pCvgetTickFrequency(): Double; cdecl;
Function   pCvgetTrackbarPos(trackbarname: PCvString_t; winname: PCvString_t): Integer; cdecl;
Function   pCvgetValidDisparityROI(roi1: PCvRect_t; roi2: PCvRect_t; minDisparity: Integer; 
                 numberOfDisparities: Integer; blockSize: Integer): PCvRect_t; cdecl;
Function   pCvgetVersionMajor(): Integer; cdecl;
Function   pCvgetVersionMinor(): Integer; cdecl;
Function   pCvgetVersionRevision(): Integer; cdecl;
Function   pCvgetVersionString(): PCvString_t; cdecl;
Function   pCvgetWindowImageRect(winname: PCvString_t): PCvRect_t; cdecl;
Function   pCvgetWindowProperty(winname: PCvString_t; prop_id: Integer): Double; cdecl;
Procedure  pCvgoodFeaturesToTrack(image: PCvMat_t; corners: PCvMat_t; maxCorners: Integer; 
                 qualityLevel: Double; minDistance: Double; mask: PCvMat_t { default: Mat() } = nil; 
                 blockSize: Integer { default: 3 } = 3; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04); cdecl;
Procedure  pCvgoodFeaturesToTrackV2(image: PCvUMat_t; corners: PCvUMat_t; maxCorners: Integer; 
                 qualityLevel: Double; minDistance: Double; mask: PCvUMat_t { default: UMat() } = nil; 
                 blockSize: Integer { default: 3 } = 3; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04); cdecl;
Procedure  pCvgoodFeaturesToTrackV3(image: PCvMat_t; corners: PCvMat_t; maxCorners: Integer; 
                 qualityLevel: Double; minDistance: Double; mask: PCvMat_t; blockSize: Integer; 
                 gradientSize: Integer; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04); cdecl;
Procedure  pCvgoodFeaturesToTrackV4(image: PCvUMat_t; corners: PCvUMat_t; maxCorners: Integer; 
                 qualityLevel: Double; minDistance: Double; mask: PCvUMat_t; blockSize: Integer; 
                 gradientSize: Integer; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04); cdecl;
Procedure  pCvgoodFeaturesToTrackWithQuality(image: PCvMat_t; corners: PCvMat_t; maxCorners: Integer; 
                 qualityLevel: Double; minDistance: Double; mask: PCvMat_t; 
                 cornersQuality: PCvMat_t; blockSize: Integer { default: 3 } = 3; 
                 gradientSize: Integer { default: 3 } = 3; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04); cdecl;
Procedure  pCvgoodFeaturesToTrackWithQualityV2(image: PCvUMat_t; corners: PCvUMat_t; maxCorners: Integer; 
                 qualityLevel: Double; minDistance: Double; mask: PCvUMat_t; 
                 cornersQuality: PCvUMat_t; blockSize: Integer { default: 3 } = 3; 
                 gradientSize: Integer { default: 3 } = 3; useHarrisDetector: Boolean { default: false } = false; 
                 k: Double { default: 0.04 } = 0.04); cdecl;
Procedure  pCvgrabCut(img: PCvMat_t; mask: PCvMat_t; rect: PCvRect_t; bgdModel: PCvMat_t; 
                 fgdModel: PCvMat_t; iterCount: Integer; mode: Integer { default: GC_EVAL } = ord(GC_EVAL)); cdecl;
Procedure  pCvgrabCutV2(img: PCvUMat_t; mask: PCvUMat_t; rect: PCvRect_t; bgdModel: PCvUMat_t; 
                 fgdModel: PCvUMat_t; iterCount: Integer; mode: Integer { default: GC_EVAL } = ord(GC_EVAL)); cdecl;
Procedure  pCvgroupRectangles(rectList: PCvvector_Rect; weights: PCvvector_int; groupThreshold: Integer; 
                 eps: Double { default: 0.2 } = 0.2); cdecl;
Function   pCvhaveImageReader(filename: PCvString_t): Boolean; cdecl;
Function   pCvhaveImageWriter(filename: PCvString_t): Boolean; cdecl;
Procedure  pCvhconcat(src: PCvvector_Mat; dst: PCvMat_t); cdecl;
Procedure  pCvhconcatV2(src: PCvvector_UMat; dst: PCvUMat_t); cdecl;
Procedure  pCvidct(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvidctV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer { default: 0 } = 0); cdecl;
Procedure  pCvidft(src: PCvMat_t; dst: PCvMat_t; flags: Integer { default: 0 } = 0; 
                 nonzeroRows: Integer { default: 0 } = 0); cdecl;
Procedure  pCvidftV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer { default: 0 } = 0; 
                 nonzeroRows: Integer { default: 0 } = 0); cdecl;
Procedure  pCvilluminationChange(src: PCvMat_t; mask: PCvMat_t; dst: PCvMat_t; 
                 alpha: Single { default: 0.2f } = 0.2; beta: Single { default: 0.4f } = 0.4); cdecl;
Procedure  pCvilluminationChangeV2(src: PCvUMat_t; mask: PCvUMat_t; dst: PCvUMat_t; 
                 alpha: Single { default: 0.2f } = 0.2; beta: Single { default: 0.4f } = 0.4); cdecl;
Function   pCvimcount(filename: PCvString_t; 
                 flags: Integer { default: IMREAD_ANYCOLOR } = ord(IMREAD_ANYCOLOR)): UInt64; cdecl;
Function   pCvimdecode(buf: PCvMat_t; flags: Integer): PCvMat_t; cdecl;
Function   pCvimdecodeV2(buf: PCvUMat_t; flags: Integer): PCvMat_t; cdecl;
Function   pCvimencode(ext: PCvString_t; img: PCvMat_t; buf: PCvvector_uchar; 
                 params: PCvvector_int { default: std::vector<int>() } = nil): Boolean; cdecl;
Function   pCvimencodeV2(ext: PCvString_t; img: PCvUMat_t; buf: PCvvector_uchar; 
                 params: PCvvector_int { default: std::vector<int>() } = nil): Boolean; cdecl;
Function   pCvimread(filename: PCvString_t; flags: Integer { default: IMREAD_COLOR } = ord(IMREAD_COLOR)): PCvMat_t; cdecl;
Function   pCvimreadmulti(filename: PCvString_t; mats: PCvvector_Mat; 
                 flags: Integer { default: IMREAD_ANYCOLOR } = ord(IMREAD_ANYCOLOR)): Boolean; cdecl;
Function   pCvimreadmultiV2(filename: PCvString_t; mats: PCvvector_Mat; start: Integer; count: Integer; 
                 flags: Integer { default: IMREAD_ANYCOLOR } = ord(IMREAD_ANYCOLOR)): Boolean; cdecl;
Procedure  pCvimshow(winname: PCvString_t; mat: PCvMat_t); cdecl;
Procedure  pCvimshowV2(winname: PCvString_t; mat: PCvUMat_t); cdecl;
Function   pCvimwrite(filename: PCvString_t; img: PCvMat_t; 
                 params: PCvvector_int { default: std::vector<int>() } = nil): Boolean; cdecl;
Function   pCvimwriteV2(filename: PCvString_t; img: PCvUMat_t; 
                 params: PCvvector_int { default: std::vector<int>() } = nil): Boolean; cdecl;
Function   pCvimwritemulti(filename: PCvString_t; img: PCvvector_Mat; 
                 params: PCvvector_int { default: std::vector<int>() } = nil): Boolean; cdecl;
Function   pCvimwritemultiV2(filename: PCvString_t; img: PCvvector_UMat; 
                 params: PCvvector_int { default: std::vector<int>() } = nil): Boolean; cdecl;
Procedure  pCvinRange(src: PCvMat_t; lowerb: PCvMat_t; upperb: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvinRangeV2(src: PCvUMat_t; lowerb: PCvUMat_t; upperb: PCvUMat_t; dst: PCvUMat_t); cdecl;
Function   pCvinitCameraMatrix2D(objectPoints: PCvvector_Mat; imagePoints: PCvvector_Mat; 
                 imageSize: PCvSize_t; aspectRatio: Double { default: 1.0 } = 1.0): PCvMat_t; cdecl;
Function   pCvinitCameraMatrix2DV2(objectPoints: PCvvector_UMat; imagePoints: PCvvector_UMat; 
                 imageSize: PCvSize_t; aspectRatio: Double { default: 1.0 } = 1.0): PCvMat_t; cdecl;
Procedure  pCvinitInverseRectificationMap(cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; R: PCvMat_t; 
                 newCameraMatrix: PCvMat_t; size: PCvSize_t; m1type: Integer; map1: PCvMat_t; 
                 map2: PCvMat_t); cdecl;
Procedure  pCvinitInverseRectificationMapV2(cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; R: PCvUMat_t; 
                 newCameraMatrix: PCvUMat_t; size: PCvSize_t; m1type: Integer; map1: PCvUMat_t; 
                 map2: PCvUMat_t); cdecl;
Procedure  pCvinitUndistortRectifyMap(cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; R: PCvMat_t; 
                 newCameraMatrix: PCvMat_t; size: PCvSize_t; m1type: Integer; map1: PCvMat_t; map2: PCvMat_t); cdecl;
Procedure  pCvinitUndistortRectifyMapV2(cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; R: PCvUMat_t; 
                 newCameraMatrix: PCvUMat_t; size: PCvSize_t; m1type: Integer; map1: PCvUMat_t; 
                 map2: PCvUMat_t); cdecl;
Procedure  pCvinpaint(src: PCvMat_t; inpaintMask: PCvMat_t; dst: PCvMat_t; inpaintRadius: Double; 
                 flags: Integer); cdecl;
Procedure  pCvinpaintV2(src: PCvUMat_t; inpaintMask: PCvUMat_t; dst: PCvUMat_t; inpaintRadius: Double; 
                 flags: Integer); cdecl;
Procedure  pCvinsertChannel(src: PCvMat_t; dst: PCvMat_t; coi: Integer); cdecl;
Procedure  pCvinsertChannelV2(src: PCvUMat_t; dst: PCvUMat_t; coi: Integer); cdecl;
Procedure  pCvintegral(src: PCvMat_t; sum: PCvMat_t; sdepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvintegralV2(src: PCvUMat_t; sum: PCvUMat_t; sdepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvintegral2(src: PCvMat_t; sum: PCvMat_t; sqsum: PCvMat_t; 
                 sdepth: Integer { default: -1 } = ord(-1); sqdepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvintegral2V2(src: PCvUMat_t; sum: PCvUMat_t; sqsum: PCvUMat_t; 
                 sdepth: Integer { default: -1 } = ord(-1); sqdepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvintegral3(src: PCvMat_t; sum: PCvMat_t; sqsum: PCvMat_t; tilted: PCvMat_t; 
                 sdepth: Integer { default: -1 } = ord(-1); sqdepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvintegral3V2(src: PCvUMat_t; sum: PCvUMat_t; sqsum: PCvUMat_t; tilted: PCvUMat_t; 
                 sdepth: Integer { default: -1 } = ord(-1); sqdepth: Integer { default: -1 } = ord(-1)); cdecl;
Function   pCvintersectConvexConvex(p1: PCvMat_t; p2: PCvMat_t; p12: PCvMat_t; 
                 handleNested: Boolean { default: true } = true): Single; cdecl;
Function   pCvintersectConvexConvexV2(p1: PCvUMat_t; p2: PCvUMat_t; p12: PCvUMat_t; 
                 handleNested: Boolean { default: true } = true): Single; cdecl;
Function   pCvinvert(src: PCvMat_t; dst: PCvMat_t; 
                 flags: Integer { default: DECOMP_LU } = ord(DECOMP_LU)): Double; cdecl;
Function   pCvinvertV2(src: PCvUMat_t; dst: PCvUMat_t; 
                 flags: Integer { default: DECOMP_LU } = ord(DECOMP_LU)): Double; cdecl;
Procedure  pCvinvertAffineTransform(M: PCvMat_t; iM: PCvMat_t); cdecl;
Procedure  pCvinvertAffineTransformV2(M: PCvUMat_t; iM: PCvUMat_t); cdecl;
Function   pCvipp_getIppVersion(): PCvString_t; cdecl;
Procedure  pCvipp_setUseIPP(flag: Boolean); cdecl;
Procedure  pCvipp_setUseIPP_NotExact(flag: Boolean); cdecl;
Function   pCvipp_useIPP(): Boolean; cdecl;
Function   pCvipp_useIPP_NotExact(): Boolean; cdecl;
Function   pCvisContourConvex(contour: PCvMat_t): Boolean; cdecl;
Function   pCvisContourConvexV2(contour: PCvUMat_t): Boolean; cdecl;
Function   pCvkmeans(data: PCvMat_t; K: Integer; bestLabels: PCvMat_t; criteria: PCvTermCriteria_t; 
                 attempts: Integer; flags: Integer; centers: PCvMat_t { default: Mat() } = nil): Double; cdecl;
Function   pCvkmeansV2(data: PCvUMat_t; K: Integer; bestLabels: PCvUMat_t; criteria: PCvTermCriteria_t; 
                 attempts: Integer; flags: Integer; centers: PCvUMat_t { default: UMat() } = nil): Double; cdecl;
Procedure  pCvline(img: PCvMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvlineV2(img: PCvUMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvlinearPolar(src: PCvMat_t; dst: PCvMat_t; center: PCvPoint2f_t; maxRadius: Double; 
                 flags: Integer); cdecl;
Procedure  pCvlinearPolarV2(src: PCvUMat_t; dst: PCvUMat_t; center: PCvPoint2f_t; maxRadius: Double; 
                 flags: Integer); cdecl;
Procedure  pCvlog(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvlogV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvlogPolar(src: PCvMat_t; dst: PCvMat_t; center: PCvPoint2f_t; M: Double; flags: Integer); cdecl;
Procedure  pCvlogPolarV2(src: PCvUMat_t; dst: PCvUMat_t; center: PCvPoint2f_t; M: Double; flags: Integer); cdecl;
Procedure  pCvmagnitude(x: PCvMat_t; y: PCvMat_t; magnitude: PCvMat_t); cdecl;
Procedure  pCvmagnitudeV2(x: PCvUMat_t; y: PCvUMat_t; magnitude: PCvUMat_t); cdecl;
Procedure  pCvmatMulDeriv(A: PCvMat_t; B: PCvMat_t; dABdA: PCvMat_t; dABdB: PCvMat_t); cdecl;
Procedure  pCvmatMulDerivV2(A: PCvUMat_t; B: PCvUMat_t; dABdA: PCvUMat_t; dABdB: PCvUMat_t); cdecl;
Function   pCvmatchShapes(contour1: PCvMat_t; contour2: PCvMat_t; method: Integer; parameter: Double): Double; cdecl;
Function   pCvmatchShapesV2(contour1: PCvUMat_t; contour2: PCvUMat_t; method: Integer; parameter: Double): Double; cdecl;
Procedure  pCvmatchTemplate(image: PCvMat_t; templ: PCvMat_t; _result: PCvMat_t; method: Integer; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvmatchTemplateV2(image: PCvUMat_t; templ: PCvUMat_t; _result: PCvUMat_t; method: Integer; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvmax(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvmaxV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t); cdecl;
Function   pCvmean(src: PCvMat_t; mask: PCvMat_t { default: Mat() } = nil): PCvScalar_t; cdecl;
Function   pCvmeanV2(src: PCvUMat_t; mask: PCvUMat_t { default: UMat() } = nil): PCvScalar_t; cdecl;
Function   pCvmeanShift(probImage: PCvMat_t; window: PCvRect_t; criteria: PCvTermCriteria_t): Integer; cdecl;
Function   pCvmeanShiftV2(probImage: PCvUMat_t; window: PCvRect_t; criteria: PCvTermCriteria_t): Integer; cdecl;
Procedure  pCvmeanStdDev(src: PCvMat_t; mean: PCvMat_t; stddev: PCvMat_t; 
                 mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvmeanStdDevV2(src: PCvUMat_t; mean: PCvUMat_t; stddev: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvmedianBlur(src: PCvMat_t; dst: PCvMat_t; ksize: Integer); cdecl;
Procedure  pCvmedianBlurV2(src: PCvUMat_t; dst: PCvUMat_t; ksize: Integer); cdecl;
Procedure  pCvmerge(mv: PCvvector_Mat; dst: PCvMat_t); cdecl;
Procedure  pCvmergeV2(mv: PCvvector_UMat; dst: PCvUMat_t); cdecl;
Procedure  pCvmin(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvminV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t); cdecl;
Function   pCvminAreaRect(points: PCvMat_t): PCvRotatedRect_t; cdecl;
Function   pCvminAreaRectV2(points: PCvUMat_t): PCvRotatedRect_t; cdecl;
Procedure  pCvminEnclosingCircle(points: PCvMat_t; center: PCvPoint2f_t; radius: Single); cdecl;
Procedure  pCvminEnclosingCircleV2(points: PCvUMat_t; center: PCvPoint2f_t; radius: Single); cdecl;
Function   pCvminEnclosingTriangle(points: PCvMat_t; triangle: PCvMat_t): Double; cdecl;
Function   pCvminEnclosingTriangleV2(points: PCvUMat_t; triangle: PCvUMat_t): Double; cdecl;
Procedure  pCvminMaxLoc(src: PCvMat_t; minVal: PDouble; maxVal: PDouble { default: 0 } = 0; 
                 minLoc: PCvPoint_t { default: 0 } = 0; maxLoc: PCvPoint_t { default: 0 } = 0; mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvminMaxLocV2(src: PCvUMat_t; minVal: PDouble; maxVal: PDouble { default: 0 } = 0; 
                 minLoc: PCvPoint_t { default: 0 } = 0; maxLoc: PCvPoint_t { default: 0 } = 0; 
                 mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvmixChannels(src: PCvvector_Mat; dst: PCvvector_Mat; fromTo: PCvvector_int); cdecl;
Procedure  pCvmixChannelsV2(src: PCvvector_UMat; dst: PCvvector_UMat; fromTo: PCvvector_int); cdecl;
Function   pCvmoments(_array: PCvMat_t; binaryImage: Boolean { default: false } = false): PCvMoments_t; cdecl;
Function   pCvmomentsV2(_array: PCvUMat_t; binaryImage: Boolean { default: false } = false): PCvMoments_t; cdecl;
Procedure  pCvmorphologyEx(src: PCvMat_t; dst: PCvMat_t; op: Integer; kernel: PCvMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; iterations: Integer { default: 1 } = 1; 
                 borderType: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() } = nil); cdecl;
Procedure  pCvmorphologyExV2(src: PCvUMat_t; dst: PCvUMat_t; op: Integer; kernel: PCvUMat_t; 
                 anchor: PCvPoint_t { default: Point(-1,-1) } = nil; iterations: Integer { default: 1 } = 1; 
                 borderType: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); 
                 borderValue: PCvScalar_t { default: morphologyDefaultBorderValue() } = nil); cdecl;
Procedure  pCvmoveWindow(winname: PCvString_t; x: Integer; y: Integer); cdecl;
Procedure  pCvmulSpectrums(a: PCvMat_t; b: PCvMat_t; c: PCvMat_t; flags: Integer; 
                 conjB: Boolean { default: false } = false); cdecl;
Procedure  pCvmulSpectrumsV2(a: PCvUMat_t; b: PCvUMat_t; c: PCvUMat_t; flags: Integer; 
                 conjB: Boolean { default: false } = false); cdecl;
Procedure  pCvmulTransposed(src: PCvMat_t; dst: PCvMat_t; aTa: Boolean; 
                 delta: PCvMat_t { default: Mat() } = nil; scale: Double { default: 1 } = 1; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvmulTransposedV2(src: PCvUMat_t; dst: PCvUMat_t; aTa: Boolean; 
                 delta: PCvUMat_t { default: UMat() } = nil; scale: Double { default: 1 } = 1; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvmultiply(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; scale: Double { default: 1 } = 1; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvmultiplyV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 scale: Double { default: 1 } = 1; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvnamedWindow(winname: PCvString_t; 
                 flags: Integer { default: WINDOW_AUTOSIZE } = ord(WINDOW_AUTOSIZE)); cdecl;
Function   pCvnorm(src1: PCvMat_t; normType: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 mask: PCvMat_t { default: Mat() } = nil): Double; cdecl;
Function   pCvnormV2(src1: PCvUMat_t; normType: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 mask: PCvUMat_t { default: UMat() } = nil): Double; cdecl;
Function   pCvnormV3(src1: PCvMat_t; src2: PCvMat_t; 
                 normType: Integer { default: NORM_L2 } = ord(NORM_L2); mask: PCvMat_t { default: Mat() } = nil): Double; cdecl;
Function   pCvnormV4(src1: PCvUMat_t; src2: PCvUMat_t; 
                 normType: Integer { default: NORM_L2 } = ord(NORM_L2); mask: PCvUMat_t { default: UMat() } = nil): Double; cdecl;
Procedure  pCvnormalize(src: PCvMat_t; dst: PCvMat_t; alpha: Double { default: 1 } = 1; 
                 beta: Double { default: 0 } = 0; norm_type: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 dtype: Integer { default: -1 } = ord(-1); mask: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvnormalizeV2(src: PCvUMat_t; dst: PCvUMat_t; alpha: Double { default: 1 } = 1; 
                 beta: Double { default: 0 } = 0; norm_type: Integer { default: NORM_L2 } = ord(NORM_L2); 
                 dtype: Integer { default: -1 } = ord(-1); mask: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvocl_finish(); cdecl;
Function   pCvocl_haveAmdBlas(): Boolean; cdecl;
Function   pCvocl_haveAmdFft(): Boolean; cdecl;
Function   pCvocl_haveOpenCL(): Boolean; cdecl;
Procedure  pCvocl_setUseOpenCL(flag: Boolean); cdecl;
Function   pCvocl_useOpenCL(): Boolean; cdecl;
Procedure  pCvpatchNaNs(a: PCvMat_t; _val: Double { default: 0 } = 0); cdecl;
Procedure  pCvpatchNaNsV2(a: PCvUMat_t; _val: Double { default: 0 } = 0); cdecl;
Procedure  pCvpencilSketch(src: PCvMat_t; dst1: PCvMat_t; dst2: PCvMat_t; 
                 sigma_s: Single { default: 60 } = 60; sigma_r: Single { default: 0.07f } = 0.07; 
                 shade_factor: Single { default: 0.02f } = 0.02); cdecl;
Procedure  pCvpencilSketchV2(src: PCvUMat_t; dst1: PCvUMat_t; dst2: PCvUMat_t; 
                 sigma_s: Single { default: 60 } = 60; sigma_r: Single { default: 0.07f } = 0.07; 
                 shade_factor: Single { default: 0.02f } = 0.02); cdecl;
Procedure  pCvperspectiveTransform(src: PCvMat_t; dst: PCvMat_t; m: PCvMat_t); cdecl;
Procedure  pCvperspectiveTransformV2(src: PCvUMat_t; dst: PCvUMat_t; m: PCvUMat_t); cdecl;
Procedure  pCvphase(x: PCvMat_t; y: PCvMat_t; angle: PCvMat_t; 
                 angleInDegrees: Boolean { default: false } = false); cdecl;
Procedure  pCvphaseV2(x: PCvUMat_t; y: PCvUMat_t; angle: PCvUMat_t; 
                 angleInDegrees: Boolean { default: false } = false); cdecl;
Function   pCvphaseCorrelate(src1: PCvMat_t; src2: PCvMat_t; window: PCvMat_t { default: Mat() } = nil; 
                 response: PDouble { default: 0 } = 0): PCvPoint2d_t; cdecl;
Function   pCvphaseCorrelateV2(src1: PCvUMat_t; src2: PCvUMat_t; 
                 window: PCvUMat_t { default: UMat() } = nil; response: PDouble { default: 0 } = 0): PCvPoint2d_t; cdecl;
Function   pCvpointPolygonTest(contour: PCvMat_t; pt: PCvPoint2f_t; measureDist: Boolean): Double; cdecl;
Function   pCvpointPolygonTestV2(contour: PCvUMat_t; pt: PCvPoint2f_t; measureDist: Boolean): Double; cdecl;
Procedure  pCvpolarToCart(magnitude: PCvMat_t; angle: PCvMat_t; x: PCvMat_t; y: PCvMat_t; 
                 angleInDegrees: Boolean { default: false } = false); cdecl;
Procedure  pCvpolarToCartV2(magnitude: PCvUMat_t; angle: PCvUMat_t; x: PCvUMat_t; y: PCvUMat_t; 
                 angleInDegrees: Boolean { default: false } = false); cdecl;
Function   pCvpollKey(): Integer; cdecl;
Procedure  pCvpolylines(img: PCvMat_t; pts: PCvvector_Mat; isClosed: Boolean; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvpolylinesV2(img: PCvUMat_t; pts: PCvvector_UMat; isClosed: Boolean; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvpow(src: PCvMat_t; power: Double; dst: PCvMat_t); cdecl;
Procedure  pCvpowV2(src: PCvUMat_t; power: Double; dst: PCvUMat_t); cdecl;
Procedure  pCvpreCornerDetect(src: PCvMat_t; dst: PCvMat_t; ksize: Integer; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvpreCornerDetectV2(src: PCvUMat_t; dst: PCvUMat_t; ksize: Integer; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvprojectPoints(objectPoints: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; 
                 cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; imagePoints: PCvMat_t; 
                 jacobian: PCvMat_t { default: Mat() } = nil; aspectRatio: Double { default: 0 } = 0); cdecl;
Procedure  pCvprojectPointsV2(objectPoints: PCvUMat_t; rvec: PCvUMat_t; tvec: PCvUMat_t; 
                 cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; imagePoints: PCvUMat_t; 
                 jacobian: PCvUMat_t { default: UMat() } = nil; aspectRatio: Double { default: 0 } = 0); cdecl;
Procedure  pCvputText(img: PCvMat_t; text: PCvString_t; org: PCvPoint_t; fontFace: Integer; 
                 fontScale: Double; color: PCvScalar_t; thickness: Integer { default: 1 } = 1; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); bottomLeftOrigin: Boolean { default: false } = false); cdecl;
Procedure  pCvputTextV2(img: PCvUMat_t; text: PCvString_t; org: PCvPoint_t; fontFace: Integer; 
                 fontScale: Double; color: PCvScalar_t; thickness: Integer { default: 1 } = 1; 
                 lineType: Integer { default: LINE_8 } = ord(LINE_8); bottomLeftOrigin: Boolean { default: false } = false); cdecl;
Procedure  pCvpyrDown(src: PCvMat_t; dst: PCvMat_t; dstsize: PCvSize_t { default: Size() } = nil; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvpyrDownV2(src: PCvUMat_t; dst: PCvUMat_t; dstsize: PCvSize_t { default: Size() } = nil; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvpyrMeanShiftFiltering(src: PCvMat_t; dst: PCvMat_t; sp: Double; sr: Double; 
                 maxLevel: Integer { default: 1 } = 1; 
                 termcrit: PCvTermCriteria_t { default: TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) } = nil); cdecl;
Procedure  pCvpyrMeanShiftFilteringV2(src: PCvUMat_t; dst: PCvUMat_t; sp: Double; sr: Double; 
                 maxLevel: Integer { default: 1 } = 1; 
                 termcrit: PCvTermCriteria_t { default: TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1) } = nil); cdecl;
Procedure  pCvpyrUp(src: PCvMat_t; dst: PCvMat_t; dstsize: PCvSize_t { default: Size() } = nil; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvpyrUpV2(src: PCvUMat_t; dst: PCvUMat_t; dstsize: PCvSize_t { default: Size() } = nil; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvrandShuffle(dst: PCvMat_t; iterFactor: Double { default: 1. } = 1.0; 
                 rng: PCvRNG_t { default: 0 } = 0); cdecl;
Procedure  pCvrandShuffleV2(dst: PCvUMat_t; iterFactor: Double { default: 1. } = 1.0; 
                 rng: PCvRNG_t { default: 0 } = 0); cdecl;
Procedure  pCvrandn(dst: PCvMat_t; mean: PCvMat_t; stddev: PCvMat_t); cdecl;
Procedure  pCvrandnV2(dst: PCvUMat_t; mean: PCvUMat_t; stddev: PCvUMat_t); cdecl;
Procedure  pCvrandu(dst: PCvMat_t; _low: PCvMat_t; _high: PCvMat_t); cdecl;
Procedure  pCvranduV2(dst: PCvUMat_t; _low: PCvUMat_t; _high: PCvUMat_t); cdecl;
Function   pCvreadOpticalFlow(path: PCvString_t): PCvMat_t; cdecl;
Function   pCvrecoverPose(points1: PCvMat_t; points2: PCvMat_t; cameraMatrix1: PCvMat_t; 
                 distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; distCoeffs2: PCvMat_t; E: PCvMat_t; R: PCvMat_t; 
                 t: PCvMat_t; method: Integer { default: cv::RANSAC } = ord(cv_RANSAC); 
                 prob: Double { default: 0.999 } = 0.999; threshold: Double { default: 1.0 } = 1.0; 
                 mask: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV2(points1: PCvUMat_t; points2: PCvUMat_t; cameraMatrix1: PCvUMat_t; 
                 distCoeffs1: PCvUMat_t; cameraMatrix2: PCvUMat_t; distCoeffs2: PCvUMat_t; E: PCvUMat_t; 
                 R: PCvUMat_t; t: PCvUMat_t; method: Integer { default: cv::RANSAC } = ord(cv_RANSAC); 
                 prob: Double { default: 0.999 } = 0.999; threshold: Double { default: 1.0 } = 1.0; 
                 mask: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV3(E: PCvMat_t; points1: PCvMat_t; points2: PCvMat_t; cameraMatrix: PCvMat_t; 
                 R: PCvMat_t; t: PCvMat_t; mask: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV4(E: PCvUMat_t; points1: PCvUMat_t; points2: PCvUMat_t; 
                 cameraMatrix: PCvUMat_t; R: PCvUMat_t; t: PCvUMat_t; mask: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV5(E: PCvMat_t; points1: PCvMat_t; points2: PCvMat_t; R: PCvMat_t; t: PCvMat_t; 
                 focal: Double { default: 1.0 } = 1.0; pp: PCvPoint2d_t { default: Point2d(0, 0) } = nil; 
                 mask: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV6(E: PCvUMat_t; points1: PCvUMat_t; points2: PCvUMat_t; R: PCvUMat_t; 
                 t: PCvUMat_t; focal: Double { default: 1.0 } = 1.0; 
                 pp: PCvPoint2d_t { default: Point2d(0, 0) } = nil; mask: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV7(E: PCvMat_t; points1: PCvMat_t; points2: PCvMat_t; cameraMatrix: PCvMat_t; 
                 R: PCvMat_t; t: PCvMat_t; distanceThresh: Double; 
                 mask: PCvMat_t { default: Mat() } = nil; triangulatedPoints: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvrecoverPoseV8(E: PCvUMat_t; points1: PCvUMat_t; points2: PCvUMat_t; 
                 cameraMatrix: PCvUMat_t; R: PCvUMat_t; t: PCvUMat_t; distanceThresh: Double; 
                 mask: PCvUMat_t { default: UMat() } = nil; triangulatedPoints: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Procedure  pCvrectangle(img: PCvMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvrectangleV2(img: PCvUMat_t; pt1: PCvPoint_t; pt2: PCvPoint_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvrectangleV3(img: PCvMat_t; rec: PCvRect_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Procedure  pCvrectangleV4(img: PCvUMat_t; rec: PCvRect_t; color: PCvScalar_t; 
                 thickness: Integer { default: 1 } = 1; lineType: Integer { default: LINE_8 } = ord(LINE_8); 
                 shift: Integer { default: 0 } = 0); cdecl;
Function   pCvrectify3Collinear(cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; 
                 distCoeffs2: PCvMat_t; cameraMatrix3: PCvMat_t; distCoeffs3: PCvMat_t; imgpt1: PCvvector_Mat; 
                 imgpt3: PCvvector_Mat; imageSize: PCvSize_t; R12: PCvMat_t; T12: PCvMat_t; R13: PCvMat_t; 
                 T13: PCvMat_t; R1: PCvMat_t; R2: PCvMat_t; R3: PCvMat_t; P1: PCvMat_t; P2: PCvMat_t; 
                 P3: PCvMat_t; Q: PCvMat_t; alpha: Double; newImgSize: PCvSize_t; roi1: PCvRect_t; 
                 roi2: PCvRect_t; flags: Integer): Single; cdecl;
Function   pCvrectify3CollinearV2(cameraMatrix1: PCvUMat_t; distCoeffs1: PCvUMat_t; 
                 cameraMatrix2: PCvUMat_t; distCoeffs2: PCvUMat_t; cameraMatrix3: PCvUMat_t; 
                 distCoeffs3: PCvUMat_t; imgpt1: PCvvector_UMat; imgpt3: PCvvector_UMat; imageSize: PCvSize_t; 
                 R12: PCvUMat_t; T12: PCvUMat_t; R13: PCvUMat_t; T13: PCvUMat_t; R1: PCvUMat_t; 
                 R2: PCvUMat_t; R3: PCvUMat_t; P1: PCvUMat_t; P2: PCvUMat_t; P3: PCvUMat_t; 
                 Q: PCvUMat_t; alpha: Double; newImgSize: PCvSize_t; roi1: PCvRect_t; 
                 roi2: PCvRect_t; flags: Integer): Single; cdecl;
Procedure  pCvreduce(src: PCvMat_t; dst: PCvMat_t; dim: Integer; rtype: Integer; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvreduceV2(src: PCvUMat_t; dst: PCvUMat_t; dim: Integer; rtype: Integer; 
                 dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvreduceArgMax(src: PCvMat_t; dst: PCvMat_t; axis: Integer; 
                 lastIndex: Boolean { default: false } = false); cdecl;
Procedure  pCvreduceArgMaxV2(src: PCvUMat_t; dst: PCvUMat_t; axis: Integer; 
                 lastIndex: Boolean { default: false } = false); cdecl;
Procedure  pCvreduceArgMin(src: PCvMat_t; dst: PCvMat_t; axis: Integer; 
                 lastIndex: Boolean { default: false } = false); cdecl;
Procedure  pCvreduceArgMinV2(src: PCvUMat_t; dst: PCvUMat_t; axis: Integer; 
                 lastIndex: Boolean { default: false } = false); cdecl;
Procedure  pCvremap(src: PCvMat_t; dst: PCvMat_t; map1: PCvMat_t; map2: PCvMat_t; interpolation: Integer; 
                 borderMode: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvremapV2(src: PCvUMat_t; dst: PCvUMat_t; map1: PCvUMat_t; map2: PCvUMat_t; 
                 interpolation: Integer; borderMode: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); 
                 borderValue: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvrepeat(src: PCvMat_t; ny: Integer; nx: Integer; dst: PCvMat_t); cdecl;
Procedure  pCvrepeatV2(src: PCvUMat_t; ny: Integer; nx: Integer; dst: PCvUMat_t); cdecl;
Procedure  pCvreprojectImageTo3D(disparity: PCvMat_t; _3dImage: PCvMat_t; Q: PCvMat_t; 
                 handleMissingValues: Boolean { default: false } = false; ddepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvreprojectImageTo3DV2(disparity: PCvUMat_t; _3dImage: PCvUMat_t; Q: PCvUMat_t; 
                 handleMissingValues: Boolean { default: false } = false; ddepth: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvresize(src: PCvMat_t; dst: PCvMat_t; dsize: PCvSize_t; fx: Double { default: 0 } = 0; 
                 fy: Double { default: 0 } = 0; interpolation: Integer { default: INTER_LINEAR } = ord(INTER_LINEAR)); cdecl;
Procedure  pCvresizeV2(src: PCvUMat_t; dst: PCvUMat_t; dsize: PCvSize_t; fx: Double { default: 0 } = 0; 
                 fy: Double { default: 0 } = 0; interpolation: Integer { default: INTER_LINEAR } = ord(INTER_LINEAR)); cdecl;
Procedure  pCvresizeWindow(winname: PCvString_t; width: Integer; height: Integer); cdecl;
Procedure  pCvresizeWindowV2(winname: PCvString_t; size: PCvSize_t); cdecl;
Procedure  pCvrotate(src: PCvMat_t; dst: PCvMat_t; rotateCode: Integer); cdecl;
Procedure  pCvrotateV2(src: PCvUMat_t; dst: PCvUMat_t; rotateCode: Integer); cdecl;
Function   pCvrotatedRectangleIntersection(rect1: PCvRotatedRect_t; rect2: PCvRotatedRect_t; 
                 intersectingRegion: PCvMat_t): Integer; cdecl;
Function   pCvrotatedRectangleIntersectionV2(rect1: PCvRotatedRect_t; rect2: PCvRotatedRect_t; 
                 intersectingRegion: PCvUMat_t): Integer; cdecl;
Procedure  pCvsamples_addSamplesDataSearchPath(path: PCvString_t); cdecl;
Procedure  pCvsamples_addSamplesDataSearchSubDirectory(subdir: PCvString_t); cdecl;
Function   pCvsamples_findFile(relative_path: PCvString_t; required: Boolean { default: true } = true; 
                 silentMode: Boolean { default: false } = false): PCvString_t; cdecl;
Function   pCvsamples_findFileOrKeep(relative_path: PCvString_t; 
                 silentMode: Boolean { default: false } = false): PCvString_t; cdecl;
Function   pCvsampsonDistance(pt1: PCvMat_t; pt2: PCvMat_t; F: PCvMat_t): Double; cdecl;
Function   pCvsampsonDistanceV2(pt1: PCvUMat_t; pt2: PCvUMat_t; F: PCvUMat_t): Double; cdecl;
Procedure  pCvscaleAdd(src1: PCvMat_t; alpha: Double; src2: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvscaleAddV2(src1: PCvUMat_t; alpha: Double; src2: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvseamlessClone(src: PCvMat_t; dst: PCvMat_t; mask: PCvMat_t; p: PCvPoint_t; blend: PCvMat_t; 
                 flags: Integer); cdecl;
Procedure  pCvseamlessCloneV2(src: PCvUMat_t; dst: PCvUMat_t; mask: PCvUMat_t; p: PCvPoint_t; 
                 blend: PCvUMat_t; flags: Integer); cdecl;
Function   pCvselectROI(windowName: PCvString_t; img: PCvMat_t; 
                 showCrosshair: Boolean { default: true } = true; fromCenter: Boolean { default: false } = false): PCvRect_t; cdecl;
Function   pCvselectROIV2(windowName: PCvString_t; img: PCvUMat_t; 
                 showCrosshair: Boolean { default: true } = true; fromCenter: Boolean { default: false } = false): PCvRect_t; cdecl;
Function   pCvselectROIV3(img: PCvMat_t; showCrosshair: Boolean { default: true } = true; 
                 fromCenter: Boolean { default: false } = false): PCvRect_t; cdecl;
Function   pCvselectROIV4(img: PCvUMat_t; showCrosshair: Boolean { default: true } = true; 
                 fromCenter: Boolean { default: false } = false): PCvRect_t; cdecl;
Procedure  pCvselectROIs(windowName: PCvString_t; img: PCvMat_t; boundingBoxes: PCvvector_Rect; 
                 showCrosshair: Boolean { default: true } = true; fromCenter: Boolean { default: false } = false); cdecl;
Procedure  pCvselectROIsV2(windowName: PCvString_t; img: PCvUMat_t; boundingBoxes: PCvvector_Rect; 
                 showCrosshair: Boolean { default: true } = true; fromCenter: Boolean { default: false } = false); cdecl;
Procedure  pCvsepFilter2D(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; kernelX: PCvMat_t; 
                 kernelY: PCvMat_t; anchor: PCvPoint_t { default: Point(-1,-1) } = nil; 
                 delta: Double { default: 0 } = 0; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvsepFilter2DV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; kernelX: PCvUMat_t; 
                 kernelY: PCvUMat_t; anchor: PCvPoint_t { default: Point(-1,-1) } = nil; 
                 delta: Double { default: 0 } = 0; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvsetIdentity(mtx: PCvMat_t; s: PCvScalar_t { default: Scalar(1) } = nil); cdecl;
Procedure  pCvsetIdentityV2(mtx: PCvUMat_t; s: PCvScalar_t { default: Scalar(1) } = nil); cdecl;
Function   pCvsetLogLevel(level: Integer): Integer; cdecl;
Procedure  pCvsetNumThreads(nthreads: Integer); cdecl;
Procedure  pCvsetRNGSeed(seed: Integer); cdecl;
Procedure  pCvsetTrackbarMax(trackbarname: PCvString_t; winname: PCvString_t; maxval: Integer); cdecl;
Procedure  pCvsetTrackbarMin(trackbarname: PCvString_t; winname: PCvString_t; minval: Integer); cdecl;
Procedure  pCvsetTrackbarPos(trackbarname: PCvString_t; winname: PCvString_t; _pos: Integer); cdecl;
Procedure  pCvsetUseOptimized(onoff: Boolean); cdecl;
Procedure  pCvsetWindowProperty(winname: PCvString_t; prop_id: Integer; prop_value: Double); cdecl;
Procedure  pCvsetWindowTitle(winname: PCvString_t; title: PCvString_t); cdecl;
Function   pCvsolve(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; 
                 flags: Integer { default: DECOMP_LU } = ord(DECOMP_LU)): Boolean; cdecl;
Function   pCvsolveV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 flags: Integer { default: DECOMP_LU } = ord(DECOMP_LU)): Boolean; cdecl;
Function   pCvsolveCubic(coeffs: PCvMat_t; roots: PCvMat_t): Integer; cdecl;
Function   pCvsolveCubicV2(coeffs: PCvUMat_t; roots: PCvUMat_t): Integer; cdecl;
Function   pCvsolveP3P(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; flags: Integer): Integer; cdecl;
Function   pCvsolveP3PV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; rvecs: PCvvector_UMat; tvecs: PCvvector_UMat; flags: Integer): Integer; cdecl;
Function   pCvsolvePnP(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; 
                 useExtrinsicGuess: Boolean { default: false } = false; flags: Integer { default: SOLVEPNP_ITERATIVE } = ord(SOLVEPNP_ITERATIVE)): Boolean; cdecl;
Function   pCvsolvePnPV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; rvec: PCvUMat_t; tvec: PCvUMat_t; 
                 useExtrinsicGuess: Boolean { default: false } = false; flags: Integer { default: SOLVEPNP_ITERATIVE } = ord(SOLVEPNP_ITERATIVE)): Boolean; cdecl;
Function   pCvsolvePnPGeneric(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvecs: PCvvector_Mat; tvecs: PCvvector_Mat; 
                 useExtrinsicGuess: Boolean { default: false } = false; 
                 flags: TCvSolvePnPMethod { default: SOLVEPNP_ITERATIVE } = TCvSolvePnPMethod.SOLVEPNP_ITERATIVE; rvec: PCvMat_t { default: Mat() } = nil; 
                 tvec: PCvMat_t { default: Mat() } = nil; reprojectionError: PCvMat_t { default: Mat() } = nil): Integer; cdecl;
Function   pCvsolvePnPGenericV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; rvecs: PCvvector_UMat; tvecs: PCvvector_UMat; 
                 useExtrinsicGuess: Boolean { default: false } = false; 
                 flags: TCvSolvePnPMethod { default: SOLVEPNP_ITERATIVE } = TCvSolvePnPMethod.SOLVEPNP_ITERATIVE; rvec: PCvUMat_t { default: UMat() } = nil; 
                 tvec: PCvUMat_t { default: UMat() } = nil; reprojectionError: PCvUMat_t { default: UMat() } = nil): Integer; cdecl;
Function   pCvsolvePnPRansac(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; 
                 useExtrinsicGuess: Boolean { default: false } = false; iterationsCount: Integer { default: 100 } = 100; 
                 reprojectionError: Single { default: 8.0 } = 8.0; confidence: Double { default: 0.99 } = 0.99; 
                 inliers: PCvMat_t { default: Mat() } = nil; flags: Integer { default: SOLVEPNP_ITERATIVE } = ord(SOLVEPNP_ITERATIVE)): Boolean; cdecl;
Function   pCvsolvePnPRansacV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; rvec: PCvUMat_t; tvec: PCvUMat_t; 
                 useExtrinsicGuess: Boolean { default: false } = false; iterationsCount: Integer { default: 100 } = 100; 
                 reprojectionError: Single { default: 8.0 } = 8.0; confidence: Double { default: 0.99 } = 0.99; 
                 inliers: PCvUMat_t { default: UMat() } = nil; 
                 flags: Integer { default: SOLVEPNP_ITERATIVE } = ord(SOLVEPNP_ITERATIVE)): Boolean; cdecl;
Function   pCvsolvePnPRansacV3(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; inliers: PCvMat_t; 
                 params: PCvUsacParams_t { default: UsacParams() } = nil): Boolean; cdecl;
Function   pCvsolvePnPRansacV4(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; rvec: PCvUMat_t; tvec: PCvUMat_t; inliers: PCvUMat_t; 
                 params: PCvUsacParams_t { default: UsacParams() } = nil): Boolean; cdecl;
Procedure  pCvsolvePnPRefineLM(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON) } = nil); cdecl;
Procedure  pCvsolvePnPRefineLMV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; 
                 cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; rvec: PCvUMat_t; tvec: PCvUMat_t; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON) } = nil); cdecl;
Procedure  pCvsolvePnPRefineVVS(objectPoints: PCvMat_t; imagePoints: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; rvec: PCvMat_t; tvec: PCvMat_t; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON) } = nil; VVSlambda: Double { default: 1 } = 1); cdecl;
Procedure  pCvsolvePnPRefineVVSV2(objectPoints: PCvUMat_t; imagePoints: PCvUMat_t; 
                 cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; rvec: PCvUMat_t; tvec: PCvUMat_t; 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON) } = nil; VVSlambda: Double { default: 1 } = 1); cdecl;
Function   pCvsolvePoly(coeffs: PCvMat_t; roots: PCvMat_t; maxIters: Integer { default: 300 } = 300): Double; cdecl;
Function   pCvsolvePolyV2(coeffs: PCvUMat_t; roots: PCvUMat_t; maxIters: Integer { default: 300 } = 300): Double; cdecl;
Procedure  pCvsort(src: PCvMat_t; dst: PCvMat_t; flags: Integer); cdecl;
Procedure  pCvsortV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer); cdecl;
Procedure  pCvsortIdx(src: PCvMat_t; dst: PCvMat_t; flags: Integer); cdecl;
Procedure  pCvsortIdxV2(src: PCvUMat_t; dst: PCvUMat_t; flags: Integer); cdecl;
Procedure  pCvspatialGradient(src: PCvMat_t; dx: PCvMat_t; dy: PCvMat_t; 
                 ksize: Integer { default: 3 } = 3; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvspatialGradientV2(src: PCvUMat_t; dx: PCvUMat_t; dy: PCvUMat_t; 
                 ksize: Integer { default: 3 } = 3; borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvsplit(m: PCvMat_t; mv: PCvvector_Mat); cdecl;
Procedure  pCvsplitV2(m: PCvUMat_t; mv: PCvvector_UMat); cdecl;
Procedure  pCvsqrBoxFilter(src: PCvMat_t; dst: PCvMat_t; ddepth: Integer; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1, -1) } = nil; normalize: Boolean { default: true } = true; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvsqrBoxFilterV2(src: PCvUMat_t; dst: PCvUMat_t; ddepth: Integer; ksize: PCvSize_t; 
                 anchor: PCvPoint_t { default: Point(-1, -1) } = nil; normalize: Boolean { default: true } = true; 
                 borderType: Integer { default: BORDER_DEFAULT } = ord(BORDER_DEFAULT)); cdecl;
Procedure  pCvsqrt(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvsqrtV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Function   pCvstartWindowThread(): Integer; cdecl;
Function   pCvstereoCalibrate(objectPoints: PCvvector_Mat; imagePoints1: PCvvector_Mat; 
                 imagePoints2: PCvvector_Mat; cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; 
                 distCoeffs2: PCvMat_t; imageSize: PCvSize_t; R: PCvMat_t; T: PCvMat_t; E: PCvMat_t; F: PCvMat_t; 
                 flags: Integer { default: CALIB_FIX_INTRINSIC } = ord(CALIB_FIX_INTRINSIC); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) } = nil): Double; cdecl;
Function   pCvstereoCalibrateV2(objectPoints: PCvvector_UMat; imagePoints1: PCvvector_UMat; 
                 imagePoints2: PCvvector_UMat; cameraMatrix1: PCvUMat_t; distCoeffs1: PCvUMat_t; 
                 cameraMatrix2: PCvUMat_t; distCoeffs2: PCvUMat_t; imageSize: PCvSize_t; R: PCvUMat_t; 
                 T: PCvUMat_t; E: PCvUMat_t; F: PCvUMat_t; 
                 flags: Integer { default: CALIB_FIX_INTRINSIC } = ord(CALIB_FIX_INTRINSIC); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) } = nil): Double; cdecl;
Function   pCvstereoCalibrateExtended(objectPoints: PCvvector_Mat; imagePoints1: PCvvector_Mat; 
                 imagePoints2: PCvvector_Mat; cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; 
                 cameraMatrix2: PCvMat_t; distCoeffs2: PCvMat_t; imageSize: PCvSize_t; R: PCvMat_t; 
                 T: PCvMat_t; E: PCvMat_t; F: PCvMat_t; perViewErrors: PCvMat_t; 
                 flags: Integer { default: CALIB_FIX_INTRINSIC } = ord(CALIB_FIX_INTRINSIC); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) } = nil): Double; cdecl;
Function   pCvstereoCalibrateExtendedV2(objectPoints: PCvvector_UMat; imagePoints1: PCvvector_UMat; 
                 imagePoints2: PCvvector_UMat; cameraMatrix1: PCvUMat_t; distCoeffs1: PCvUMat_t; 
                 cameraMatrix2: PCvUMat_t; distCoeffs2: PCvUMat_t; imageSize: PCvSize_t; R: PCvUMat_t; 
                 T: PCvUMat_t; E: PCvUMat_t; F: PCvUMat_t; perViewErrors: PCvUMat_t; 
                 flags: Integer { default: CALIB_FIX_INTRINSIC } = ord(CALIB_FIX_INTRINSIC); 
                 criteria: PCvTermCriteria_t { default: TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6) } = nil): Double; cdecl;
Procedure  pCvstereoRectify(cameraMatrix1: PCvMat_t; distCoeffs1: PCvMat_t; cameraMatrix2: PCvMat_t; 
                 distCoeffs2: PCvMat_t; imageSize: PCvSize_t; R: PCvMat_t; T: PCvMat_t; R1: PCvMat_t; R2: PCvMat_t; 
                 P1: PCvMat_t; P2: PCvMat_t; Q: PCvMat_t; 
                 flags: Integer { default: CALIB_ZERO_DISPARITY } = ord(CALIB_ZERO_DISPARITY); alpha: Double { default: -1 } = ord(-1); 
                 newImageSize: PCvSize_t { default: Size() } = nil; validPixROI1: PCvRect_t { default: 0 } = 0; 
                 validPixROI2: PCvRect_t { default: 0 } = 0); cdecl;
Procedure  pCvstereoRectifyV2(cameraMatrix1: PCvUMat_t; distCoeffs1: PCvUMat_t; cameraMatrix2: PCvUMat_t; 
                 distCoeffs2: PCvUMat_t; imageSize: PCvSize_t; R: PCvUMat_t; T: PCvUMat_t; R1: PCvUMat_t; 
                 R2: PCvUMat_t; P1: PCvUMat_t; P2: PCvUMat_t; Q: PCvUMat_t; 
                 flags: Integer { default: CALIB_ZERO_DISPARITY } = ord(CALIB_ZERO_DISPARITY); alpha: Double { default: -1 } = ord(-1); 
                 newImageSize: PCvSize_t { default: Size() } = nil; validPixROI1: PCvRect_t { default: 0 } = 0; 
                 validPixROI2: PCvRect_t { default: 0 } = 0); cdecl;
Function   pCvstereoRectifyUncalibrated(points1: PCvMat_t; points2: PCvMat_t; F: PCvMat_t; 
                 imgSize: PCvSize_t; H1: PCvMat_t; H2: PCvMat_t; 
                 threshold: Double { default: 5 } = 5): Boolean; cdecl;
Function   pCvstereoRectifyUncalibratedV2(points1: PCvUMat_t; points2: PCvUMat_t; F: PCvUMat_t; 
                 imgSize: PCvSize_t; H1: PCvUMat_t; H2: PCvUMat_t; 
                 threshold: Double { default: 5 } = 5): Boolean; cdecl;
Procedure  pCvstylization(src: PCvMat_t; dst: PCvMat_t; sigma_s: Single { default: 60 } = 60; 
                 sigma_r: Single { default: 0.45f } = 0.45); cdecl;
Procedure  pCvstylizationV2(src: PCvUMat_t; dst: PCvUMat_t; sigma_s: Single { default: 60 } = 60; 
                 sigma_r: Single { default: 0.45f } = 0.45); cdecl;
Procedure  pCvsubtract(src1: PCvMat_t; src2: PCvMat_t; dst: PCvMat_t; 
                 mask: PCvMat_t { default: Mat() } = nil; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Procedure  pCvsubtractV2(src1: PCvUMat_t; src2: PCvUMat_t; dst: PCvUMat_t; 
                 mask: PCvUMat_t { default: UMat() } = nil; dtype: Integer { default: -1 } = ord(-1)); cdecl;
Function   pCvsumElems(src: PCvMat_t): PCvScalar_t; cdecl;
Function   pCvsumElemsV2(src: PCvUMat_t): PCvScalar_t; cdecl;
Procedure  pCvtextureFlattening(src: PCvMat_t; mask: PCvMat_t; dst: PCvMat_t; 
                 low_threshold: Single { default: 30 } = 30; high_threshold: Single { default: 45 } = 45; 
                 kernel_size: Integer { default: 3 } = 3); cdecl;
Procedure  pCvtextureFlatteningV2(src: PCvUMat_t; mask: PCvUMat_t; dst: PCvUMat_t; 
                 low_threshold: Single { default: 30 } = 30; high_threshold: Single { default: 45 } = 45; 
                 kernel_size: Integer { default: 3 } = 3); cdecl;
Function   pCvthreshold(src: PCvMat_t; dst: PCvMat_t; thresh: Double; maxval: Double; _type: Integer): Double; cdecl;
Function   pCvthresholdV2(src: PCvUMat_t; dst: PCvUMat_t; thresh: Double; maxval: Double; _type: Integer): Double; cdecl;
Function   pCvtrace(mtx: PCvMat_t): PCvScalar_t; cdecl;
Function   pCvtraceV2(mtx: PCvUMat_t): PCvScalar_t; cdecl;
Procedure  pCvtransform(src: PCvMat_t; dst: PCvMat_t; m: PCvMat_t); cdecl;
Procedure  pCvtransformV2(src: PCvUMat_t; dst: PCvUMat_t; m: PCvUMat_t); cdecl;
Procedure  pCvtranspose(src: PCvMat_t; dst: PCvMat_t); cdecl;
Procedure  pCvtransposeV2(src: PCvUMat_t; dst: PCvUMat_t); cdecl;
Procedure  pCvtransposeND(src: PCvMat_t; order: PCvvector_int; dst: PCvMat_t); cdecl;
Procedure  pCvtransposeNDV2(src: PCvUMat_t; order: PCvvector_int; dst: PCvUMat_t); cdecl;
Procedure  pCvtriangulatePoints(projMatr1: PCvMat_t; projMatr2: PCvMat_t; projPoints1: PCvMat_t; 
                 projPoints2: PCvMat_t; points4D: PCvMat_t); cdecl;
Procedure  pCvtriangulatePointsV2(projMatr1: PCvUMat_t; projMatr2: PCvUMat_t; projPoints1: PCvUMat_t; 
                 projPoints2: PCvUMat_t; points4D: PCvUMat_t); cdecl;
Procedure  pCvundistort(src: PCvMat_t; dst: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; 
                 newCameraMatrix: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvundistortV2(src: PCvUMat_t; dst: PCvUMat_t; cameraMatrix: PCvUMat_t; distCoeffs: PCvUMat_t; 
                 newCameraMatrix: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvundistortImagePoints(src: PCvMat_t; dst: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; 
                 arg1: PCvTermCriteria_t { default: TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01) } = nil); cdecl;
Procedure  pCvundistortImagePointsV2(src: PCvUMat_t; dst: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; 
                 arg1: PCvTermCriteria_t { default: TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01) } = nil); cdecl;
Procedure  pCvundistortPoints(src: PCvMat_t; dst: PCvMat_t; cameraMatrix: PCvMat_t; distCoeffs: PCvMat_t; 
                 R: PCvMat_t { default: Mat() } = nil; P: PCvMat_t { default: Mat() } = nil); cdecl;
Procedure  pCvundistortPointsV2(src: PCvUMat_t; dst: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; R: PCvUMat_t { default: UMat() } = nil; 
                 P: PCvUMat_t { default: UMat() } = nil); cdecl;
Procedure  pCvundistortPointsIter(src: PCvMat_t; dst: PCvMat_t; cameraMatrix: PCvMat_t; 
                 distCoeffs: PCvMat_t; R: PCvMat_t; P: PCvMat_t; criteria: PCvTermCriteria_t); cdecl;
Procedure  pCvundistortPointsIterV2(src: PCvUMat_t; dst: PCvUMat_t; cameraMatrix: PCvUMat_t; 
                 distCoeffs: PCvUMat_t; R: PCvUMat_t; P: PCvUMat_t; criteria: PCvTermCriteria_t); cdecl;
Function   pCvuseOptimized(): Boolean; cdecl;
Function   pCvutils_dumpBool(argument: Boolean): PCvString_t; cdecl;
Function   pCvutils_dumpCString(argument: PAnsiChar): PCvString_t; cdecl;
Function   pCvutils_dumpDouble(argument: Double): PCvString_t; cdecl;
Function   pCvutils_dumpFloat(argument: Single): PCvString_t; cdecl;
Function   pCvutils_dumpInputArray(argument: PCvMat_t): PCvString_t; cdecl;
Function   pCvutils_dumpInputArrayV2(argument: PCvUMat_t): PCvString_t; cdecl;
Function   pCvutils_dumpInputArrayOfArrays(argument: PCvvector_Mat): PCvString_t; cdecl;
Function   pCvutils_dumpInputArrayOfArraysV2(argument: PCvvector_UMat): PCvString_t; cdecl;
Function   pCvutils_dumpInputOutputArray(argument: PCvMat_t): PCvString_t; cdecl;
Function   pCvutils_dumpInputOutputArrayV2(argument: PCvUMat_t): PCvString_t; cdecl;
Function   pCvutils_dumpInputOutputArrayOfArrays(argument: PCvvector_Mat): PCvString_t; cdecl;
Function   pCvutils_dumpInputOutputArrayOfArraysV2(argument: PCvvector_UMat): PCvString_t; cdecl;
Function   pCvutils_dumpInt(argument: Integer): PCvString_t; cdecl;
Function   pCvutils_dumpRange(argument: PCvRange_t): PCvString_t; cdecl;
Function   pCvutils_dumpRect(argument: PCvRect_t): PCvString_t; cdecl;
Function   pCvutils_dumpRotatedRect(argument: PCvRotatedRect_t): PCvString_t; cdecl;
Function   pCvutils_dumpSizeT(argument: UInt64): PCvString_t; cdecl;
Function   pCvutils_dumpString(argument: PCvString_t): PCvString_t; cdecl;
Function   pCvutils_dumpTermCriteria(argument: PCvTermCriteria_t): PCvString_t; cdecl;
Function   pCvutils_dumpVectorOfDouble(vec: PCvvector_double): PCvString_t; cdecl;
Function   pCvutils_dumpVectorOfInt(vec: PCvvector_int): PCvString_t; cdecl;
Function   pCvutils_dumpVectorOfRect(vec: PCvvector_Rect): PCvString_t; cdecl;
Function   pCvutils_fs_getCacheDirectoryForDownloads(): PCvString_t; cdecl;
Procedure  pCvutils_generateVectorOfInt(len: UInt64; vec: PCvvector_int); cdecl;
Procedure  pCvutils_generateVectorOfMat(len: UInt64; rows: Integer; cols: Integer; dtype: Integer; 
                 vec: PCvvector_Mat); cdecl;
Procedure  pCvutils_generateVectorOfRect(len: UInt64; vec: PCvvector_Rect); cdecl;
Function   pCvutils_nested_testEchoBooleanFunction(flag: Boolean): Boolean; cdecl;
Function   pCvutils_testAsyncArray(argument: PCvMat_t): PCvAsyncArray_t; cdecl;
Function   pCvutils_testAsyncArrayV2(argument: PCvUMat_t): PCvAsyncArray_t; cdecl;
Function   pCvutils_testAsyncException(): PCvAsyncArray_t; cdecl;
Function   pCvutils_testOverloadResolution(value: Integer; 
                 point: PCvPoint_t { default: Point(42, 24) } = nil): PCvString_t; cdecl;
Function   pCvutils_testOverloadResolutionV2(rect: PCvRect_t): PCvString_t; cdecl;
Function   pCvutils_testOverwriteNativeMethod(argument: Integer): Integer; cdecl;
Procedure  pCvutils_testRaiseGeneralException(); cdecl;
Function   pCvutils_testReservedKeywordConversion(positional_argument: Integer; 
                 lambda: Integer { default: 2 } = 2; from: Integer { default: 3 } = 3): PCvString_t; cdecl;
Function   pCvutils_testRotatedRect(x: Single; y: Single; w: Single; h: Single; angle: Single): PCvRotatedRect_t; cdecl;
Function   pCvutils_testRotatedRectVector(x: Single; y: Single; w: Single; h: Single; angle: Single): PCvvector_RotatedRect; cdecl;
Procedure  pCvvalidateDisparity(disparity: PCvMat_t; cost: PCvMat_t; minDisparity: Integer; 
                 numberOfDisparities: Integer; disp12MaxDisp: Integer { default: 1 } = 1); cdecl;
Procedure  pCvvalidateDisparityV2(disparity: PCvUMat_t; cost: PCvUMat_t; minDisparity: Integer; 
                 numberOfDisparities: Integer; disp12MaxDisp: Integer { default: 1 } = 1); cdecl;
Procedure  pCvvconcat(src: PCvvector_Mat; dst: PCvMat_t); cdecl;
Procedure  pCvvconcatV2(src: PCvvector_UMat; dst: PCvUMat_t); cdecl;
Function   pCvwaitKey(delay: Integer { default: 0 } = 0): Integer; cdecl;
Function   pCvwaitKeyEx(delay: Integer { default: 0 } = 0): Integer; cdecl;
Procedure  pCvwarpAffine(src: PCvMat_t; dst: PCvMat_t; M: PCvMat_t; dsize: PCvSize_t; 
                 flags: Integer { default: INTER_LINEAR } = ord(INTER_LINEAR); borderMode: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); 
                 borderValue: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvwarpAffineV2(src: PCvUMat_t; dst: PCvUMat_t; M: PCvUMat_t; dsize: PCvSize_t; 
                 flags: Integer { default: INTER_LINEAR } = ord(INTER_LINEAR); borderMode: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); 
                 borderValue: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvwarpPerspective(src: PCvMat_t; dst: PCvMat_t; M: PCvMat_t; dsize: PCvSize_t; 
                 flags: Integer { default: INTER_LINEAR } = ord(INTER_LINEAR); borderMode: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); 
                 borderValue: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvwarpPerspectiveV2(src: PCvUMat_t; dst: PCvUMat_t; M: PCvUMat_t; dsize: PCvSize_t; 
                 flags: Integer { default: INTER_LINEAR } = ord(INTER_LINEAR); 
                 borderMode: Integer { default: BORDER_CONSTANT } = ord(BORDER_CONSTANT); borderValue: PCvScalar_t { default: Scalar() } = nil); cdecl;
Procedure  pCvwarpPolar(src: PCvMat_t; dst: PCvMat_t; dsize: PCvSize_t; center: PCvPoint2f_t; 
                 maxRadius: Double; flags: Integer); cdecl;
Procedure  pCvwarpPolarV2(src: PCvUMat_t; dst: PCvUMat_t; dsize: PCvSize_t; center: PCvPoint2f_t; 
                 maxRadius: Double; flags: Integer); cdecl;
Procedure  pCvwatershed(image: PCvMat_t; markers: PCvMat_t); cdecl;
Procedure  pCvwatershedV2(image: PCvUMat_t; markers: PCvUMat_t); cdecl;
Function   pCvwriteOpticalFlow(path: PCvString_t; flow: PCvMat_t): Boolean; cdecl;
Function   pCvwriteOpticalFlowV2(path: PCvString_t; flow: PCvUMat_t): Boolean; cdecl;
